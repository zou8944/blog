<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zou8944.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
<meta property="og:type" content="website">
<meta property="og:title" content="果冻 | Jelly">
<meta property="og:url" content="https://zou8944.com/index.html">
<meta property="og:site_name" content="果冻 | Jelly">
<meta property="og:description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="果冻 | Jelly">
<meta property="article:tag" content="果冻 博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zou8944.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>果冻 | Jelly</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">果冻 | Jelly</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">果冻的碎碎念</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">果冻 | Jelly</p>
  <div class="site-description" itemprop="description">Beat Jelly; Hit Jelly; Kill Jelly.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E7%9E%85%E7%9E%85%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-chou-chou-dong-tai-dai-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%9E%85%E7%9E%85%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-chou-chou-dong-tai-dai-li/" class="post-title-link" itemprop="url">瞅瞅动态代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-03 15:38:51" itemprop="dateCreated datePublished" datetime="2021-11-03T15:38:51+08:00">2021-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>动态代理说大不大，说小不小，可深可浅。往深了说还是对JVM的了解程度要足够深入，时间篇幅有限，本文专注于回答如下问题，不作更深入的探讨。</p>
<ul>
<li>JDK和Cglib动态代理，分别怎么使用</li>
<li>JDK动态代理的原理</li>
<li>Cglib动态代理的原理</li>
<li>为什么JDK动态代理一定要实现接口，而Cglib就不用？</li>
<li>JDK和Cglib，本质上有什么区别？</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E7%9E%85%E7%9E%85%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-chou-chou-dong-tai-dai-li/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E6%88%91%E4%B8%8D%E4%BC%9AJava%E5%8F%8D%E5%B0%84-wo-bu-hui-java-fan-she/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%88%91%E4%B8%8D%E4%BC%9AJava%E5%8F%8D%E5%B0%84-wo-bu-hui-java-fan-she/" class="post-title-link" itemprop="url">我不会Java反射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-21 18:09:05" itemprop="dateCreated datePublished" datetime="2021-10-21T18:09:05+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">后端 | 编程语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我会写Java反射，我知道反射是用来获取、改变程序运行时状态的方式，通过反射API我们能够获取类对象、类的方法、成员变量、注解等。</p>
<p>我不会写Java反射，我不知道Type和Class有啥关系，ParameteredType、TypeVariable呢？</p>
<p>我会Java反射吗？不，我不会。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E6%88%91%E4%B8%8D%E4%BC%9AJava%E5%8F%8D%E5%B0%84-wo-bu-hui-java-fan-she/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0%20-%20JMH-%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0-jmh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0%20-%20JMH-%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0-jmh/" class="post-title-link" itemprop="url">工具快手记 - JMH</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-20 12:04:53 / 修改时间：12:07:20" itemprop="dateCreated datePublished" datetime="2021-10-20T12:04:53+08:00">2021-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>站在巨人的肩膀上，JMH是一个工具，不打算深入研究它，只求能够正确使用，网上关于它的使用方法讲的还挺全面的，就直接看他们吧。</p>
<p>这篇文章包含基本使用方法、注意事项、IEAD插件、JMH可视化工具的介绍等：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1644001?from=article.detail.1378150">性能调优必备利器之 JMH</a></p>
<p>这篇文章包含较为深层次的解释：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1350814?from=article.detail.1378150">JAVA拾遗 — JMH与8个代码陷阱</a></p>
<p>当然最重要的还有官方例程：<a target="_blank" rel="noopener" href="https://github.com/lexburner/JMH-samples">JMH给的38个例子</a></p>
<p>作为补充，我添加了所有注解的说明，还有自己使用中遇到的问题</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0%20-%20JMH-%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0-jmh/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%85%AD%20-%20Protobuf-xu-lie-hua-tan-suo-zhi-liu--protobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%85%AD%20-%20Protobuf-xu-lie-hua-tan-suo-zhi-liu--protobuf/" class="post-title-link" itemprop="url">序列化探索之六 - Protobuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-18 18:18:56" itemprop="dateCreated datePublished" datetime="2021-10-18T18:18:56+08:00">2021-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序列化探索之Protobuf"><a href="#序列化探索之Protobuf" class="headerlink" title="序列化探索之Protobuf"></a>序列化探索之Protobuf</h1><p>Protobuf是谷歌提出的一种高压缩比的序列化格式，二进制，不可读，语言无关，平台无关。拥有自己的语法规则，压缩编码算法，并提供主流语言的API生成器（即Protobuf编译器），其序列化结果很小，能够有效节省带宽。</p>
<p>掌握Protobuf，需要比较了解三个方面，其中，如果只是单纯滴使用，前两个方面即可。</p>
<ul>
<li>proto语法规则，即proto文件的语法规则</li>
<li>具体语言的API生成及使用规则，即通过proto文件生成对应语言的代码</li>
<li>序列化和反序列化算法</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>截止目前，proto有两个版本，proto2和proto3，我们关注proto3。这里展示一个完整的场景，考虑一个获取资源的rpc协议</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;resource.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.gitee.floyd.serialization.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个类一个文件</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ResourceService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> getResource (GetResourceRequest) <span class="keyword">returns</span> (GetResourceResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetResourceRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> resourceId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetResourceResponse</span> </span>&#123;</span><br><span class="line">  Resource resource = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源定义在这里</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.gitee.floyd.serialization.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义资源类型</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编号1已经被以前使用了</span></span><br><span class="line">  reserved <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型枚举</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    RECORD = <span class="number">0</span>;</span><br><span class="line">    TAG = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录的具体内容</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">RecordData</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> content = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> images = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标签的具体内容</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">TagData</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> title = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 资源ID</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 资源类型</span></span><br><span class="line">  Type type = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 记录和标签同时只会出现一个</span></span><br><span class="line">  <span class="keyword">oneof</span> data &#123;</span><br><span class="line">    RecordData record = <span class="number">4</span>;</span><br><span class="line">    TagData tag = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 还可以塞一些其它的东西</span></span><br><span class="line">  google.protobuf.Any other = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 以map的形式塞一些其它的东西</span></span><br><span class="line">  map&lt;<span class="built_in">string</span>, google.protobuf.Any&gt; otherMap = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就上面用到的进行说明，也就七七八八了，其它的可以参考官方文档自己去补。</p>
<h3 id="proto结构"><a href="#proto结构" class="headerlink" title="proto结构"></a>proto结构</h3><ul>
<li>语法版本声明，如果不声明，默认为proto2</li>
<li>导入的proto依赖</li>
<li>包声明</li>
<li>可选参数设置</li>
<li>service声明</li>
<li>消息声明</li>
</ul>
<p>其中，除了消息声明，其它都不是必须的，主要的语法内容，也集中在消息声明</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>完整的类型声明参考<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">官方文档</a>，总结如下</p>
<ul>
<li>int32：占用字节数是变化的；能表示负数，但效率不是很高</li>
<li>uint32：占用字节数是变化的；无符号</li>
<li>sint32：占用字节数是变化的；能表示负数，效率较高</li>
<li>fixed32：定长，当数字真的非常大时，它比uint32更有效率</li>
<li>sfixed32：同上，只不过是有符号的</li>
<li>string：UTF8编码，最长2^32个字节</li>
<li>bytes：最长2^32个字节</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举定义参考上面的Resource.Type，要点</p>
<ul>
<li>必须有一个的编号是0，以便设置默认值；且必须是第一个元素，以便于proto2兼容</li>
<li>由于其实际上是使用变长编码，因此编号尽量不好是负数</li>
</ul>
<h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><p><strong>repeated</strong></p>
<p>字段只有单数和复数，复数用repeated修饰符，对应的Java中的集合。</p>
<p><strong>oneof</strong></p>
<ul>
<li><p>可使用oneof设置字段多选一，但是使用之前需要使用hasxxx()方法查看是否有值。</p>
</li>
<li><p>oneof里面不能使用repeated</p>
</li>
<li><p>序列化时，如果为多个字段都设置值，只有最后一个设定的值会被保留，其它会被清除，反序列化同理</p>
</li>
<li><p>针对oneof的版本升级问题一般不建议做，会有丢失数据的问题</p>
<p>比如新版本将其中一个元素移出去了，那么新的协议得到的序列化结果用旧的协议来解析，则移出去那个元素有值，oneof本身内部有一个有效值，由于旧版本都在oneof内部，因此会丢失一个对新版本来说有效的值。</p>
</li>
</ul>
<p><strong>map</strong></p>
<ul>
<li>key可以是除了浮点数、bytes和枚举之外的任意值</li>
<li>value可以是除了map之外的任意值</li>
<li>map不能是repeated</li>
<li>map内顺序不被保证</li>
</ul>
<p><strong>Any</strong></p>
<ul>
<li>能够包含任意被序列化为bytes的类型</li>
<li>有专门的方法去包装和拆解它：pack()和unpack()</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>一旦一个编号被使用，在之后的升级中，它将不能再被使用，否则会导致反序列化出错</li>
<li>字段编号并非无穷，在1到2^29次方之间；但19000到19999之间的是Protocol Buffers预留的，不能使用</li>
<li>如果不给字段赋值，将会设置为默认值，各种类型默认值如下<ul>
<li>字符串：空串</li>
<li>字节数组：空数组</li>
<li>bool：false</li>
<li>数字：0</li>
<li>枚举：编号是0的那个值</li>
<li>消息字段：取决于具体语言，Kotlin和Java中</li>
</ul>
</li>
<li>proto的导入不可跨层传递，除非用<code>import public</code>，但这在Java中是不支持的</li>
<li>protobuf可以和Json之间直接映射，有兴趣可以去研究一下</li>
</ul>
<h2 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2><p>Protobuf序列化的目标单位是一条消息（message），其算法，就是一个压缩算法，总体要点有几个</p>
<ul>
<li>以序号替代字段名</li>
<li>对一般的数字类型和布尔采用变长表示法，这样一个int32类型的字段最低只要一个字节即可表示完成</li>
<li>将所有字段类型分为几类，分别有不同的表示方法</li>
<li>对string或自定义的结构化类型，只是多了一个长度标识</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>下面以一个序列化说明</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> content = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">string</span> type = <span class="number">2</span>;</span><br><span class="line">	Data data = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照如下设置值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = 2</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;R&quot;</span> <span class="comment"># UTF8编码为：</span></span><br><span class="line">data.content = <span class="string">&quot;我&quot;</span> <span class="comment"># UTF8编码为</span></span><br></pre></td></tr></table></figure>

<p>其对应的代码为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resourceBuilder = Resource.newBuilder()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = resourceBuilder.dataBuilder.setContent(<span class="string">&quot;我&quot;</span>).build()</span><br><span class="line">    <span class="keyword">val</span> resource = Resource.newBuilder()</span><br><span class="line">        .setId(<span class="number">2</span>)</span><br><span class="line">        .setType(<span class="string">&quot;R&quot;</span>)</span><br><span class="line">        .setData(<span class="keyword">data</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> buffer = ByteArrayOutputStream()</span><br><span class="line">    resource.writeTo(buffer)</span><br><span class="line">    println(buffer.toByteArray().toHexString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的序列化结果将是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08021201521a050a03e68891</span><br></pre></td></tr></table></figure>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>二进制流组成：字段编号&lt;&lt;3 + 编码类型 + 字段值</p>
<p>字段值为复杂类型时，将会递归使用上述编码方式</p>
<p>编码类型如下</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Meaning</th>
<th align="left">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">Varint</td>
<td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">64-bit</td>
<td align="left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Length-delimited</td>
<td align="left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Start group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">End group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">32-bit</td>
<td align="left">fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<h3 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h3><p>现在我们再来看上面的输出：</p>
<p>08 -&gt; 00001 000 ：字段编号为1，类型为0</p>
<p>02 -&gt; 0000 0010 ：字段值为2</p>
<p>12 -&gt; 00010 010 ：字段编号为2，类型为2，即复杂字段，这个类型的下一个字节标识了长度</p>
<p>01 -&gt; 0000 0001 ：字段编号为2的字段值长度为1</p>
<p>52 -&gt; 0101 0010 ：字段编号为2的字段值的UTF8编码，即”R“</p>
<p>1a -&gt; 00011 010 ：字段编号为3，类型为2</p>
<p>05 -&gt; 0000 0101 ：字段编号为3的字段值长度为5，对应我们的嵌套类型Data</p>
<p>​    0a -&gt; 00001 010 ：字段编号为1，类型为2</p>
<p>​    03 -&gt; 0000 0011 ：字段编号为1的字段值长度为3</p>
<p>​    e68891 -&gt; 字段编号为1的字段值的UTF8编码，即”我“</p>
<p>结束</p>
<h3 id="如何做到版本兼容"><a href="#如何做到版本兼容" class="headerlink" title="如何做到版本兼容"></a>如何做到版本兼容</h3><p>由于它是根据字段编号标识字段，反序列化时，遇到不认识的字段编号会直接忽略。因此版本兼容的方式就是，字段编号只增不减，不可与之前的编号复用。复用在protobuf里是绝对不允许的。</p>
<h2 id="API生成规则"><a href="#API生成规则" class="headerlink" title="API生成规则"></a>API生成规则</h2><p>使用protobuf编译器，能够生成对应语言的代码，我们主要看Java和Kotlin，由于Kotlin是在Java生成的基础上生成的，因此一起讲了。</p>
<p>其主要能力，是对proto中定义的消息进行构建，然后提供转换为流的方式；如果加上特定RPC插件，还可以生成Service的代码。</p>
<h3 id="Java文件生成"><a href="#Java文件生成" class="headerlink" title="Java文件生成"></a>Java文件生成</h3><ul>
<li>文件拆分：如果设置了<code>option java_multiple_files = true;</code>，则会按照顶层的Service和Message分别生成多个Java源文件</li>
<li>包名：如果设置了<code>option java_package = &quot;xx.xx.xx.xxx&quot;;</code>，则以它为准；否则以proto文件定义的package为准</li>
<li>字段名：proto中为小写+下划线，Java文件中转换为小驼峰命名</li>
</ul>
<h3 id="关键字段类型"><a href="#关键字段类型" class="headerlink" title="关键字段类型"></a>关键字段类型</h3><ul>
<li>repeated：转换为ProtocolStringList类型，其直接继承了java.util.List</li>
<li>枚举：转换为普通枚举类型，但是会多一个UNRECOGNIZE，表示未知参数</li>
<li>oneof：多选一的字段，每个字段都会生成一个<code>hasXXX()</code>方法，用以判断是否有值；也有提供<code>hasOneof()</code>，判断这几个字段是否有存在一个</li>
<li>map：转换为<code>java.util.Map</code>类型</li>
<li>Any：转换为<code>com.google.protobuf.Any</code>，它提供pack和unpack，用于将其它任意消息类型进行封装和解封</li>
</ul>
<h3 id="消息类型的构建"><a href="#消息类型的构建" class="headerlink" title="消息类型的构建"></a>消息类型的构建</h3><ul>
<li>消息是不可变的，一旦构建不可更改</li>
<li>消息构建采用建造器模式，典型地如<code>Resource.newBuilder().setType(Resource.Type.RECORD).build()</code></li>
<li>嵌套消息，其建造器也是嵌套的，嵌套在父建造器上：<code>Resource.newBuilder().recordBuilder.addImages(&quot;&quot;).build()</code></li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>尽管我们在proto文件中定义了Service，但是脱离具体的RPC实现（比如gRPC），这个Service就没有意义。且一般的RPC实现会作为插件的形式载入（所以你看很多gradle中配置grpc是以插件的形式声明在protobuf块中的），生成两个部分</p>
<ul>
<li>服务抽象类：定义服务端，用户通过它实现自己的服务端逻辑</li>
<li>客户端Stub：定义客户端，用户通过它连接远端服务</li>
</ul>
<p>proto文件中存在<code>option java_generic_services = true;</code>时，会生成一个通用的Service实现。有兴趣可以看一下。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>每个消息，还提供了Descriptor，用以描述其proto信息，类似反射，可以获取元信息，如果我们写自己的RPC插件，可以使用</li>
<li>每个消息，都提供<code>getDefaultInstance()</code>，返回一个空对象</li>
</ul>
<h3 id="来个例子（Java）"><a href="#来个例子（Java）" class="headerlink" title="来个例子（Java）"></a>来个例子（Java）</h3><p>这里仅展示将上面定义的Resource消息设置值，并将序列化结果以流的形式输出。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resourceBuilder = Resource.newBuilder()</span><br><span class="line">    <span class="keyword">val</span> record = resourceBuilder.recordBuilder</span><br><span class="line">        .addImages(<span class="string">&quot;https://hello.png&quot;</span>)</span><br><span class="line">        .addAllImages(listOf(<span class="string">&quot;https://key.png&quot;</span>, <span class="string">&quot;https://key2.png&quot;</span>))</span><br><span class="line">        .setContent(<span class="string">&quot;这是记录&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource1 = resourceBuilder</span><br><span class="line">        .setId(<span class="number">1</span>)</span><br><span class="line">        .setType(Resource.Type.RECORD)</span><br><span class="line">        .setRecord(record)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource2 = resourceBuilder</span><br><span class="line">        .setId(<span class="number">2</span>)</span><br><span class="line">        .setType(Resource.Type.RECORD)</span><br><span class="line">        .setOther(Any.pack(resource1))</span><br><span class="line">        .putOtherMap(<span class="string">&quot;key&quot;</span>, Any.pack(resource1))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream().run &#123;</span><br><span class="line">        resource2.writeTo(<span class="keyword">this</span>)</span><br><span class="line">        println(<span class="keyword">this</span>.toByteArray().toHexString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="来个例子（Kotlin）"><a href="#来个例子（Kotlin）" class="headerlink" title="来个例子（Kotlin）"></a>来个例子（Kotlin）</h3><p>Kotlin生成在Java之上，为我们提供了DSL，上面的代码，用DSL再写一遍，看起来明显好很多。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource1 = resource &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.type = Resource.Type.RECORD</span><br><span class="line">        <span class="keyword">this</span>.record = ResourceKt.recordData &#123;</span><br><span class="line">            <span class="keyword">this</span>.images.add(<span class="string">&quot;https://hello.png&quot;</span>)</span><br><span class="line">            <span class="keyword">this</span>.images.addAll(listOf(<span class="string">&quot;https://key.png&quot;</span>, <span class="string">&quot;https://key2.png&quot;</span>))</span><br><span class="line">            <span class="keyword">this</span>.content = <span class="string">&quot;这是记录&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource2 = resource &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">2</span></span><br><span class="line">        <span class="keyword">this</span>.type = Resource.Type.RECORD</span><br><span class="line">        <span class="keyword">this</span>.other = Any.pack(resource1)</span><br><span class="line">        <span class="keyword">this</span>.otherMap.put(<span class="string">&quot;key&quot;</span>, Any.pack(resource1))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream().run &#123;</span><br><span class="line">        resource2.writeTo(<span class="keyword">this</span>)</span><br><span class="line">        println(<span class="keyword">this</span>.toByteArray().toHexString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h2><p>API生成，可以有两种方式</p>
<ul>
<li>protoc命令行生成API，gradle只引入相关依赖。好处是简单；缺点是一次性，每次修改协议都要生成一次。</li>
<li>直接使用gradle插件，将protoc生成命令嵌入gradle生命周期。好处是一旦配置完成就一劳永逸；坏处是配置麻烦。</li>
</ul>
<p>protobuf简单是简单，但配置起来还是有几个问题的。问题主要在于kotlin代码的生成，gradle插件的配置</p>
<h3 id="关于protoc的安装"><a href="#关于protoc的安装" class="headerlink" title="关于protoc的安装"></a>关于protoc的安装</h3><p>需要在<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.18.1">项目发布</a>页下载压缩包进行安装，macos直接选择对应的编译好的二进制包，有先尝试过直接<code>brew install protobuf</code>，结果它不包含protoc-kotlin-gen插件。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211018112756901.png" alt="image-20211018112756901"></p>
<h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>协议相关包，在<a target="_blank" rel="noopener" href="https://search.maven.org/search?q=g:com.google.protobuf">这里</a>才是最完整的，无论java也好，kotlin也好。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211018112836558.png" alt="image-20211018112836558"></p>
<h3 id="Kotlin的生成"><a href="#Kotlin的生成" class="headerlink" title="Kotlin的生成"></a>Kotlin的生成</h3><p>kotlin API需要依赖java代码，因此要同时生成java</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --java_out=xxxxxx --kotlin_out=xxxxxx resource_service.proto</span><br></pre></td></tr></table></figure>

<p>生成的Java代码</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-18%20%E4%B8%8A%E5%8D%8811.40.08.png" alt="截屏2021-10-18 上午11.40.08"></p>
<p>生成的Kotlin代码</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-18%20%E4%B8%8A%E5%8D%8811.40.49.png" alt="截屏2021-10-18 上午11.40.49"></p>
<h3 id="Gradle插件"><a href="#Gradle插件" class="headerlink" title="Gradle插件"></a>Gradle插件</h3><p>插件的项目地址：<a target="_blank" rel="noopener" href="https://github.com/google/protobuf-gradle-plugin">我是插件的项目地址</a></p>
<p>配置要点</p>
<ul>
<li>添加protobuf插件的依赖</li>
<li>通过sourceSets指定proto文件位置</li>
<li>protobuf.generatedFilesBaseDir指定代码生成位置</li>
<li>protobuf.protoc指定protoc的版本</li>
<li>protobuf.generateProtoTasks定制</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.google.protobuf:protobuf-gradle-plugin:0.8.17&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;java&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.google.protobuf&quot;</span>) version <span class="string">&quot;0.8.17&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        proto &#123;</span><br><span class="line">            srcDir(<span class="string">&quot;src/main/resources/proto&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">    generatedFilesBaseDir = <span class="string">&quot;<span class="variable">$projectDir</span>/src/generated&quot;</span></span><br><span class="line"></span><br><span class="line">    protoc &#123;</span><br><span class="line">        artifact = <span class="string">&quot;com.google.protobuf:protoc:3.18.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateProtoTasks &#123;</span><br><span class="line">        all().forEach &#123; task -&gt;</span><br><span class="line">            task.builtins &#123;</span><br><span class="line">                java &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kotlin代码的插件配置方式，暂时还没找到</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Protobuf优点众多：语法简单；编码算法使得结果非常小巧；编码算法也不难理解；对主流语言提供了API生成支持。但代码生成这种方式增加了构建时间，实际体验并不是很好。</p>
<p>有关更多内容，请需要参考官方文档</p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3">语法说明</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/encoding">编码方式</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/java-generated">Java API生成说明</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/kotlin-generated#nested-types">Kotlin API生成说明</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/protobuf-gradle-plugin">gradle插件</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%BA%94%20-%20Gson-xu-lie-hua-tan-suo-zhi-wu--gson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%BA%94%20-%20Gson-xu-lie-hua-tan-suo-zhi-wu--gson/" class="post-title-link" itemprop="url">序列化探索之五 - Gson</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-16 12:42:57" itemprop="dateCreated datePublished" datetime="2021-10-16T12:42:57+08:00">2021-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Gson是一个相对简单的库，没有那么多功能，从设计上也并不想让别人去扩展它，它只想安安静静地做一个Json序列化库，简单而实用。</p>
<h2 id="简单说"><a href="#简单说" class="headerlink" title="简单说"></a>简单说</h2><p>Gson提供两种方式创建Gson实例</p>
<ul>
<li><code>new Gson()</code>：快速创建，默认配置，快速使用</li>
<li><code>new GsonBuilder().setxxxxx().create()</code>：完整方式创建，支持一些自定义化的配置</li>
</ul>
<p>Gson突出一个简单，API如此，功能更是如此，大致列一下其支持的功能</p>
<ul>
<li>基于field的序列化与反序列化：基本特性</li>
<li>支持自定义属性名：@SerializedName</li>
<li>支持反序列化时指定泛型信息：TypeToken</li>
<li>支持排除某个字段：transient关键字排除单个字段、按照可见性修饰符排除、@Expose主动选择</li>
<li>支持自定义序列化和反序列化逻辑：JsonSerializer、JsonDeserializer，或者它们的集合体：TypeAdapter</li>
</ul>
<h2 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h2><p>什么注释也不用加，啥也不用干，直接就能使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource1</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> type: ResourceType? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">var</span> secret: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName(<span class="meta-string">&quot;我是实际数据&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource1(id=<span class="variable">$id</span>, type=<span class="variable">$type</span>, secret=&#x27;<span class="variable">$secret</span>&#x27;, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> resource = Resource1&lt;JsonObject&gt;().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.type = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.secret = <span class="string">&quot;我是密码&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = JsonObject().apply &#123;</span><br><span class="line">            addProperty(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    println(gson.fromJson&lt;Resource1&lt;JsonObject&gt;&gt;(jsonString, <span class="keyword">object</span> : TypeToken&lt;Resource1&lt;JsonObject&gt;&gt;() &#123;&#125;.type))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>序列化用<code>gson.toJson(xxx)</code>，反序列化用<code>gson.fromJson(jsonString, 类型信息)</code></li>
<li>忽略字段可以用transient关键字</li>
<li>自定义字段名用@SerializedName注解，实际上这是Gson能够个性化配置的唯四之一</li>
<li>对于泛型擦除的情况，在反序列化时通过TypeToken指定：<code>object : TypeToken&lt;Resource1&lt;JsonObject&gt;&gt;() &#123;&#125;.type</code>。这一点和Jackson和Fastjson的TypeReference类似</li>
</ul>
<h2 id="排除字段"><a href="#排除字段" class="headerlink" title="排除字段"></a>排除字段</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Expose</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> type: ResourceType? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</span><br><span class="line">    println(gson.toJson(Resource4().apply &#123; id = <span class="number">10</span>; type = ResourceType.CHARACTER &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GsonBuilder().excludeFieldsWithoutExposeAnnotation()</code>设置只暴露@Expose的数据</li>
<li>@Expose标记字段</li>
</ul>
<h2 id="自定义实例创建器"><a href="#自定义实例创建器" class="headerlink" title="自定义实例创建器"></a>自定义实例创建器</h2><p>Gson反序列化时创建对象的逻辑</p>
<ul>
<li>首先寻找是否存在目标类的无参构造函数，有则用它创建实例</li>
<li>其次寻找是否存在用户自定义的实例创建器</li>
<li>然后如果目标类是原生类型，则直接查找对应类型的构造器并创建实例</li>
<li>都没有，则用sun.misc.Unsafe创建实例</li>
</ul>
<p>一般不推荐使用Unsafe创建实例，要么提供无参构造方法，要么提供实例创建器，这里有一个后者的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource3</span></span>(<span class="keyword">var</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> type: ResourceType?) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;有参构造函数被执行了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource3(id=<span class="variable">$id</span>, type=<span class="variable">$type</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource3Creator</span> : <span class="type">InstanceCreator</span>&lt;<span class="type">Resource3</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createInstance</span><span class="params">(type: <span class="type">Type</span>)</span></span>: Resource3 &#123;</span><br><span class="line">        <span class="keyword">return</span> Resource3(-<span class="number">1</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = GsonBuilder().registerTypeAdapter(Resource3::<span class="keyword">class</span>.java, Resource3Creator()).create()</span><br><span class="line">    <span class="keyword">val</span> resource = Resource3(<span class="number">1</span>, <span class="literal">null</span>)</span><br><span class="line">    println(<span class="string">&quot;序列化&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    println(<span class="string">&quot;反序列化&quot;</span>)</span><br><span class="line">    println(gson.fromJson(jsonString, Resource3::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被执行了</span><br><span class="line">序列化</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:1&#125;</span><br><span class="line">反序列化</span><br><span class="line">有参构造函数被执行了</span><br><span class="line">Resource3(id=1, <span class="built_in">type</span>=null)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：Gson默认忽略掉内部类，因为它没有无参构造函数</p>
</blockquote>
<h2 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h2><p>老规矩，自定义LocalDateTime的序列化和反序列化逻辑，为此Gson提供了三种类型可供定义，要么定义序列化器、要么反序列化器，要么同时有。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> type: ResourceType = ResourceType.CHARACTER</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAdapter(Resource5TypeAdapter::class)</span></span><br><span class="line">    <span class="keyword">var</span> updatedTime: LocalDateTime? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource5(id=<span class="variable">$id</span>, type=<span class="variable">$type</span>, updatedTime=<span class="variable">$updatedTime</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource5TypeAdapter</span> : <span class="type">TypeAdapter</span>&lt;<span class="type">LocalDateTime</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(<span class="keyword">out</span>: <span class="type">JsonWriter</span>, value: <span class="type">LocalDateTime</span>?)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;执行了写方法&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">out</span>.nullValue()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">out</span>.value(value.toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(`<span class="keyword">in</span>`: <span class="type">JsonReader</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        println(<span class="string">&quot;执行了读方法&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(`<span class="keyword">in</span>`.nextLong()), ZoneOffset.UTC)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = Resource5().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    println(gson.fromJson(jsonString, Resource5::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可通过@JsonAdapter局部指定</li>
<li>也可通过<code>GsonBuilder().registerTypeAdapter</code>全局注册</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>Gson原生不支持多态，但可通过一些其它方式实现，以下是官方推荐的方式（尽管很傻）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> list = listOf(</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        mapOf(</span><br><span class="line">            <span class="string">&quot;key&quot;</span> to <span class="string">&quot;value&quot;</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(list)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    gson.fromJson(jsonString, JsonArray::<span class="keyword">class</span>.java).mapIndexed &#123; index, jsonElement -&gt;</span><br><span class="line">        <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; gson.fromJson(jsonElement, <span class="built_in">Int</span>::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="number">1</span> -&gt; gson.fromJson(jsonElement, String::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="number">2</span> -&gt; gson.fromJson(jsonElement, <span class="keyword">object</span> : TypeToken&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;.type)</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.toList().also &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个集合中有多重类型，反序列化时，先得到JsonArray，再针对具体元素应用具体类型</li>
<li>这就不咋科学，还有一种方式是RuntimeTypeAdapterFactory，这非官方推荐的方式，所以要用多态还是别用Gson了</li>
</ul>
<h2 id="树模型"><a href="#树模型" class="headerlink" title="树模型"></a>树模型</h2><p>Gson的树模型还是简单的，只有JsonArray、JsonObject以及JsonElement三个类，但是API不大友好，限制的比较死</p>
<ul>
<li>添加一般属性就要调用addProperty方法，且只支持String、Boolean、Number、Character四种类型</li>
<li>添加对象或数组属性就得用add方法</li>
<li>不支持fluent API</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = JsonObject().apply &#123;</span><br><span class="line">        addProperty(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        addProperty(<span class="string">&quot;type&quot;</span>, ResourceType.CHARACTER.name)</span><br><span class="line">        addProperty(<span class="string">&quot;usn&quot;</span>, <span class="literal">null</span> <span class="keyword">as</span> String?)</span><br><span class="line">        add(<span class="string">&quot;data&quot;</span>, JsonArray().apply &#123;</span><br><span class="line">            add(<span class="literal">false</span>)</span><br><span class="line">            add(<span class="number">123</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(GsonBuilder().setPrettyPrinting().create().toJson(resource))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持设置啥能力"><a href="#支持设置啥能力" class="headerlink" title="支持设置啥能力"></a>支持设置啥能力</h2><p>穷举一下GsonBuilder，有啥能力，可以看到，其实没啥能力。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211016115638338.png" alt="image-20211016115638338"></p>
<ul>
<li>设置序列化和反序列化的排除策略</li>
<li>设置各种类型适配器，用于控制类型序列化和反序列化时的行为</li>
<li>关闭内部类的序列化</li>
<li>Html格式转义</li>
<li>序列化名称控制</li>
<li>输出格式化</li>
<li>版本控制（@Since和@Until注解可设置POJO的版本，有点类似@JsonView的功能，但感觉非常鸡肋）</li>
<li>设置日期格式</li>
<li>设置字段名命名策略</li>
</ul>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>加上Gson，前前后后看了五个序列化库，除了Java，原理结构上都大同小异，只是在序列化和反序列化的具体算法上有所差别，扣得比较细节，尤其是Fastjson用了很多奇技淫巧，硬是把速度提了上去。</p>
<ul>
<li>对于序列化，首先得到序列化器，再用序列化器将实际对象写入流</li>
<li>对反序列化，首先得到反序列化器，再得到目标类的实例，再用反序列化器从流中读取内容塞入目标实例</li>
</ul>
<p>至于Gson，它比较与众不同的点在于</p>
<ul>
<li>序列化时，直接使用了StringWriter做写操作，而不是自己维护输出流和缓冲区</li>
<li>Json格式的实际写入在com.google.gson.stream.JsonWriter，内部套StringWriter<ul>
<li>写入状态控制与Jackson采用树状结构不同，它采用了栈（一个一维数组，数组的大小即当前层次结构的深度，数组的值即当前所处结构的类型）的方式维护，参见com.google.gson.stream.JsonWriter#stack</li>
</ul>
</li>
<li>对未自定义序列化器的类型来说，使用com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter达成<ul>
<li>对于序列化，它直接使用了反射获取符合要求的字段，然后写入writer</li>
<li>对于反序列化，它使用前文”自定义实例创建器”所说的方式创建对象，然后通过反射写入目标对象</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通篇看起来，Gson定位清晰，目标明确，文档和代码规范，用起来也比较轻松。只是功能简单，原理也简单，直接使用StringWriter和反射，就是一个功能性的Json库，看不大出有什么性能优化，因此可以推测，Gson的性能不会太出色。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%9B%9B%20-%20Fastjson-xu-lie-hua-tan-suo-zhi-fastjson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%9B%9B%20-%20Fastjson-xu-lie-hua-tan-suo-zhi-fastjson/" class="post-title-link" itemprop="url">序列化探索之四 - Fastjson</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-15 17:11:21 / 修改时间：17:11:39" itemprop="dateCreated datePublished" datetime="2021-10-15T17:11:21+08:00">2021-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>开局一吐槽，Fastjson的文档，比Jackson还差。Jackson只是位置不明确，如果安下心来看看，还是能够理清楚的。而Fastjson是位置不明确，如果安下心来看看，还会发现，它的文档零零散散，中英文混杂，找不准主线在哪儿。我记得知乎上有个问题，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/44199956">fastjson这么快老外为啥还是热衷 jackson?</a>，就这文档，让老外用个啥。</p>
<p>不过看还是要看的，毕竟它是目前主流序列化框架之一。老样子，我们还是从基本使用方法和原理分析两部分着手。</p>
<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>Fastjson仅仅针对json，尚不支持其它任何格式，也没有看到谁为它进行格式扩展。因为这并不是它的目的，库如其名，它是为了更快地序列化Json而存在。因此，使用上来，会简单许多。具体分为几个部分</p>
<ul>
<li>常规使用</li>
<li>注解</li>
<li>自定义序列化器</li>
<li>自定义过滤器</li>
<li>树模型</li>
</ul>
<h3 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBase</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">var</span> id: String,</span><br><span class="line">        <span class="keyword">var</span> type: Type</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonString = JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD))</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="keyword">val</span> resource = JSON.parseObject(jsonString, Resource::<span class="keyword">class</span>.java)</span><br><span class="line">    println(resource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>序列化：<code>JSON.toJSONString(对象)</code></p>
</li>
<li><p>反序列化：<code>JSON.parseObject(jsonString, 对象class)</code></p>
</li>
<li><p>注意</p>
<ul>
<li><p>默认情况下，是根据getter和setter方法取得和设置字段的，如果没有，将得不到输出</p>
</li>
<li><p>也可以基于属性获取和设置字段，考虑下面的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBasedOnFields</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> id: String,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> type: Type</span><br><span class="line">    )</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 设置基于字段的序列化</span></span><br><span class="line">    <span class="keyword">val</span> serializeConfig = SerializeConfig(<span class="literal">true</span>)</span><br><span class="line">  	<span class="comment">// 设置基于字段反序列化</span></span><br><span class="line">    <span class="keyword">val</span> parserConfig = ParserConfig(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> jsonString = JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD), serializeConfig)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="keyword">val</span> resource = JSON.parseObject&lt;Resource&gt;(jsonString, Resource::<span class="keyword">class</span>.java, parserConfig)</span><br><span class="line">    println(resource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解方面它采取了另一种思路，它只有两个注解，但将功能放在注解的属性中</p>
<ul>
<li>@JSONType：放在类上的注解 ，可设置<ul>
<li>alphabetic：字段按照字母顺序排序</li>
<li>asm：反序列化时是否使用asm</li>
<li>orders：字段之间的顺序</li>
<li>includes：需要包含哪些字段</li>
<li>excludes：需要排除哪些字段</li>
<li>serializeFeatures：需要包含的序列化功能</li>
<li>parseFeatures：需要包含的反序列化功能</li>
<li>mappingTo：映射成某个类</li>
<li>builder：指定反序列化的构建器</li>
<li>serializer：指定序列化器</li>
<li>deserializer：指定反序列化器</li>
<li>naming：指定命名策略</li>
<li>serialzeFilters：指定过滤器</li>
</ul>
</li>
<li>@JSONField：放在属性上的注解 ，可设置<ul>
<li>ordinal：序列化后字段的位置</li>
<li>name：序列化后的名字</li>
<li>format：指定日期的格式</li>
<li>serialize：是否参与序列化</li>
<li>deserialize：是否参与反序列化</li>
<li>serializeFeatures：需要包含的序列化功能</li>
<li>parseFeatures：需要包含的反序列化功能</li>
<li>label：标签，这是内部功能，结合过滤器可实现类似分组的功能</li>
<li>serializeUsing：指定序列化器</li>
<li>deseializeUsing：指定反序列化器</li>
<li>alternateNames：指定别名，反序列化时可用</li>
<li>unwrapped：将带有结构的对象的属性提取到顶层</li>
<li>defaultValue：反序列化时的默认值</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的修改属性名字献给大家</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testAnnotations</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONType(alphabetic = false, ignores = [<span class="meta-string">&quot;id&quot;</span>])</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: String,</span><br><span class="line">        <span class="meta">@JSONField(name = <span class="meta-string">&quot;resourceType&quot;</span>)</span></span><br><span class="line">        <span class="keyword">val</span> type: Type,</span><br><span class="line">        <span class="keyword">val</span> updatedTime: Date</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD, Date()), SerializerFeature.PrettyFormat))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细想想，从注解能力上来说，还是有所差别的</p>
<ul>
<li>@JsonRawValue，将字段作为原生json看待</li>
<li>@JsonAutoDetect，自定义属性检测的可见性修饰符</li>
<li>@JsonView，同一个POJO的多种序列化结果，可通过label实现</li>
<li>@JsonAnyGetter、@JsonAnySetter，多余的字段塞到map，以及反过程</li>
<li>@JsonValue，将POJO的某个字段作为整个POJO的序列化结果</li>
<li>@JsonInclude，根据情况决定是否将字段加入序列化</li>
<li>@JsonEnumDefaultValue，给枚举设置默认值</li>
<li>@JsonInject，给某个字段强行注入</li>
<li>多态，不过可以通过其它方式变相达成：SerializeFeature.WriteClassName</li>
<li>@JsonManagedReference等循环引用的解决方式，Fastjson也有解决，不过它是采用$ref的方式，而非jackson的去除或使用某个字段替代。</li>
<li>@JsonRootName，将对象序列化到一个指定名称的属性下</li>
</ul>
<h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><p>不多解释，传统技能：为LocalDateTime自定义序列化器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCustomSerializer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: String,</span><br><span class="line">        <span class="keyword">val</span> type: Type,</span><br><span class="line">        <span class="keyword">val</span> updatedTime: LocalDateTime</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeSerializer</span> : <span class="type">ObjectSerializer &#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            serializer: <span class="type">JSONSerializer</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            `<span class="keyword">object</span>`: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            fieldName: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            fieldType: <span class="type">java</span>.<span class="type">lang</span>.<span class="type">reflect</span>.<span class="type">Type</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            features: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">out</span> = serializer.<span class="keyword">out</span></span><br><span class="line">            <span class="keyword">if</span> (`<span class="keyword">object</span>` == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">out</span>.writeNull()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">out</span>.writeLong((`<span class="keyword">object</span>` <span class="keyword">as</span> LocalDateTime).toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SerializeConfig.globalInstance.put(LocalDateTime::<span class="keyword">class</span>.java, LocalDateTimeSerializer())</span><br><span class="line">    println(JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD, LocalDateTime.now())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这序列化器注册的方式嘛，是不是不大友好呀。要么全局注册，要么序列化时传参进去，并不能持有多套配置JSON对象。</p>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>过滤器是Fastjson比较独有的概念，也比较好理解：在序列化的多个阶段提供给用户参与调整的机会。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211015152451901.png" alt="image-20211015152451901"></p>
<p>具体怎么用，只能靠猜，源码也没有注释，文档也不好找，需要的时候再去找吧。这里就展示怎么注册：把所有名称都设置为大写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCustomFilter</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: String,</span><br><span class="line">        <span class="keyword">val</span> type: Type,</span><br><span class="line">        <span class="keyword">val</span> updatedTime: LocalDateTime</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IdFilter</span> : <span class="type">NameFilter &#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(`<span class="keyword">object</span>`: <span class="type">Any</span>?, name: <span class="type">String</span>, value: <span class="type">Any</span>)</span></span>: String? &#123;</span><br><span class="line">            <span class="keyword">return</span> name.uppercase(Locale.getDefault())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SerializeConfig.globalInstance.addFilter(Resource::<span class="keyword">class</span>.java, IdFilter())</span><br><span class="line">    println(JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD, LocalDateTime.now())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树模型的使用"><a href="#树模型的使用" class="headerlink" title="树模型的使用"></a>树模型的使用</h3><p>没错，它也有树模型，只是功能没那么强大而已，它也只有两个对象</p>
<ul>
<li>JSONObject：可直接理解为Map，事实上它也是继承了Map</li>
<li>JSONArray：理解为List</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testTreeModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = JSONObject()</span><br><span class="line">        .fluentPut(<span class="string">&quot;ID&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        .fluentPut(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, JSONArray()</span><br><span class="line">                .fluentAdd(</span><br><span class="line">                    JSONObject()</span><br><span class="line">                        .fluentPut(<span class="string">&quot;images&quot;</span>, <span class="string">&quot;[]&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        )</span><br><span class="line">    println(JSON.toJSONString(resource, SerializerFeature.PrettyFormat, SerializerFeature.SortField))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下，这里可以看到一个问题：Fastjson默认序列化后所有的字段都是排序的，这就很不好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;data&quot;</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;images&quot;</span>:<span class="string">&quot;[]&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="string">&quot;ID&quot;</span>:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>其它功能，主要就是在Feature中指定的内容了，基本都是置顶序列化和反序列化时遵循的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化相关的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerFeature</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 字段名用引号引起来</span></span><br><span class="line">    QuoteFieldNames,</span><br><span class="line">    <span class="comment">// 使用单引号</span></span><br><span class="line">    UseSingleQuotes,</span><br><span class="line">    WriteMapNullValue,</span><br><span class="line">    <span class="comment">// 枚举调用toString()输出</span></span><br><span class="line">    WriteEnumUsingToString,</span><br><span class="line">    <span class="comment">// 枚举调用name()输出</span></span><br><span class="line">    WriteEnumUsingName,</span><br><span class="line">    <span class="comment">// 日期使用ISO8601格式</span></span><br><span class="line">    UseISO8601DateFormat,</span><br><span class="line">    <span class="comment">// 列表的null输出为[]</span></span><br><span class="line">    WriteNullListAsEmpty,</span><br><span class="line">    <span class="comment">// 字符串的null输出为空串</span></span><br><span class="line">    WriteNullStringAsEmpty,</span><br><span class="line">    <span class="comment">// 数字的null输出为0</span></span><br><span class="line">    WriteNullNumberAsZero,</span><br><span class="line">    <span class="comment">// 布尔的null输出为false</span></span><br><span class="line">    WriteNullBooleanAsFalse,</span><br><span class="line">    <span class="comment">// 忽略被transient标记的字段</span></span><br><span class="line">    SkipTransientField,</span><br><span class="line">    <span class="comment">// 为字段排序</span></span><br><span class="line">    SortField,</span><br><span class="line">    <span class="comment">// 格式化输出</span></span><br><span class="line">    PrettyFormat,</span><br><span class="line">    <span class="comment">// 输出结果添加类名，可用来实现多态</span></span><br><span class="line">    WriteClassName,</span><br><span class="line">		<span class="comment">// 关闭循环引用检测</span></span><br><span class="line">    DisableCircularReferenceDetect,</span><br><span class="line">		<span class="comment">// 将斜线当做特殊符号</span></span><br><span class="line">    WriteSlashAsSpecial,</span><br><span class="line">		<span class="comment">// 浏览器兼容</span></span><br><span class="line">    BrowserCompatible,</span><br><span class="line">		<span class="comment">// Date使用日期格式输出</span></span><br><span class="line">    WriteDateUseDateFormat,</span><br><span class="line">		<span class="comment">// 不写根类的名字</span></span><br><span class="line">    NotWriteRootClassName,</span><br><span class="line">    <span class="comment">// 将java bean的字段以数组的形式输出，而不是对象</span></span><br><span class="line">    BeanToArray,</span><br><span class="line">		<span class="comment">// 将非字符串的key当做字符串输出</span></span><br><span class="line">    WriteNonStringKeyAsString,</span><br><span class="line">    <span class="comment">// 不为没有值的属性写默认值</span></span><br><span class="line">    NotWriteDefaultValue,</span><br><span class="line">    <span class="comment">// 浏览器安全</span></span><br><span class="line">    BrowserSecure,</span><br><span class="line">    <span class="comment">// 忽略没有幕后字段的getter</span></span><br><span class="line">    IgnoreNonFieldGetter,</span><br><span class="line">    <span class="comment">// 将非字符串的值当做字符串输出</span></span><br><span class="line">    WriteNonStringValueAsString,</span><br><span class="line">    <span class="comment">// getter报错时忽略</span></span><br><span class="line">    IgnoreErrorGetter,</span><br><span class="line">		<span class="comment">// 将bigdecimal当做字符串输出</span></span><br><span class="line">    WriteBigDecimalAsPlain,</span><br><span class="line">		<span class="comment">// map输出时也要将字段排序</span></span><br><span class="line">    MapSortField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化相关的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Feature</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取完后自动关闭读取源</span></span><br><span class="line">    AutoCloseSource,</span><br><span class="line">    <span class="comment">// 允许注释出现</span></span><br><span class="line">    AllowComment,</span><br><span class="line">    <span class="comment">// 允许未被引号包含的字段名</span></span><br><span class="line">    AllowUnQuotedFieldNames,</span><br><span class="line">   	<span class="comment">// 允许单引号</span></span><br><span class="line">    AllowSingleQuotes,</span><br><span class="line">    <span class="comment">// 字段名intern化，主要用于节省空间</span></span><br><span class="line">    InternFieldNames,</span><br><span class="line">    <span class="comment">// 允许ISO8601格式的日期格式</span></span><br><span class="line">    AllowISO8601DateFormat,</span><br><span class="line">		<span class="comment">// 允许任意数量的逗号间隔</span></span><br><span class="line">    AllowArbitraryCommas,</span><br><span class="line">		<span class="comment">// 数字使用BigDecinal接收</span></span><br><span class="line">    UseBigDecimal,</span><br><span class="line">    <span class="comment">// 字段不匹配时忽略，不报错</span></span><br><span class="line">    IgnoreNotMatch,</span><br><span class="line">		<span class="comment">// 启用有序字段的匹配算法，会更快</span></span><br><span class="line">    SortFeidFastMatch,</span><br><span class="line">    <span class="comment">// 不启用ASM</span></span><br><span class="line">    DisableASM,</span><br><span class="line">    <span class="comment">// 关闭循环引用的检测</span></span><br><span class="line">    DisableCircularReferenceDetect,</span><br><span class="line">    <span class="comment">// 字符串类型的字段初始化为空串</span></span><br><span class="line">    InitStringFieldAsEmpty,</span><br><span class="line">    <span class="comment">// 支持将数组转换为bean</span></span><br><span class="line">    SupportArrayToBean,</span><br><span class="line">    <span class="comment">// 字段排序</span></span><br><span class="line">    OrderedField,</span><br><span class="line">    <span class="comment">// 关闭特殊字符检测</span></span><br><span class="line">    DisableSpecialKeyDetect,</span><br><span class="line">    <span class="comment">// 使用对象数组</span></span><br><span class="line">    UseObjectArray,</span><br><span class="line">		<span class="comment">// 支持非public的字段写入</span></span><br><span class="line">    SupportNonPublicField,</span><br><span class="line">		<span class="comment">// 忽略autotype，即多态的功能</span></span><br><span class="line">    IgnoreAutoType,</span><br><span class="line">		<span class="comment">// disable field smart match, improve performance in some scenarios.</span></span><br><span class="line">    DisableFieldSmartMatch,</span><br><span class="line">		<span class="comment">// 开启自动类型转换</span></span><br><span class="line">    SupportAutoType,</span><br><span class="line">		<span class="comment">// 非字符串的key转化为string</span></span><br><span class="line">    NonStringKeyAsString,</span><br><span class="line">		<span class="comment">// 使用自定义的Map的反序列化器</span></span><br><span class="line">    CustomMapDeserializer,</span><br><span class="line">		<span class="comment">// 枚举不匹配时报错</span></span><br><span class="line">    ErrorOnEnumNotMatch,</span><br><span class="line">		<span class="comment">// 安全模式</span></span><br><span class="line">    SafeMode,</span><br><span class="line">		<span class="comment">// 字符串字段去除两头空字符</span></span><br><span class="line">    TrimStringFieldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>看了kotlinx.serialization、Jackson，再看Fastjson，发现它们的组成基本一致，无非三个部分，可能根据情况其命名和具体实现方式会有所不同。这部分没啥新意，自己追一下方法就OK了。</p>
<ul>
<li>门面：JSON</li>
<li>将原始对象写入流：SerializeWriter、JSONReaderScanner</li>
<li>将自定义对象转换为原始对象：ObjectSerializer、ObjectDeserializer</li>
</ul>
<p>Fastjson的特点在于快，为什么这么快呢？据说是算法，<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/wenshao-1142031">作者自己的博客——Fastjson技术内幕</a>有所描述，归结起来大概就是</p>
<ul>
<li>自定义SerializeWriter，提供两部并做一步走之类的方法writeIntAndChar，减少越界检查</li>
<li>使用ASM避免反射</li>
<li>自定义IdentityHashMap，避免equals操作</li>
<li>默认字段有序，以便为反序列化性能提升做准备</li>
<li>balabalabalabalabala</li>
</ul>
<p>所以Fastjson的原理，重点是算法，而不在结构上。而这些算法，是不是有点奇技淫巧了🤔。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了官方手册、网上相关文章，翻阅了源码，试用了基本功能，Fastjson给人最大的感觉——偏科生。</p>
<p>偏在哪里？速度，大家都在强调快快快，一切以快为目标。作者告诉我们Fastjson是目前已知的最快的Json序列化库，给出benchmark，晒出获奖记录，好像要脚踩Jackson，拳打Gson，唯我独尊，甚至和Protobuf进行了对比（这个对比我觉得就很扯）；网文介绍Fastjson的功能时，快是一定要强调的。大家好像陷入一种狂热状态，好像Json序列化最主要的功能就是为了快，这明显是不正常的。</p>
<p>典型的Web场景，数据库读取几十ms，序列化几ms，如果序列化不是以指数形式加速，快个小几倍个人认为意义不大，可能对于京东淘宝这种超大吞吐量有意义，对一般的网站，Jackson已经足够快速。</p>
<p>作为一个序列化库，更重要的是稳定性、安全性、可用性。这几方面FastJson做的貌似都不大好，文档混乱、代码没有注释、类命名还是有奇怪的地方，当然作为一个人撸出来的代码，也不能苛求太多。</p>
<p>对此，我个人的观点是，Fastjson只适合少数特定场景下的使用，并不能作为一个通用的Json序列化框架。目前看起来，我用Jackson。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%B8%89%20-%20Jackson-xu-lie-hua-tan-suo-zhi-san--jackson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%B8%89%20-%20Jackson-xu-lie-hua-tan-suo-zhi-san--jackson/" class="post-title-link" itemprop="url">序列化探索之三 - Jackson</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-14 12:38:21" itemprop="dateCreated datePublished" datetime="2021-10-14T12:38:21+08:00">2021-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>写这篇文章时，我一度陷入了纠结与不安，再次体会到了聚焦的重要性。Jackson看似简单，实则功能强大，这两天有些迷失，不知道要看些什么，要写些什么。但路得一步一步走，饭得一口一口吃，纵使它可供探索的点繁如星辰，我也得将焦点拉回，否则就叫失控。至于其它的点，以后再说。因此，本文将聚焦如下几点</p>
<ul>
<li>Jackson的能力</li>
<li>基本原理</li>
<li>module工作原理</li>
</ul>
<h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p>Jackson文档怎么看，是一个问题。如果初次接触Jackson，看<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">主项目的介绍</a>半个小时，多半还是云里雾里，我认为这是Jackson文档做的很不好的一点，并没有一个Guide，而是需要自己一个一个项目看，而如果你恰巧点到了第三方module，就更不知道它在说什么了。</p>
<p>总的说来，Jackson由三部分组成</p>
<ul>
<li>Jackson-core：提供低层级的流式API，灵活程度高，效率高，但易用性差</li>
<li>Jackson-annotations：提供注解定义，这些注解是与我么打交道最多的</li>
<li>Jackson-databind：在前两个部分的基础上封装了一层，提供序列化和反序列化功能，我们直接使用的API，基本都来自于此。</li>
</ul>
<p>在jackson-databind中，提供了可插入的module机制，允许第三方定义自己的类型转换库，通过ObjectMapper().registerModule的方式注册，常见的有</p>
<ul>
<li>针对java.time包下的时间的类型库</li>
<li>针对kotlin的类型库</li>
<li>好多其它的</li>
</ul>
<p>又，Jackson并非仅仅针对Json，还支持Protobuf、TOML、Yaml等诸多格式，他们是通过自定义jackson-core提供的流式API和Codec实现的。</p>
<p>还有，Jackson中的很多概念都和kotlinx.serialization类似，学习过程中可做类比，加深印象。</p>
<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>Jackson提供三种方式进行序列化和反序列化</p>
<ul>
<li>低层级的流式API，直接控制基础token的写入（要理解Jackson所谓的token，一个字符、一个起始符，都是token）</li>
<li>ObjectMapper，直接进行POJO和json之间的转换，也可以进行POJO和POJO之间的转换，但原理是一样的。</li>
<li>基于TreeModel，脱离POJO直接构建json结构</li>
</ul>
<h3 id="流式API"><a href="#流式API" class="headerlink" title="流式API"></a>流式API</h3><p>要想快，就用流式API，只需引入jackson-core，这里简单展示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceWithStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceWithStream(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, usn=<span class="variable">$usn</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> JsonGenerator.<span class="title">encoding</span><span class="params">(resource: <span class="type">ResourceWithStream</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.writeStartObject()</span><br><span class="line">    <span class="keyword">this</span>.writeStringField(<span class="string">&quot;resourceId&quot;</span>, resource.resourceId)</span><br><span class="line">    <span class="keyword">this</span>.writeStringField(<span class="string">&quot;resourceType&quot;</span>, resource.resourceType)</span><br><span class="line">    resource.usn.let &#123; usn -&gt;</span><br><span class="line">        <span class="keyword">this</span>.writeFieldName(<span class="string">&quot;usn&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (usn == <span class="literal">null</span>) <span class="keyword">this</span>.writeNull()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.writeNumber(usn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.writeEndObject()</span><br><span class="line">    <span class="keyword">this</span>.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> JsonParser.<span class="title">decoding</span><span class="params">()</span></span>: ResourceWithStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextToken() != JsonToken.START_OBJECT) <span class="keyword">throw</span> Exception(<span class="string">&quot;没有以对象起头&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ResourceWithStream().also &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">this</span>.currentName) &#123;</span><br><span class="line">                <span class="string">&quot;resourceId&quot;</span> -&gt; it.resourceId = <span class="keyword">this</span>.valueAsString</span><br><span class="line">                <span class="string">&quot;resourceType&quot;</span> -&gt; it.resourceType = <span class="keyword">this</span>.valueAsString</span><br><span class="line">                <span class="string">&quot;usn&quot;</span> -&gt; it.usn = <span class="keyword">this</span>.valueAsLong</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = ResourceWithStream().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="number">123456</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> bos = ByteArrayOutputStream()</span><br><span class="line">    <span class="keyword">val</span> jsonFactory = JsonFactoryBuilder().build()</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonGenerator = jsonFactory.createGenerator(bos)</span><br><span class="line">    jsonGenerator.encoding(resource)</span><br><span class="line">    println(bos.toString())</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonParser = jsonFactory.createParser(bos.toByteArray())</span><br><span class="line">    println(jsonParser.decoding())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;resourceId&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;resourceType&quot;</span>:<span class="string">&quot;record&quot;</span>,<span class="string">&quot;usn&quot;</span>:123456&#125;</span><br><span class="line">ResourceWithStream(resourceId=1, resourceType=record, usn=123456)</span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Jackson的注解可就多了去了，一个简单而骚气的展示：序列化时将Map类型的数据提取到顶层，反序列化时再将这些数据塞回去。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: MutableMap&lt;String, Any&gt;? = mutableMapOf()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnySetter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>?.put(key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnyGetter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getOther</span><span class="params">()</span></span>: MutableMap&lt;String, Any&gt;? = <span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource2(resourceId=<span class="variable">$resourceId</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = Resource2().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = <span class="string">&quot;资源ID&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = mutableMapOf(</span><br><span class="line">            <span class="string">&quot;key&quot;</span> to <span class="string">&quot;value&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key2&quot;</span> to <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key3&quot;</span> to <span class="string">&quot;value3&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">    <span class="keyword">val</span> jsonString = objectMapper</span><br><span class="line">        .writerWithDefaultPrettyPrinter()</span><br><span class="line">        .writeValueAsString(resource)</span><br><span class="line">        .also &#123; println(it) &#125;</span><br><span class="line">    objectMapper.readValue(jsonString, Resource2::<span class="keyword">class</span>.java)</span><br><span class="line">        .also &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到注解多又常用，这里有不能每一个都展示，我们穷举场景</p>
<ul>
<li><p>如果需要自定义POJO某个属性的和序列化结果的对应关系，使用**@JsonProperty、@JsonSetter、@JsonGetter**</p>
</li>
<li><p>如果需要指定序列化后字段之间的顺序，使用**@JsonPropertyOrder**</p>
</li>
<li><p>如果POJO的某个字段需要直接当做json格式输出，使用@Js<strong>onRawValue</strong></p>
</li>
<li><p>如果需要忽略某些字段，使用**@JsonIgnore、@JsonIgnoreProperties、@JsonIgnoreType**</p>
</li>
<li><p>如果需要修改Jackson针对属性、POJO创建器等的检测逻辑，使用**@JsonAutoDetect**配置</p>
<p>典型地就是设置field、getter、setter、creator方法的可见性，指定哪种可见性能够被检测到</p>
</li>
<li><p>如果需要根据属性的值的情况决定是否序列化，可以使用**@JsonInclude**，它甚至可以指定当属性为某个特定的值时才序列化</p>
</li>
<li><p>如果某个类需要将某个属性当做该类型最终序列化结果的值，使用**@JsonValue**，一般用于枚举</p>
</li>
<li><p>如果需要配置jata.util中的日期相关序列化和反序列化转换逻辑，使用**@JsonFormat**</p>
</li>
<li><p>如果同一个POJO，在不同的情况下需要有不同的序列化结果，使用**@JsonView**</p>
</li>
<li><p>如果POJO中存在自定义类型，要想将该类型字段在序列化时提取到顶层，使用**@JsonUnwrapped**</p>
</li>
<li><p>如果POJO中存在map，想要把map的值提到顶层，使用**@JsonAnyGetter**</p>
<p>反之，如果json拥有多个属性，POJO中仅有少量字段，为了将多余的字段直接放在map中，使用**@JsonAnySetter**</p>
</li>
<li><p>如果想要自定义反序列化时调用的POJO构建器，使用**@JsonCreator**</p>
</li>
<li><p>针对枚举类型，如果想要在反序列化时匹配不到的情况下设置一个默认值，使用**@JsonEnumDefaultValue**</p>
</li>
<li><p>如果在反序列化时需要强制干预一个字段的值，可以使用**@JacksonInject**，但要结合ObjectMapper..setInjectableValues使用</p>
</li>
<li><p>如果要使用多态，需要使用**@JsonSubTypes、@JsonTypeId、@JsonTypeInfo、@JsonTypeName**</p>
</li>
<li><p>如果你的POJO之间有相互引用，导致序列化时出现递归，你需要使用**@JsonManagedReference、@JsonBackReference或@JsonIdentityInfo**解递归</p>
</li>
<li><p>如果希望某个POJO序列化后放在一个字段下，使用**@JsonRootName**</p>
</li>
</ul>
<p>他们的使用，可以参考这篇文章，还挺全的：<a target="_blank" rel="noopener" href="https://www.baeldung.com/jackson-annotations">就是我</a></p>
<h3 id="TreeModel"><a href="#TreeModel" class="headerlink" title="TreeModel"></a>TreeModel</h3><p>树形结构，是Jackson提供的又一强大功能，它允许我们直接构建Json，类似Kotlin的JsonElement，但是更强大。给一个简单的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 两种创建node的方式都一样</span></span><br><span class="line"><span class="comment">//    val node = JsonNodeFactory.instance.objectNode()</span></span><br><span class="line">    <span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">    <span class="keyword">val</span> node = objectMapper.createObjectNode()</span><br><span class="line">    node.put(<span class="string">&quot;resourceId&quot;</span>, <span class="string">&quot;这是ID&quot;</span>)</span><br><span class="line">        .put(<span class="string">&quot;resourceType&quot;</span>, <span class="string">&quot;这是Type&quot;</span>)</span><br><span class="line">        .put(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, objectMapper.createObjectNode().apply &#123;</span><br><span class="line">                put(</span><br><span class="line">                    <span class="string">&quot;images&quot;</span>, objectMapper.createArrayNode().apply &#123;</span><br><span class="line">                        add(<span class="string">&quot;这是第一个链接&quot;</span>)</span><br><span class="line">                        add(<span class="string">&quot;这是第二个链接&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    println(node.toPrettyString())</span><br><span class="line">    println(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(node))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;resourceId&quot;</span> : <span class="string">&quot;这是ID&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resourceType&quot;</span> : <span class="string">&quot;这是Type&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;images&quot;</span> : [ <span class="string">&quot;这是第一个链接&quot;</span>, <span class="string">&quot;这是第二个链接&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;resourceId&quot;</span> : <span class="string">&quot;这是ID&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resourceType&quot;</span> : <span class="string">&quot;这是Type&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;images&quot;</span> : [ <span class="string">&quot;这是第一个链接&quot;</span>, <span class="string">&quot;这是第二个链接&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>在MapperFeature、SerializationFeature、DeserializationFeature中，定义了很多开关，可根据需要打开或关闭。具体看三个文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-databind/wiki/Mapper-Features">针对整个ObjectMapper的配置</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-databind/wiki/Serialization-features">针对序列化的配置</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-databind/wiki/Deserialization-Features">针对反序列化的配置</a></li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="流式API-1"><a href="#流式API-1" class="headerlink" title="流式API"></a>流式API</h3><p> 流式API也支持很多功能，翻开JsonGenerator源码，将近三千行的文件长度有点吓人，但总的来说，它大概也只有功能配置和各种写方法。这其中，我们目前只关心之前用到的内容：</p>
<ul>
<li>一个基本的写方法的实现，即writeXXX</li>
<li>序列化过程中的状态维护，即JsonWriteContext</li>
<li>ObjectMapper的基础，即ObjectCodec</li>
</ul>
<p><strong>最底层的原理</strong></p>
<p>一般来说，通过<code>JsonFactoryBuilder().build().createGenerator(xxx)</code>创建出来的是<code>UTC8JsonGenerator</code>实例，我们来看两个方法的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写对象开头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeStartObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  _verifyValueWrite(<span class="string">&quot;start an object&quot;</span>);</span><br><span class="line">  _writeContext = _writeContext.createChildObjectContext();</span><br><span class="line">  <span class="keyword">if</span> (_outputTail &gt;= _outputEnd) &#123;</span><br><span class="line">    _flushBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  _outputBuffer[_outputTail++] = BYTE_LCURLY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写一个普通字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String text)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._verifyValueWrite(<span class="string">&quot;write a string&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._writeNull();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> len = text.length();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="keyword">this</span>._outputMaxContiguous) &#123;</span><br><span class="line">      <span class="keyword">this</span>._writeStringSegments(text, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._outputTail + len &gt;= <span class="keyword">this</span>._outputEnd) &#123;</span><br><span class="line">        <span class="keyword">this</span>._flushBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>._outputBuffer[<span class="keyword">this</span>._outputTail++] = <span class="keyword">this</span>._quoteChar;</span><br><span class="line">      <span class="keyword">this</span>._writeStringSegment((String)text, <span class="number">0</span>, len);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._outputTail &gt;= <span class="keyword">this</span>._outputEnd) &#123;</span><br><span class="line">        <span class="keyword">this</span>._flushBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>._outputBuffer[<span class="keyword">this</span>._outputTail++] = <span class="keyword">this</span>._quoteChar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// flush</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="keyword">this</span>._outputTail;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._outputTail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>._outputStream.write(<span class="keyword">this</span>._outputBuffer, <span class="number">0</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证写入是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_verifyValueWrite</span><span class="params">(String typeMsg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status = <span class="keyword">this</span>._writeContext.writeValue();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._cfgPrettyPrinter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._verifyPrettyValueWrite(typeMsg, status);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">switch</span>(status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        b = <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        b = <span class="number">58</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._rootValueSeparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">byte</span>[] raw = <span class="keyword">this</span>._rootValueSeparator.asUnquotedUTF8();</span><br><span class="line">          <span class="keyword">if</span> (raw.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._writeBytes(raw);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">this</span>._reportCantWriteValueExpectName(typeMsg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._outputTail &gt;= <span class="keyword">this</span>._outputEnd) &#123;</span><br><span class="line">      <span class="keyword">this</span>._flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._outputBuffer[<span class="keyword">this</span>._outputTail++] = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们忽略_cfgPrettyPrinter这个东西，它不是关键。有要点</p>
<ul>
<li>流式API的输出原理：维护一个输出流，维护一个缓存字节数组。每次写入，只是写入缓存数组中，只有主动调用flush()或缓存长度超过设定值(_outputEnd)时，才会将数据批量写入输入流，这样可以提升效率</li>
<li>每次写入前，都会调用_verifyValueWrite对当前的状态进行验证，它验证的内容其实是即将写入的内容是否符合Json格式，这是通过JsonStreamContext实现的（对写，对应JsonWriteContext），它维护了序列化过程中，当前的写入状态。比如，刚刚写入了一个key，现在必须写入一个value，否则就会报错。</li>
<li>在写对象的起始符时，也创建了jsonContext的子context，可见，Context是有层次结构的，其结构和Json的层次结构保持一致。</li>
</ul>
<p>看看JsonContext的层次结构，我们大概能猜出其工作原理</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013173735959.png" alt="image-20211013173735959"></p>
<ul>
<li><p>三个type（TYPE_ROOT等），是Context的类型，对应了根、数组、对象三种</p>
</li>
<li><p>几个status（STATUS_OK_AS_IS等），是Context检查后返回给调用者的结果，其中</p>
<ul>
<li>STATUS_OK_AS_IS：表明格式检查正确</li>
<li>STATUS_OK_AFTER_COMMA：表明格式检查正确，且当前位置后面应该添加逗号</li>
<li>STATUS_OK_AFTER_COLON：表明格式正确，且当前位置后面应该添加冒号</li>
<li>STATUS_OK_AFTER_SPACE：表明格式正确，且当前位置后面应该添加空白符</li>
<li>STATUS_EXPECT_VALUE：表明格式错误，预期是一个值</li>
<li>STATUS_EXPECT_NAME：表明格式错误，预期是一个字段名</li>
</ul>
<p>对它们的处理方式，在上面展示的方式_verifyValueWrite中也能看到。</p>
</li>
<li><p>其余属性，是为了维持当前状态用，根据状态判定当前调用是否合法，我们忽略”重复属性检查”，主要有两个方法，逻辑见注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写字段名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeFieldName</span><span class="params">(String name)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">  <span class="comment">// 当前类型是对象或已经写过了字段名，肯定就错了嘛</span></span><br><span class="line">  <span class="keyword">if</span> ((_type != TYPE_OBJECT) || _gotName) &#123;</span><br><span class="line">    <span class="keyword">return</span> STATUS_EXPECT_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  _gotName = <span class="keyword">true</span>;</span><br><span class="line">  _currentName = name;</span><br><span class="line">  <span class="keyword">if</span> (_dups != <span class="keyword">null</span>) &#123; _checkDup(_dups, name); &#125;</span><br><span class="line">  <span class="comment">// 如果这是第一个键值对，则啥都不管，否则，需要在这个键前面加逗号</span></span><br><span class="line">  <span class="keyword">return</span> (_index &lt; <span class="number">0</span>) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_type == TYPE_OBJECT) &#123;</span><br><span class="line">    <span class="comment">// 如果还没有设置键，应该先设置键</span></span><br><span class="line">    <span class="keyword">if</span> (!_gotName) &#123;</span><br><span class="line">      <span class="keyword">return</span> STATUS_EXPECT_NAME;</span><br><span class="line">    &#125;</span><br><span class="line">    _gotName = <span class="keyword">false</span>;</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="comment">// 在值前面加冒号</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_OK_AFTER_COLON;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_type == TYPE_ARRAY) &#123;</span><br><span class="line">    <span class="keyword">int</span> ix = _index;</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="comment">// 如果是数组，如果数组里还一个值都没有，啥也不做，否则，应该在这个之前面加逗号</span></span><br><span class="line">    <span class="keyword">return</span> (ix &lt; <span class="number">0</span>) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++_index;</span><br><span class="line">  <span class="comment">// 否则就是根对象咯，如果根对象里还没有元素，就啥也不错，否则应该在前面加空格</span></span><br><span class="line">  <span class="keyword">return</span> (_index == <span class="number">0</span>) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>编解码器</strong></p>
<p>如果了解Kotlin的序列化设计策略，就很好理解编解码器了，可以将它类比SerialFormat——为了将流式API的复杂逻辑封装起来，提供一个简单易用的API，我们看它的接口定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCodec</span> <span class="keyword">extends</span> <span class="title">TreeCodec</span> <span class="keyword">implements</span> <span class="title">Versioned</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ObjectCodec</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Version <span class="title">version</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser p, Class&lt;T&gt; valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser p, TypeReference&lt;T&gt; valueTypeRef)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser p, ResolvedType valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">readValues</span><span class="params">(JsonParser p, Class&lt;T&gt; valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">readValues</span><span class="params">(JsonParser p, TypeReference&lt;T&gt; valueTypeRef)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">readValues</span><span class="params">(JsonParser p, ResolvedType valueType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(JsonGenerator gen, Object value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends TreeNode&gt; <span class="function">T <span class="title">readTree</span><span class="params">(JsonParser p)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeTree</span><span class="params">(JsonGenerator gen, TreeNode tree)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TreeNode <span class="title">createObjectNode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TreeNode <span class="title">createArrayNode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JsonParser <span class="title">treeAsTokens</span><span class="params">(TreeNode n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">treeToValue</span><span class="params">(TreeNode n, Class&lt;T&gt; valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonFactory <span class="title">getJsonFactory</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getFactory(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonFactory <span class="title">getFactory</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getJsonFactory(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它提供的方法非常有限，大致分为两类</p>
<ul>
<li>针对一般类型及其集合类型的读、写方法，接收JsonParser/JsonGenerator、类型参数</li>
<li>针对树模型的读写方法</li>
</ul>
<h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><p>ObjectMapper是data-bind最主要的类，而他，直接继承ObjectCodec，也就是说，可以直接使用ObjectCodec中定义的那些方法。但会发现，最常用的却不是它们，类似SerialFormat，尽管ObjectCodec已经为我们提供了一些方法，但它们只是将流式API的端点和类型联系了起来，还是不够易用，因此data-bind定义了更多易用的方法，将JsonGenerator之类的创建封装在类内部，于是我们就有了writeValueAsString()这样的方法可以直接使用。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013193907907.png" alt="image-20211013193907907"></p>
<p>来看写方法，其实所有的写方法内部实现都是一样的，writeValueAsString也只是在其内部用一个流缓存序列化输出，再转换为字符串。它们的重点，在于com.fasterxml.jackson.databind.ObjectMapper#_writeValueAndClose</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有写方法都会调用的内部方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_writeValueAndClose</span><span class="params">(JsonGenerator g, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  SerializationConfig cfg = getSerializationConfig();</span><br><span class="line">  <span class="keyword">if</span> (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) &amp;&amp; (value <span class="keyword">instanceof</span> Closeable)) &#123;</span><br><span class="line">    _writeCloseable(g, value, cfg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 重点在serializeValue</span></span><br><span class="line">    _serializerProvider(cfg).serializeValue(g, value);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ClassUtil.closeOnFailAndThrowAsIOE(g, e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  g.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializeValue</span><span class="params">(JsonGenerator gen, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  _generator = gen;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _serializeNull(gen);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; cls = value.getClass();</span><br><span class="line">  <span class="comment">// 这是重点</span></span><br><span class="line">  <span class="keyword">final</span> JsonSerializer&lt;Object&gt; ser = findTypedValueSerializer(cls, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">  PropertyName rootName = _config.getFullRootName();</span><br><span class="line">  <span class="keyword">if</span> (rootName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) &#123;</span><br><span class="line">      _serialize(gen, value, ser, _config.findRootName(cls));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rootName.isEmpty()) &#123;</span><br><span class="line">    _serialize(gen, value, ser, rootName);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _serialize(gen, value, ser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入JsonGenerator</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_serialize</span><span class="params">(JsonGenerator gen, Object value, JsonSerializer&lt;Object&gt; ser, PropertyName rootName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    gen.writeStartObject();</span><br><span class="line">    gen.writeFieldName(rootName.simpleAsEncoded(_config));</span><br><span class="line">    ser.serialize(value, gen, <span class="keyword">this</span>);</span><br><span class="line">    gen.writeEndObject();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> _wrapAsIOE(gen, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们展示了三层调用层次的方法，排除干扰项，要点如下</p>
<ul>
<li>获取待序列化的类型对应的序列化器</li>
<li>使用找到的序列化器，执行最后的序列化逻辑<ul>
<li>向JsonGenerator写入对象起始符</li>
<li>向JsonGenerator写入根字段名</li>
<li>用得到的序列化器向JsonGenerator写入对象相关信息</li>
<li>向JsonGenerator写入对象结束符</li>
</ul>
</li>
</ul>
<p>这里出现了一个新的概念：序列化器，之前是没有见过的。序列化器和反序列化器的创建，是data-bind的重要内容，我们可以想象一下：序列化器负责对整个对象的序列化，这里的序列化，其实是将对象属性转换为json的token的过程。我们又没有创建序列化器，那要么是编译器创建，要么是运行时创建，很显然前者是不可能的。可以猜测，序列化器的生成，包含了以下逻辑（反序列化类似）</p>
<ul>
<li>包含对Json注解的支持，反射读取注解，然后体现在序列化器上</li>
<li>包含对各种功能的支持，目前data-bind的功能主要有MapperFeature、SerializationFeature、DeserializationFeature的支持，生成序列化器时，根据这些条件动态调整转换行为。这其实最终体现在了SerializationConfig中。</li>
<li>对新增逻辑的支持，module的扩展性，应该要靠它来支持</li>
</ul>
<p>有关序列化器的生成逻辑，主要在SerializerProvider，比较深，有兴趣自己跟跟看，解析一下其生成逻辑。对于一个自定义的POJO，创建逻辑最终会来到这里：com.fasterxml.jackson.databind.ser.BeanSerializerFactory#constructBeanOrAddOnSerializer，逻辑过于复杂，所有上面说的那些都交织在其中，有兴趣可以自己研究。下图展示了构建过程中判断MapperFeature.USE_STATIC_TYPING开关的情况。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013204532184.png" alt="image-20211013204532184"></p>
<p>实际上，序列化器会首先在预先设置的序列化器中查找，然后从缓存中查找，实在没有，才会自动生成，且生成后的序列化器会添加到缓存，避免多次生成，从而提升性能。而那些针对Jackson的三方库，基本都是自定义类型的处理方式，是否可以推测，所谓第三方库，其实就是自己提前定义的序列化器和反序列化器，然后注册进来就好。</p>
<h3 id="正确认识ObjectMapper"><a href="#正确认识ObjectMapper" class="headerlink" title="正确认识ObjectMapper"></a>正确认识ObjectMapper</h3><p>ObjectMapper是Jackson使用的核心，一般来说，一个ObjectMapper实例对应了一套配置，配置一旦添加不可去除，如果想用多套不同的配置，则需维护多个ObjectMapper，这也是常规使用方法，你看整个Spring中，正常情况下，都只有一个ObejctMapper实例的。</p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>在Jackson主项目下，能看到很多第三方插件（数据类型模块），我们来探究它是如何工作的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013205612048.png" alt="image-20211013205612048"></p>
<p>注册一个module的调用方式是</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper().registerModule(JavaTimeModule())</span><br></pre></td></tr></table></figure>

<p>它干了啥呢？参见com.fasterxml.jackson.databind.ObjectMapper#registerModule（代码太长就不贴了），简单说来</p>
<ul>
<li>将Module依赖的Module进行递归注册</li>
<li>将Module中定义的序列化器和反序列化器注册到ObjectMapper</li>
</ul>
<p>当然，能够自定义的，肯定不止序列化器，看com.fasterxml.jackson.databind.Module.SetupContext</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013210926397.png" alt="image-20211013210926397"></p>
<p>可以看到，它提供了多种配置能力，这些能力怎么用，后面可以单独开一篇文章介绍。</p>
<ul>
<li>可开启各种功能</li>
<li>可添加各种序列化器、反序列化器</li>
<li>可添加序列化和反序列化描述符</li>
<li>添加类型解析器</li>
<li>添加注解</li>
<li>注册子类型（用于多态）</li>
<li>混入</li>
<li>命名策略</li>
</ul>
<h2 id="自定义Module"><a href="#自定义Module" class="headerlink" title="自定义Module"></a>自定义Module</h2><p>Jackson提供了SimpleModule，帮助我们在自定义类型module时简化开发，现在我们自定义一个Module。</p>
<p>假设有一系列类型（这里就展示一个），比如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation2</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>现在希望Jackson支持它们，于是可以定义一个Module，它需要包含针对这些类型的序列化器，将这些序列化器包装进一个自定义Module，如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationSerializer</span> : <span class="type">StdSerializer</span>&lt;<span class="type">Operation2</span>&gt;</span>(Operation2::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(value: <span class="type">Operation2</span>?, gen: <span class="type">JsonGenerator</span>, provider: <span class="type">SerializerProvider</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            gen.writeNull()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gen.writeStartObject()</span><br><span class="line">        gen.writeNumberField(<span class="string">&quot;operationId&quot;</span>, value.id!!)</span><br><span class="line">        gen.writeEndObject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationModule</span> : <span class="type">SimpleModule</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        addSerializer(OperationSerializer())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getModuleName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>::<span class="keyword">class</span>.qualifiedName.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在使用时就可以注册并使用了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objectMapper = ObjectMapper().registerModule(OperationModule())</span><br><span class="line">    println(objectMapper.writeValueAsString(Operation2(<span class="number">1</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;operationId&quot;</span>:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与Kotlin序列化对比"><a href="#与Kotlin序列化对比" class="headerlink" title="与Kotlin序列化对比"></a>与Kotlin序列化对比</h2><p>相对而言，Kotlin序列化功能还非常年轻，有类似也有不同，将二者进行对比，有助于理解。</p>
<table>
<thead>
<tr>
<th>Jackson接口</th>
<th>Kotlin接口</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>JsonGenerator/JsonParser</td>
<td>Encoder/Decoder</td>
<td>底层接口，负责将支持的基本类型编码到流中</td>
</tr>
<tr>
<td>JsonSerializer/JsonDeserializer</td>
<td>KSerializer</td>
<td>序列化器/反序列化器，负责将具有结构的对象，转换为基本类型</td>
</tr>
<tr>
<td>ObjectCodec/ObjectMapper</td>
<td>SerialFormat/Json</td>
<td>编解码器，略有不同，不过都是对用户隐藏了实现，暴露简单接口</td>
</tr>
<tr>
<td>TreeNode</td>
<td>JsonElement</td>
<td>树抽象模型，二者都有，不过Jackson的更加强大</td>
</tr>
<tr>
<td>Module</td>
<td>serializerModule</td>
<td>功能完全不一样，但思想类似，都是维护一堆上下文对象。<br />区别在于，前者功能更多；后者只有上下文和多态的声明</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初以为Jackson，区区一Json序列化库，能复杂到哪里去；看了官方手册，不知道是它写的乱，还是我悟性不好，看半天反正不知道在讲啥；后来耐着性子看，并尝试了不少方式，发现用起来还挺简单，模型上又和Kotlin序列化有几分类似，原理上也没那么难懂嘛；多翻一些源码，发现这个历史悠久的库果然不是泛泛之辈，功能太多了，眼花缭乱的，很多功能单拎出来都能写一篇长文，也不怪得网络上那么多Jackson专栏。所以它也不是那种一两天就能搞定的库，更不是一篇文章能说清楚的。</p>
<p>本文我们简要介绍了Jackson的基础能力、基本原理、基本模型等。抓住Jackson主干是主要目的，细枝末节，更加高级偏僻的功能，留待日后探索。通过本文，你应该知道了</p>
<ul>
<li>Jackson由core提供核心能力，data-bind提供各种功能，annotations提供注解支持</li>
<li>Jackson的常用场景使用方法</li>
<li>Jackson和核心原理，Module的工作原理</li>
</ul>
<h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next"></a>What’s Next</h2><p>有了本文的基础，我们就能更加流畅地去看其他文章了，<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson#tutorials">官网推荐的那些</a>就很好</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211014120133817.png" alt="image-20211014120133817"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%BA%8C%20-%20Kotlin-xu-lie-hua-tan-suo-zhi-er-kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%BA%8C%20-%20Kotlin-xu-lie-hua-tan-suo-zhi-er-kotlin/" class="post-title-link" itemprop="url">序列化探索之二 - Kotlin</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-09 17:59:43 / 修改时间：18:00:49" itemprop="dateCreated datePublished" datetime="2021-10-09T17:59:43+08:00">2021-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">后端 | 编程语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>文章不长，但代码演示居多，可选择性阅读</p>
</blockquote>
<p>Kotlin以扩展包的形式提供了序列化能力，使得能够以“Kotlin方式”进行序列化。Kotlin设计目标，是提供一个序列化抽象，具体格式实现可用Json、CBOR、Protobuf、Properties、Yaml等进行替换。但就目前的进度，仅提供了对Json的稳定支持。其它格式都处于试验阶段。</p>
<p>因此，我们看Kotlin的序列化，主要看的就是数据对象与Json之间的序列化和反序列化。</p>
<h2 id="能力展示"><a href="#能力展示" class="headerlink" title="能力展示"></a>能力展示</h2><p>场景假设：需要序列化一个数据类，包含五个字段</p>
<ul>
<li>resourceId：资源ID</li>
<li>resourceType：资源类型</li>
<li>updatedTime：更新时间</li>
<li>usn：更新序列号</li>
<li>data：资源数据</li>
</ul>
<p>为方便演示，这些字段的类型和组织结构依据场景的不同而不同，下面演示针对这个数据类的对象的序列化。</p>
<h3 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h3><p>开局一段基础代码，下面的使用方式应该是我们能够使用得最多的场景和方式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceBasic</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerialName(<span class="meta-string">&quot;id&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerialName(<span class="meta-string">&quot;type&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> updatedTime: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceBasic(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, updatedTime=<span class="variable">$updatedTime</span>, usn=<span class="variable">$usn</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = ResourceBasic&lt;JsonElement&gt;().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = UUID.randomUUID().toString()</span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now().toInstant(ZoneOffset.UTC).toEpochMilli()</span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = buildJsonObject &#123;</span><br><span class="line">            put(<span class="string">&quot;images&quot;</span>, buildJsonArray &#123; add(<span class="string">&quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">val</span> decodedResource = jsonFormat.decodeFromString&lt;ResourceBasic&lt;JsonElement&gt;&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;74020041-79c4-456c-bd42-c372a4049d61&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;record&quot;,</span><br><span class="line">    &quot;updatedTime&quot;: 1633780307486,</span><br><span class="line">    &quot;usn&quot;: null,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;images&quot;: [</span><br><span class="line">            &quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ResourceBasic(resourceId=74020041-79c4-456c-bd42-c372a4049d61, resourceType=record, updatedTime=1633780307486, usn=null, data=&#123;&quot;images&quot;:[&quot;https://www.ppp.com/cdwrgwarhg.png&quot;]&#125;)</span><br></pre></td></tr></table></figure>

<p>上面展示了Kotlin序列化的最基础能力</p>
<ol>
<li>被序列化的类上必须添加@Serializable注解</li>
<li>被序列化的类可以带泛型</li>
<li>可以通过@SerialName注解修改序列化的键名</li>
<li>序列化时调用Json.encodeToString即可</li>
<li>反序列化时调用Json.decodeFromString即可</li>
</ol>
<p>更多参考<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/basic-serialization.md">官方手册</a></p>
<h3 id="自定义序列化逻辑"><a href="#自定义序列化逻辑" class="headerlink" title="自定义序列化逻辑"></a>自定义序列化逻辑</h3><p>上例中更新时间为Long，但实际代码编写中使用LocalDateTime更为方便，此时我们需要为LocalDateTime写一个自定义序列化器。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceInCustomSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serializable(with = LocalDateTimeAsLongSerializer::class)</span></span><br><span class="line">    <span class="keyword">var</span> updatedTime: LocalDateTime? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: JsonElement? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceBasic(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, updatedTime=<span class="variable">$updatedTime</span>, usn=<span class="variable">$usn</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LocalDateTimeAsLongSerializer : KSerializer&lt;LocalDateTime&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = buildClassSerialDescriptor(<span class="string">&quot;java.util.LocalDateTime&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">LocalDateTime</span>)</span></span> &#123;</span><br><span class="line">        encoder.encodeLong(value.toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(decoder.decodeLong()), ZoneOffset.UTC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = ResourceInCustomSerializer().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = UUID.randomUUID().toString()</span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now()</span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = buildJsonObject &#123;</span><br><span class="line">            put(<span class="string">&quot;images&quot;</span>, buildJsonArray &#123; add(<span class="string">&quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">  	<span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">val</span> decodedResource = jsonFormat.decodeFromString&lt;ResourceInCustomSerializer&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>自定义LocalDateTimeAsLongSerializer，实现KSerializer接口，重写一个属性，两个方法<ul>
<li>descriptor：类型描述</li>
<li>serialize：序列化逻辑</li>
<li>deserialize：反序列化逻辑</li>
</ul>
</li>
<li>@Serializable(with = LocalDateTimeAsLongSerializer::class)标注在目标属性上</li>
</ul>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上面的例子再变一下，updateTime有时可能想要转换为Long，有时却想要转换为ISO8601格式的字符串。即，要求根据不同<strong>上下文</strong>的变化选择不同的序列化器。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceInCustomSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contextual</span></span><br><span class="line">    <span class="keyword">var</span> updatedTime: LocalDateTime? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: JsonElement? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceBasic(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, updatedTime=<span class="variable">$updatedTime</span>, usn=<span class="variable">$usn</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LocalDateTimeAsLongSerializer : KSerializer&lt;LocalDateTime&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = buildClassSerialDescriptor(<span class="string">&quot;java.util.LocalDateTime&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">LocalDateTime</span>)</span></span> &#123;</span><br><span class="line">        encoder.encodeLong(value.toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(decoder.decodeLong()), ZoneOffset.UTC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LocalDateTimeAsStringSerializer : KSerializer&lt;LocalDateTime&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = buildClassSerialDescriptor(<span class="string">&quot;java.util.LocalDateTime&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">LocalDateTime</span>)</span></span> &#123;</span><br><span class="line">        encoder.encodeString(value.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(decoder.decodeString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource = ResourceInCustomSerializer().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = UUID.randomUUID().toString()</span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now()</span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = buildJsonObject &#123;</span><br><span class="line">            put(<span class="string">&quot;images&quot;</span>, buildJsonArray &#123; add(<span class="string">&quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">        serializersModule = serializersModuleOf(LocalDateTime::<span class="class"><span class="keyword">class</span>, <span class="type">LocalDateTimeAsLongSerializer)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LocalDateTime转换为Long的序列化和反序列化</span></span><br><span class="line">    <span class="keyword">var</span> jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="keyword">var</span> decodedResource = jsonFormat.decodeFromString&lt;ResourceInCustomSerializer&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line"></span><br><span class="line">    jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">        serializersModule = serializersModuleOf(LocalDateTime::<span class="class"><span class="keyword">class</span>, <span class="type">LocalDateTimeAsStringSerializer)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LocalDateTime转换为String的序列化和反序列化</span></span><br><span class="line">    jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    decodedResource = jsonFormat.decodeFromString&lt;ResourceInCustomSerializer&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>目标字段使用@Contextual注解，表明该字段的序列化器到上下文中去找</li>
<li>定义多个针对LocalDateTime的序列化器</li>
<li>在Json实例中，指定当前所用序列化模块，为LocalDateTime注册对应的序列化器，上面，我们用了两个Json实例，分别对应不同的上下文，注册不同的序列化器，对同一个对象的序列化结果有了不同的行为</li>
</ul>
<h3 id="序列化的多态"><a href="#序列化的多态" class="headerlink" title="序列化的多态"></a>序列化的多态</h3><p>如果我们的Resource有两个版本，它们拥有共同的三个属性：resourceId、resourceType、data，其中一个版本拥有updatedTime，另一个版本拥有usn，于是有了类型的层次结构。现在假设我有一个列表，该列表同时有两个版本的数据，为了在反序列化时能够恢复出具体元素的类型，在序列化时就需要将元素的类型信息也进行序列化，这就是序列化的多态。如果你觉得对这个概念模式，谷歌一下“jackson @class”，一定是似曾相识。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: String? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceWithUsn</span> : <span class="type">ResourceBase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceWithUpdatedTime</span> : <span class="type">ResourceBase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> updatedTime: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resources = listOf(</span><br><span class="line">        ResourceWithUsn().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceId = <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="string">&quot;这是数据&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.usn = <span class="number">123</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ResourceWithUpdatedTime().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceId = <span class="string">&quot;2&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.resourceType = <span class="string">&quot;tag&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="string">&quot;这是标签&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.updatedTime = Instant.now().toEpochMilli()</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        classDiscriminator = <span class="string">&quot;@class&quot;</span></span><br><span class="line">        serializersModule = SerializersModule &#123;</span><br><span class="line">            polymorphic(ResourceBase::<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                subclass(ResourceWithUpdatedTime::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">                subclass(ResourceWithUsn::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonString = jsonFormat.encodeToString(resources)</span><br><span class="line">    println(jsonString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;@class&quot;</span>: <span class="string">&quot;com.gitee.floyd.serialization.kotlin.ResourceWithUsn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceType&quot;</span>: <span class="string">&quot;record&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: <span class="string">&quot;这是数据&quot;</span>,</span><br><span class="line">        <span class="string">&quot;usn&quot;</span>: 123</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;@class&quot;</span>: <span class="string">&quot;com.gitee.floyd.serialization.kotlin.ResourceWithUpdatedTime&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceId&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: <span class="string">&quot;这是标签&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updatedTime&quot;</span>: 1633753842785</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>父类和子类都要标注@Serializable</li>
<li>Json实例中，注册多态声明，这里，我们声明ResourceBase的子类包含ResourceWithUpdatedTime、ResourceWithUsn</li>
<li>可以通过classDiscriminator自定义类型标记的key，这里写成@class，是为了让读者回想起jackson</li>
</ul>
<p>Kotlin实际的多态稍有不同，由于Kotlin序列化的大部分工作都是在编译期完成的，因此将一个待序列化的对象声明为其父类型，也能够触发多态。还有接口、密封类在多态中也有不同的特性，具体参见<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md">官方手册</a></p>
<blockquote>
<p><strong>Java会有多态问题吗？</strong></p>
<p>不会，Java序列化结果是二进制流，其中已经包含类型信息，不存在反序列化时候不知道具体类型的情况。也就是说，序列化的多态问题，只是对语言无关的序列化格式如Json有意义。</p>
</blockquote>
<h3 id="Json能力"><a href="#Json能力" class="headerlink" title="Json能力"></a>Json能力</h3><p>之前在使用Vertx时，深感其提供的Json库好用至极；Jackson也提供了Tree Mode，让用户能够在不创建类对象的情况下灵活构建Json对象；kotlin也提供了类似的能力——JsonElement，不过它没那么强大：能够凭空构建一个JsonElement，能够遍历其中的数据，却不能修改其中的数据。</p>
<p>当然，Json能力并非本文的重点，我们的重点在于探究Kotlin序列化的使用方式和原理，因此有关Json能力，参考<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#json-elements">官方手册</a>。</p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>Kotlin序列化几乎所有逻辑都在编译期生成。因此，配置Kotlin序列化时，需要同时引入序列化插件和序列化包</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;plugin.serialization&quot;</span>) version <span class="string">&quot;1.5.31&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从-Serializable讲起"><a href="#从-Serializable讲起" class="headerlink" title="从@Serializable讲起"></a>从@Serializable讲起</h3><p>为目标类添加@serializable注解，编译器会自动生成序列化逻辑，以一个最简单的类进行展示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其字节码反编译结果整理之后如下（去除了多余的噪声）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleData.Companion Companion = ... ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JvmStatic</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> write$Self(SimpleData self, CompositeEncoder output, SerialDescriptor serialDesc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Intrinsics.areEqual(self.id, (Object)<span class="keyword">null</span>) ^ <span class="keyword">true</span> || output.shouldEncodeElementDefault(serialDesc, <span class="number">0</span>)) &#123;</span><br><span class="line">      output.encodeNullableSerializableElement(serialDesc, <span class="number">0</span>, (KSerializer)LongSerializer.INSTANCE, self.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> KSerializer <span class="title">serializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (KSerializer)SimpleData.$serializer.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">serializer</span> <span class="keyword">implements</span> <span class="title">GeneratedSerializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleData.$serializer INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerialDescriptor $$serialDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $serializer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      SimpleData.$serializer var0 = <span class="keyword">new</span> SimpleData.$serializer();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      PluginGeneratedSerialDescriptor var1 = <span class="keyword">new</span> PluginGeneratedSerialDescriptor(<span class="string">&quot;com.gitee.floyd.serialization.kotlin.SimpleData&quot;</span>, (GeneratedSerializer)INSTANCE, <span class="number">1</span>);</span><br><span class="line">      var1.addElement(<span class="string">&quot;id&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">      $$serialDesc = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> KSerializer[] typeParametersSerializers() &#123;</span><br><span class="line">      <span class="keyword">return</span> DefaultImpls.typeParametersSerializers(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerialDescriptor <span class="title">getDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> $$serialDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Encoder encoder, SimpleData value)</span> </span>&#123;</span><br><span class="line">      SerialDescriptor var3 = $$serialDesc;</span><br><span class="line">      Encoder encoder = encoder.beginStructure(var3);</span><br><span class="line">      SimpleData.write$Self(value, encoder, var3);</span><br><span class="line">      encoder.endStructure(var3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Encoder var1, Object var2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.serialize(var1, (SimpleData)var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleData <span class="title">deserialize</span><span class="params">(Decoder decoder)</span> </span>&#123;</span><br><span class="line">      SerialDescriptor var2 = $$serialDesc;</span><br><span class="line">      <span class="keyword">int</span> var4 = <span class="number">0</span>;</span><br><span class="line">      Long var5 = <span class="keyword">null</span>;</span><br><span class="line">      Decoder decoder = decoder.beginStructure(var2);</span><br><span class="line">      <span class="keyword">if</span> (decoder.decodeSequentially()) &#123;</span><br><span class="line">        var5 = (Long)decoder.decodeNullableSerializableElement(var2, <span class="number">0</span>, (KSerializer)LongSerializer.INSTANCE, var5);</span><br><span class="line">        var4 = Integer.MAX_VALUE;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> var3 = decoder.decodeElementIndex(var2);</span><br><span class="line">          <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              var5 = (Long)decoder.decodeNullableSerializableElement(var2, <span class="number">0</span>, (KSerializer)LongSerializer.INSTANCE, var5);</span><br><span class="line">              var4 |= <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> (Throwable)(<span class="keyword">new</span> UnknownFieldException(var3));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      decoder.endStructure(var2);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SimpleData(var4, var5, (SerializationConstructorMarker)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(Decoder var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.deserialize(var1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解读一下生成的这个类</p>
<ul>
<li>编译器生成了伴生类Companion，同时附带serializer()方法，返回一个KSerializer对象</li>
<li>类本身新增静态方法<code>write$Self(SimpleData self, CompositeEncoder output, SerialDescriptor serialDesc)</code>，在生成的序列化器中有被调用</li>
<li>看生成的序列化器内部——getDescriptor方法，返回一个SerialDescriptor对象</li>
<li>看生成的序列化器内部——serialize方法<ul>
<li>传入Encoder对象、数据类对象</li>
<li>调用Encoder的方法，将数据类型写入</li>
</ul>
</li>
<li>看生成的序列化器内部——deserialize方法<ul>
<li>传入Decoder</li>
<li>从decoder中解析出字段，构建新的SimpleData对象并传入</li>
</ul>
</li>
<li>看生成的序列化器，跟上面我们自己写的序列化器，像不像，其实它们就是一样的。</li>
</ul>
<p>要点</p>
<ul>
<li><p>添加了@Serializable的类，会自动生成属于自己类的序列化器</p>
</li>
<li><p>实际上随着Kotlin序列化库的引入，你会发现，所有Kotlin原生类型也都被添加了一个扩展方法，serializer()</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211009145331561.png" alt="image-20211009145331561"></p>
<p>点进去看看他们的逻辑，依然是内置实现了KSerializer</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> String.Companion.<span class="title">serializer</span><span class="params">()</span></span>: KSerializer&lt;String&gt; = StringSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> StringSerializer : KSerializer&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = PrimitiveSerialDescriptor(<span class="string">&quot;kotlin.String&quot;</span>, PrimitiveKind.STRING)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">String</span>)</span></span>: <span class="built_in">Unit</span> = encoder.encodeString(value)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: String = decoder.decodeString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们会发现几个关键定义：KSerializer、SerialDescriptor、Encoder、Decoder、SerialKind，搞清楚它们之间的联系，就基本清楚了Kotlin的序列化原理。</p>
</li>
</ul>
<h3 id="Kotlin序列化的设计思路"><a href="#Kotlin序列化的设计思路" class="headerlink" title="Kotlin序列化的设计思路"></a>Kotlin序列化的设计思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---------+  Serialization  +------------+  Encoding  +---------------+</span><br><span class="line">| Objects | --------------&gt; | Primitives | ---------&gt; | Output format |</span><br><span class="line">+---------+                 +------------+            +---------------+</span><br></pre></td></tr></table></figure>

<p>这张图取自<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/basic-serialization.md#basics">官方手册</a>，对于理解至关重要。Kotlin将序列化分为两个阶段</p>
<ul>
<li>阶段一（序列化）：将目标对象序列化成基础类型，如Long、Char、String等，这一步是通用的，与最终序列化格式无关。这一步对应KSerializer</li>
<li>阶段二（编码）：基础类型编码为最终格式，如Json、Protobuf。这一步对应Encoder、Decoder</li>
</ul>
<h3 id="核心类解析"><a href="#核心类解析" class="headerlink" title="核心类解析"></a>核心类解析</h3><p>现在我们可以来看那几个关键定义</p>
<ul>
<li><p>KSerializer</p>
<p>它定义了Encoder和目标对象value的关系，即控制了编码器编码和解码目标对象的逻辑。编码时，需要用到类描述信息SerialDescriptor</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KSerializer</span>&lt;<span class="type">T</span>&gt; : <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, <span class="type">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializationStrategy</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> descriptor: SerialDescriptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> descriptor: SerialDescriptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SerialDescriptor</p>
<p>从名称就可得知，它定义了目标类型的描述信息，它的常规实现是SerialDescriptorImpl</p>
<ul>
<li>serialName：序列化名称，一般是类名</li>
<li>kind：目标类型，下文会讲</li>
<li>elements：当为类类型时，会包含多个属性，它们是以元素集合的形式提供的，具体可以看SerialDescriptorImpl实现</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerialDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> serialName: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> kind: SerialKind</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isNullable: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isInline: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> elementsCount: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> annotations: List&lt;Annotation&gt; <span class="keyword">get</span>() = emptyList()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getElementName</span><span class="params">(index: <span class="type">Int</span>)</span></span>: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getElementIndex</span><span class="params">(name: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getElementAnnotations</span><span class="params">(index: <span class="type">Int</span>)</span></span>: List&lt;Annotation&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isElementOptional</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Encoder/Decoder</p>
<p>上面说了，Encoder负责从原始类型向最终类型的转换，从接口定义就能看出</p>
<ul>
<li>serializersModule：这是一个专门为上下文和多态准备的类，下面会讲到</li>
<li>encodeXXX：写入各种类型的数据，其中枚举和内联类一般会特殊处理</li>
<li>beginStructure：当要编码的是一个复杂对象时，就需要用到CompositeEncoder，具体参见其源码，不过原理和Encoder差不多，套娃而已</li>
<li>最后两个方法只是快捷方法，用户自定义序列化器的情况：其实也只是套娃而已。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> serializersModule: SerializersModule</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeNotNullMark</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeNull</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeBoolean</span><span class="params">(value: <span class="type">Boolean</span>)</span></span></span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">//所有原始类型的编码方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeString</span><span class="params">(value: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeEnum</span><span class="params">(enumDescriptor: <span class="type">SerialDescriptor</span>, index: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeInline</span><span class="params">(inlineDescriptor: <span class="type">SerialDescriptor</span>)</span></span>: Encoder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">beginStructure</span><span class="params">(descriptor: <span class="type">SerialDescriptor</span>)</span></span>: CompositeEncoder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any?&gt;</span> <span class="title">encodeSerializableValue</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        serializer.serialize(<span class="keyword">this</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">encodeNullableSerializableValue</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> isNullabilitySupported = serializer.descriptor.isNullable</span><br><span class="line">        <span class="keyword">if</span> (isNullabilitySupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> encodeSerializableValue(serializer <span class="keyword">as</span> SerializationStrategy&lt;T?&gt;, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            encodeNull()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encodeNotNullMark()</span><br><span class="line">            encodeSerializableValue(serializer, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SerialKind</p>
<p>枚举了所有类型，其中CONTEXTUAL（上下文）和PolymorphicKind（多态）下文有详细讲解</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialKind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> ENUM : SerialKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> CONTEXTUAL : SerialKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveKind</span> : <span class="type">SerialKind</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> BOOLEAN : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> BYTE : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> CHAR : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> SHORT : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> INT : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> LONG : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> FLOAT : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> DOUBLE : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> STRING : PrimitiveKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">StructureKind</span> : <span class="type">SerialKind</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> CLASS : StructureKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> LIST : StructureKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> MAP : StructureKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> OBJECT : StructureKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicKind</span> : <span class="type">SerialKind</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> SEALED : PolymorphicKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> OPEN : PolymorphicKind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="看看Json序列化的实现"><a href="#看看Json序列化的实现" class="headerlink" title="看看Json序列化的实现"></a>看看Json序列化的实现</h3><p>先引入一个定义：SerialFormat，它是专门定义用来作为序列化入口的接口，我们的实现类都使用它，包括Json类（这里的serializersModule暂且忽略）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerialFormat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> serializersModule: SerializersModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常用的它的子类：StringFormat，定义了针对字符串的操作方式，及其快捷方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StringFormat</span> : <span class="type">SerialFormat &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">encodeToString</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">decodeFromString</span><span class="params">(deserializer: <span class="type">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt;, string: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> StringFormat.<span class="title">encodeToString</span><span class="params">(value: <span class="type">T</span>)</span></span>: String =</span><br><span class="line">    encodeToString(serializersModule.serializer(), value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> StringFormat.<span class="title">decodeFromString</span><span class="params">(string: <span class="type">String</span>)</span></span>: T =</span><br><span class="line">    decodeFromString(serializersModule.serializer(), string)</span><br></pre></td></tr></table></figure>

<p>最常用的序列化方法是<code>StringFormat.encodeToString(value: T)</code>，实际调用<code>Json.encodeToString</code>，它的逻辑：创建StreamingJsonEncoder（Encoder的实现类），将数据写入JsonStringBuilder，完成后转换为字符串进行返回。进入StreamingJsonEncoder查看，可以看到它定义了Composer类，控制Json格式的组合</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">encodeToString</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> result = JsonStringBuilder()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> encoder = StreamingJsonEncoder(</span><br><span class="line">      result, <span class="keyword">this</span>,</span><br><span class="line">      WriteMode.OBJ,</span><br><span class="line">      arrayOfNulls(WriteMode.values().size)</span><br><span class="line">    )</span><br><span class="line">    encoder.encodeSerializableValue(serializer, value)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    result.release()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们去AbstractJsonLexer.kt下面看，还可以看到预定义的各种Json元字符。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211009154534756.png" alt="image-20211009154534756" style="zoom:80%;" />

<h3 id="实现上下文和多态"><a href="#实现上下文和多态" class="headerlink" title="实现上下文和多态"></a>实现上下文和多态</h3><p>前文我们能够看到，在使用上下文和多态功能时，会创建SerializersModule，事实上，SerializersModule就是专门为上下文和多态设计的，因此首先要拆解SerializersModule，可以看到，它只包含了两类方法，上下文和多态，其中上下文返回的是KSerializer，多态在序列化和反序列化各自定义了一个方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializersModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getContextual</span><span class="params">(kclass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;)</span></span>: KSerializer&lt;T&gt;? =</span><br><span class="line">        getContextual(kclass, emptyList())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getContextual</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        kClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        typeArgumentsSerializers: <span class="type">List</span>&lt;<span class="type">KSerializer</span>&lt;*&gt;&gt; = emptyList()</span></span></span><br><span class="line">    ): KSerializer&lt;T&gt;?</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: SerializationStrategy&lt;T&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, serializedClassName: <span class="type">String</span>?)</span></span>: DeserializationStrategy&lt;<span class="keyword">out</span> T&gt;?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其唯一的实现类SerialModuleImpl如下，它维护了四个map</p>
<ul>
<li>class2ContextualFactory：存储类型和上下文Provider的映射，上下文Provider根据类型参数得到最终的序列化器</li>
<li>polyBase2Serializers：存储了基类和具体值的真实类型的序列化器的映射关系，用于多态序列化</li>
<li>polyBase2NamedSerializers：存储了基类和序列化后的类名的反序列化器的映射关系，用于多态反序列化</li>
<li>polyBase2DefaultProvider：存储了针对基类的默认反序列化器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialModuleImpl</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> class2ContextualFactory: Map&lt;KClass&lt;*&gt;, ContextualProvider&gt;,</span><br><span class="line">  <span class="meta">@JvmField</span> <span class="keyword">val</span> polyBase2Serializers: Map&lt;KClass&lt;*&gt;, Map&lt;KClass&lt;*&gt;, KSerializer&lt;*&gt;&gt;&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> polyBase2NamedSerializers: Map&lt;KClass&lt;*&gt;, Map&lt;String, KSerializer&lt;*&gt;&gt;&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> polyBase2DefaultProvider: Map&lt;KClass&lt;*&gt;, PolymorphicProvider&lt;*&gt;&gt;</span><br><span class="line">) : SerializersModule() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: SerializationStrategy&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value.isInstanceOf(baseClass)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> polyBase2Serializers[baseClass]?.<span class="keyword">get</span>(value::<span class="class"><span class="keyword">class</span>) <span class="title">as</span>? <span class="title">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, serializedClassName: <span class="type">String</span>?)</span></span>: DeserializationStrategy&lt;<span class="keyword">out</span> T&gt;? &#123;</span><br><span class="line">    <span class="comment">// Registered</span></span><br><span class="line">    <span class="keyword">val</span> registered = polyBase2NamedSerializers[baseClass]?.<span class="keyword">get</span>(serializedClassName) <span class="keyword">as</span>? KSerializer&lt;<span class="keyword">out</span> T&gt;</span><br><span class="line">    <span class="keyword">if</span> (registered != <span class="literal">null</span>) <span class="keyword">return</span> registered</span><br><span class="line">    <span class="comment">// Default</span></span><br><span class="line">    <span class="keyword">return</span> (polyBase2DefaultProvider[baseClass] <span class="keyword">as</span>? PolymorphicProvider&lt;T&gt;)?.invoke(serializedClassName)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getContextual</span><span class="params">(kClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;, typeArgumentsSerializers: <span class="type">List</span>&lt;<span class="type">KSerializer</span>&lt;*&gt;&gt;)</span></span>: KSerializer&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">return</span> (class2ContextualFactory[kClass]?.invoke(typeArgumentsSerializers)) <span class="keyword">as</span>? KSerializer&lt;T&gt;?</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以按照步骤来看上下文和多态的实现方方法了</p>
<ol>
<li><p>注册类和对应的序列化器，实际上就是创建SerialModuleImpl对象，并赋值给SerialFormat的serializersModule属性。</p>
<p>实际写入的是SerialModuleImpl.class2ContextualFactory属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Json &#123;</span><br><span class="line">  serializersModule = serializersModuleOf(LocalDateTime::<span class="class"><span class="keyword">class</span>, <span class="type">LocalDateTimeAsLongSerializer)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用StringFormat.encodeToString()，它调用serializersModule.serializer()方法获取对应的序列化器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> StringFormat.<span class="title">encodeToString</span><span class="params">(value: <span class="type">T</span>)</span></span>: String =</span><br><span class="line">    encodeToString(serializersModule.serializer(), value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> SerializersModule.<span class="title">serializer</span><span class="params">()</span></span>: KSerializer&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> serializer(typeOf&lt;T&gt;()).cast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就在<code>serializer(typeOf&lt;T&gt;())</code>了，根据类型确定序列化器（走反射），源码过长过碎，这里就不展示了，只说大致逻辑</p>
<ul>
<li>如果类型是枚举，则创建枚举序列化器</li>
<li>如果是接口，则创建PolymorphicSerializer，即多态序列化器，</li>
<li>如果伴生对象中存在序列化器，则直接使用（@Serializable自动生成的那个）</li>
<li>如果有Polymorphic注解，或者Serializable直接中明确指明使用PolymorphicSerializer，则返回多态序列化器</li>
<li>否则，调用SerialModuleImpl.getContextual()方法，根据类获取之前注册到上下文中的序列化器。</li>
</ul>
<p>可以看到，在不同的情况下，会返回不同的序列化器，所谓上下文和多态，都是通过序列化器实现的。这里要多提的一点是，多态一定是通过PolymorphicSerializer实现的，因为它需要添加一个type字段。</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到，上下文和多态，实际上都只是根据类型确定序列化器和反序列化器的过程，而这些序列化器默认来自SerializersModule。</p>
<p>当然，我们最终也可以显式地指定序列化器，跳过这个决定的过程，毕竟，StringFormat的方法都可以接收序列化器。</p>
<h2 id="开发属于自己的序列化格式"><a href="#开发属于自己的序列化格式" class="headerlink" title="开发属于自己的序列化格式"></a>开发属于自己的序列化格式</h2><p>这里做一个小演示，如果我想要实现自己的序列化格式，只需要三步</p>
<ol>
<li>实现Encoder</li>
<li>实现SerialFormat</li>
<li>使用</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Encoder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloydEncoder</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sb: StringBuilder,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> serializersModule: SerializersModule</span><br><span class="line">) : AbstractEncoder() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeValue</span><span class="params">(value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;<span class="variable">$value</span>&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeElement</span><span class="params">(descriptor: <span class="type">SerialDescriptor</span>, index: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;&#123;<span class="subst">$&#123;descriptor.getElementName(index)&#125;</span>=&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现SerialFormat</span></span><br><span class="line"><span class="keyword">object</span> Floyd : StringFormat &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> serializersModule: SerializersModule = EmptySerializersModule</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">decodeFromString</span><span class="params">(deserializer: <span class="type">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt;, string: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">encodeToString</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        FloydEncoder(sb, serializersModule).encodeNullableSerializableValue(serializer, value).toString()</span><br><span class="line">        <span class="keyword">return</span> sb.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: String,</span><br><span class="line">    <span class="keyword">val</span> desc: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = Resource(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;用于测试自定义Encoder的资源&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> encodeString = Floyd.encodeToString(resource)</span><br><span class="line">    println(encodeString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=1&#125;&#123;desc=用于测试自定义Encoder的资源&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哪些文档能看"><a href="#哪些文档能看" class="headerlink" title="哪些文档能看"></a>哪些文档能看</h2><p>这里只讲了主要部分，具体细节还有更多，目前网络上系统介绍Kotlin序列化的文章不多，还是以官方文档为主</p>
<ul>
<li>首推<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md">官方文档</a></li>
<li>然后<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization-core/kotlinx-serialization-core/index.html">Kotlin 序列化Api doc</a></li>
<li>然后是源码</li>
</ul>
<p>不过看源码有一个很重的感受：Kotlin库总是将抽象本身定义得比较抽象，然后大量使用扩展方法来为这些抽象增加能力，这会导致代码片段比较碎。如果用IDEA查看源码，会出现库的索引页全是类型，极不方便查找，但事实上可能只有少数几个kt源文件，所以需要探寻更加时刻Kotlin库的源码查看方式。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>优点</p>
<ul>
<li>Kotlin原生，使用起来相对优雅</li>
<li>其抽象逻辑具有很强的扩展性，要基于此实现自己的序列化格式也比较容易</li>
<li>序列化逻辑编译期生成，可能会比较快，这点尚未验证</li>
</ul>
<p>缺点</p>
<ul>
<li>太新，不够成熟，尽管Json版本已经稳定了，但其中很多API还是被标注为“实验性”的。如果线上要使用，我可能还是会选择Jackson吧。</li>
<li>不能很好滴和第三方库如Spring等很好地融合。</li>
</ul>
<p>此外，本文所有代码，都能在<a target="_blank" rel="noopener" href="https://gitee.com/zou8944/play-floyd/tree/master/serialization/src/main/kotlin/com/gitee/floyd/serialization/kotlin">这里</a>找到。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%B8%80%20-%20Java-xu-lie-hua-tan-suo-zhi-yi--java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%B8%80%20-%20Java-xu-lie-hua-tan-suo-zhi-yi--java/" class="post-title-link" itemprop="url">序列化探索之一 - Java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-06 19:17:59" itemprop="dateCreated datePublished" datetime="2021-10-06T19:17:59+08:00">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>序列化和反序列化，渗透在日常开发的方方面面。</p>
<p>所谓的序列化，就是将数据转换为能够在网络上传输、在数据库中存储、在文件中持久化的格式，这类格式很多，可以是字节流（如Java自带的序列化机制）、可以是JSON（系统之间传输用的较多）、可以是Protocol Buffers（压缩率高，GRPC有用）。反序列化，即序列化的反过程。</p>
<p>序列化这件事，不同的语言、库，提供了不同的使用方法，哪怕是对同一种序列化格式的支持也有差别。因此，深入了解常用的序列化技术，很有必要。不要再去记使用方法了，我们来看原理吧。</p>
<h2 id="序列化探索思路"><a href="#序列化探索思路" class="headerlink" title="序列化探索思路"></a>序列化探索思路</h2><p>从序列化格式看，市面上有很多种，我选取最常用的两种：JSON和ProtoBuf。对JSON，协议本身比较简单，主要关注不同库的使用方式和原理、功能和性能差异，重点放在使用最为广泛的Jackson和最快bug也最多的FastJson上；对ProtoBuf，协议本身就具有一定的特点，因此重点放在协议的研究上。</p>
<p>从语言层面看，每种语言一般都会提供序列化的方式，作为对该语言了解的一部分，它提供的序列化也需要研究。这方面的重点我放在Java和Kotlin上。</p>
<p>综上，我们将会分为四个部分学习探索</p>
<ul>
<li>Java的序列化支持</li>
<li>Kotlin的序列化支持</li>
<li>JSON序列化专题探究</li>
<li>ProtoBuf序列化专题探究</li>
</ul>
<p>本文，就是Java。</p>
<h2 id="Java序列化的使用方法"><a href="#Java序列化的使用方法" class="headerlink" title="Java序列化的使用方法"></a>Java序列化的使用方法</h2><p>作为一个Java码农，一定会记得Java序列化的使用方式：目标类实现Serializable接口，给出serialVersionUID常量。然后该类的对象就能够被序列化了。这没错，但不完整，Java序列化能做的，远比这个多。</p>
<p>具体来讲，实现序列化，Java提供了两个接口：Serializable和Externalizable，实现前者的类的序列化逻辑由Java提供，自己能够稍微干涉；实现后者的类的序列化逻辑则完全由该类自己提供。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Java中，一个能够被序列化的类，必须满足如下条件</p>
<ul>
<li>实现Serializable接口</li>
<li>指定需要序列化的字段值，两种方法<ul>
<li>排除法：默认所有字段都会被序列化，如果某个字段不需要，使用transient关键字排除</li>
<li>显式声明法：声明serialPersistentFields变量，声明需要被序列化的字段</li>
</ul>
</li>
</ul>
<p>也就是说，下面两种序列化的声明方式，是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String description;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式声明法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;id&quot;</span>, String.class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;title&quot;</span>, String.class),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>One Tip：Kotlin中使用Java序列化时，是没有transient关键字的，此时使用@Transient注解替代</p>
</blockquote>
<p>此外，它还能增加一些方法以更加个性化地控制序列化和反序列化</p>
<ul>
<li>writeObject()：控制写</li>
<li>readObject()：控制读</li>
<li>writeReplace()：指定一个替换对象写进流</li>
<li>readResolve()：指定一个从流读出来的对象的替换对象</li>
</ul>
<p>需要注意的是，上述两个write方法互斥，两个read方法互斥，如果同时存在，则只有后面的会生效。writeReplace和readResolve互斥，如果同时存在，只会writeReplace生效。下面演示readResolve()，同时通过注释的方式将其它三个方法签名给出，以供参考。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private void writeObject(ObjectOutputStream stream) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;执行writeObject&quot;);</span></span><br><span class="line"><span class="comment">//        stream.writeLong(0xfffffff);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;执行readObject&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private Object writeReplace() throws ObjectStreamException &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;执行writeReplace&quot;);</span></span><br><span class="line"><span class="comment">//        return &quot;替换成了一个String&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行readResolve&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Video(<span class="string">&quot;ID&quot;</span>, <span class="string">&quot;标题&quot;</span>, <span class="string">&quot;描述&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">        Video oldVideo = <span class="keyword">new</span> Video(<span class="string">&quot;旧ID&quot;</span>, <span class="string">&quot;旧标题&quot;</span>, <span class="string">&quot;旧描述&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化前：&quot;</span> + oldVideo);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(oldVideo);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化后：&quot;</span> + bos);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        Video newVideo = (Video) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化后：&quot;</span> + newVideo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行main方法，能够输出如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">序列化前：Video(id=旧ID, title=旧标题, description=旧描述)</span><br><span class="line">序列化后：��sr<span class="comment">#com.gitee.floyd.serialization.Video����.@LdescriptiontLjava/lang/String;Lidq~Ltitleq~xpt	旧描述t旧IDt	旧标题</span></span><br><span class="line">执行readResolve</span><br><span class="line">反序列化后：Video(id=ID, title=标题, description=描述)</span><br></pre></td></tr></table></figure>

<p>从输出我们看出几点</p>
<ul>
<li>序列化后的字节流其实有一定规律，将其转换为字符串后还有一定可读性。其规律遵循Java序列化流语法规范，稍后讨论。</li>
<li>执行了readResolve，并且其返回值替换了我们原先的对象。</li>
</ul>
<blockquote>
<p>为了更直观地观察序列化后的内容，我们可以通过<a target="_blank" rel="noopener" href="https://bined.exbin.org/intellij-plugin/">IDEA二进制插件</a>查看，对上面的内容，我们能够得到如下。脱离IDEA的单独软件，也可以使用<a target="_blank" rel="noopener" href="https://hexed.it/">HexEdit</a>（亲测好用）</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211006160453425.png" alt="image-20211006160453425"></p>
</blockquote>
<h3 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h3><p>首先要理解这个接口，所谓“外部”序列化，重点在理解这个“外部”，它不是代码的外部，而是Java自身序列化逻辑的外部，相当于一方和二方的差别。具体来说，对Serializable的支持，Java提供完整的序列化规范，用户可以完全撒手不管；而Externalizable，Java除了将类ID写入，整个序列化和反序列化逻辑是完全由用户控制。</p>
<p>选用时，如果自定义序列化程度非常高，可以使用Externalizable，如果依旧需要Java的序列化逻辑，使用Serializable，具体方式可参考<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-externalizable">这篇文章</a>。</p>
<p>同样，对于支持外部序列化的类，必须满足如下条件</p>
<ul>
<li>实现Externalizable接口</li>
<li>实现接口的writeExternal和readExternal方法</li>
</ul>
<p>也可以实现下面两个方法，其作用和前文所述完全一样</p>
<ul>
<li>writeReplace：指定一个替换对象写进流</li>
<li>readResolve：指定一个从流读出来的对象的替换对象</li>
</ul>
<h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>提出问题：</p>
<ul>
<li><p>serialVersionID有什么用？如果没有行不行？</p>
</li>
<li><p>不同的类具有相同的serialVersionID，会有什么影响？</p>
</li>
<li><p>同一个类的serialVersionID不同时，会有什么影响？</p>
</li>
<li><p>同一个类演变多次，实际不兼容，却还有一个serialVersionID时，会有什么影响？</p>
</li>
</ul>
<p>serialVersionUID用于做序列化的版本控制：在反序列化时，反序列化器会检测输入流中的serialVersionUID和目标类的serialVersionUID是否一致，如果一致则继续反序列化流程，否则抛出异常。但这个行为，是果不是因。具体怎么说，参考下文的“版本控制”。这里我们先看它的生成方式。</p>
<p>上面的例子，我们并没有提供serialVersionUID常量。事实上，如果不提供，Java会按照默认算法提供一个。计算方式如下</p>
<ol>
<li>使用DataOutputStream构建一个字节流，其输入组成由<ul>
<li>类名</li>
<li>类修饰符标记</li>
<li>类的接口的名字排序后组成的字符串</li>
<li>类中所有的字段，除static和transient的：字段名、修饰符标记、描述符</li>
<li>类的初始化器：方法名(&lt;cinit&gt;)、修饰符标记(java.lang.reflect.Modifier.STATIC)、描述符(()v)</li>
<li>类的所有非私有构造方法：方法名(&lt;init&gt;)、修饰符标记、描述符</li>
<li>类的所有非私有方法：方法名、修饰符标记、描述符</li>
</ul>
</li>
<li>对上述字节流进行SHA-1摘要计算，生成5个32bit值</li>
<li>取摘要计算的最高两个32位构成serialVersionUID</li>
</ol>
<p>虽然这个生成逻辑看起来比较周到，但它有可能随着编译器的变化而变化，对同一个类，不同的编译器可能生成不同的serialVersionUID，因此，最好的方式还是我们自己指定serialVersionUID。</p>
<blockquote>
<p>One Tip：IDEA中创建类时，没有生成serialVersionUID的固定快捷键可用，可安装GenerateSerialVersionUID插件，在generate菜单中增加一个自动生成serialVersionUID的功能。看了一下<a target="_blank" rel="noopener" href="https://github.com/jbellassai/idea-GenerateSerialVersionUID/blob/master/src/org/intellij/plugins/serial/siyeh_ig/fixes/SerialVersionUIDBuilder.java">它生成serialVersionUID的逻辑</a>，也是根据类的完整特征生成的，包括了类名、描述符、方法签名等。</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>对一个类序列化，会递归序列化器所有属性，这就要求与其关联的所有属性的类都可被序列化</li>
<li>枚举的序列化与常规对象不同，只会序列化其name，读取时读取name，然后调用该枚举类型的valueof方法获取原枚举</li>
<li>不建议对内部类进行序列化，因为<ul>
<li>内部类引用外部类，会连同外部类一起序列化</li>
<li>不同的java编译器实现针对内部类的实现有所差别，这些差别可能导致序列化后不兼容，还可能导致serialVersionUID冲突</li>
<li>内部类是没有无参构造函数的（它有一个默认参数，就是外部类的引用），不能实现Externalizable</li>
</ul>
</li>
</ol>
<h2 id="Java序列化原理"><a href="#Java序列化原理" class="headerlink" title="Java序列化原理"></a>Java序列化原理</h2><p>了解Java序列化，回答两个问题即可：一是怎么用？二是序列化的结果是个啥？第一个问题上面已经回答了，这里回答第二个问题。</p>
<p>Java序列化结果是具有一定格式的二进制流，即协议。ObjectOutputStream和ObjectInputStream就是该协议的实现。</p>
<h3 id="序列化流协议"><a href="#序列化流协议" class="headerlink" title="序列化流协议"></a>序列化流协议</h3><p>一手资料在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html">这里</a>，仔细看的话，还挺复杂的，这里简单总结留个印象就好。</p>
<p>序列化后的流组成：</p>
<ul>
<li>魔数</li>
<li>序列化协议版本号</li>
<li>内容正文<ul>
<li>序列化的对象，包含很多种类，包括实例对象、类对象、数组、空引用、对已经在流中的序列化对应的应用<ul>
<li>起始标记，可查看ObjectStreamConstants</li>
<li>类名</li>
<li>serialVersionUID</li>
<li>类描述</li>
<li>所有字段</li>
<li>注解</li>
<li>父类描述等</li>
<li>结束标记</li>
</ul>
</li>
<li>块数据<ul>
<li>起始标记</li>
<li>真实数据</li>
<li>结束标记</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当然实际组成要复杂得多，具体查看原文档的6.4节</p>
<p><strong>为原始文档做的说明</strong></p>
<ul>
<li>New Class指的是用户自定义的类，New Object同理</li>
<li>block data，原生类型值会以块模式写入，这叫做block data，是ObjectStreamConstants.PROTOCOL_VERSION_2之后引入的。</li>
<li>所有需要用到的常量，都定义在ObjectStreamConstants中</li>
</ul>
<h3 id="序列化结果解读"><a href="#序列化结果解读" class="headerlink" title="序列化结果解读"></a>序列化结果解读</h3><p>我们将上面例子的serialVersionID转成0XFFFFFFFFFFFFFFFFL，以便区分，然后来大致解读序列化结果（为什么不详细解读？尝试过，花费太多时间，都绕晕了，最后放弃，一个字——没必要）。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211006175542457.png" alt="image-20211006175542457"></p>
<p>来个表格</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AC ED</td>
<td>魔数，ObjectStreamConstants.STREAM_MAGIC</td>
</tr>
<tr>
<td>00 05</td>
<td>版本号，ObjectStreamConstants.STREAM_VERSION</td>
</tr>
<tr>
<td>73</td>
<td>新对象</td>
</tr>
<tr>
<td>72</td>
<td>新的类型描述符</td>
</tr>
<tr>
<td>00</td>
<td>classDescFlags</td>
</tr>
<tr>
<td>23 63 6F 6D 2E 67 69 74 65 65 2E 66 6C 6F 79 64 2E 73 65 72 69 61 6C 69 7A 61 74 69 6F 6E 2E 56 69 64 65 6F</td>
<td>类名：#com.gitee.floyd.serialization.Video</td>
</tr>
<tr>
<td>FF FF FF FF FF FF FF FF</td>
<td>serialVersionID</td>
</tr>
<tr>
<td>02 00 03 4C</td>
<td>newHandle</td>
</tr>
<tr>
<td>00</td>
<td>classDescFlags</td>
</tr>
<tr>
<td>0B</td>
<td>count</td>
</tr>
<tr>
<td>64 65 73 63 72 69 70 74 69 6F 6E</td>
<td>description</td>
</tr>
<tr>
<td>4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67</td>
<td>Ljava/lang/String</td>
</tr>
<tr>
<td>。。。。。。</td>
<td>后面反正就是一堆，有兴趣自己对着规范一个一个找</td>
</tr>
</tbody></table>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>序列化流的版本控制是什么：控制的是新旧版本的类序列化的结果，让对方进行反序列化时，应该做出什么样的反应。</p>
<p>这里的主要问题是：类的演进，如何算兼容，如何算不兼容呢？</p>
<p><strong>兼容的标准</strong></p>
<ul>
<li>旧版本的类序列化后，能够被新版本的类正常反序列化，并且反序列化的结果在数据完整性上不会造成破坏</li>
<li>反之亦然</li>
</ul>
<p><strong>不兼容的演进</strong></p>
<ul>
<li>删除字段：旧版本的类在反序列化时会因为缺少对应字段的值，被设置为默认值，默认值可能对业务产生负面影响</li>
<li>非静态字段改为静态字段、给已有字段添加transient关键字：等效于删除</li>
<li>在层次结构中上下移动类：流中的数据会以错误的形式出现</li>
<li>修改字段类型：反序列化时将无法正确进行类型转换</li>
<li>更改writeObject和readObject，使其发生了重大变化：将导致反序列化失败</li>
<li>将Serializable改为Externalizable或者删除Serializable：将直接导致不可序列化</li>
<li>从非枚举改为枚举：枚举的序列化方式是不一样的</li>
</ul>
<p><strong>兼容的演进</strong></p>
<ul>
<li>增加字段：对原始类不会产生影响，在新的类中应该设定对新增字段默认值的处理</li>
<li>增加类：增加的类也能够被检测出来，新增的类将被初始化为零值</li>
<li>删除类：删除类是能够检测出来的</li>
<li>添加writeObject/readObject：新添加逻辑</li>
<li>其它。。。</li>
</ul>
<p>可以看到，这里说的兼容演进是非常主观的，是说可以在新类中做添加兼容逻辑，如果逻辑添加错误，还是可能发生不兼容的情况。上面的不兼容演进，是没有机会添加兼容逻辑了，所以才叫”不兼容“。</p>
<p><strong>serialVersionID扮演的作用</strong></p>
<p>如果我们认为新类和原始类是能够兼容的，那么他们就应该具有相同的serialVersionID；反之，如果认为不兼容，他们就应该具有不同的serialVersionID。</p>
<p>声明和维护serialVersionID是必要的</p>
<ul>
<li>serialVersionID是Java提供的强制不兼容机制，必须要有，如果我们不声明，它也会自动生成，而自动生成的可能不稳定，有隐患。</li>
<li>如果实际演进不兼容，却具有相同的serialVersionID，而当不兼容的修改项运行时并不会报错，却影响到业务逻辑（如删除字段）时，是非常危险的，及时修改serialVersionID，相当于将兼容性问题显式暴露出来。</li>
</ul>
<p><strong>现在来回答那四个问题</strong></p>
<ul>
<li><p>serialVersionID有什么用？如果没有行不行？</p>
<p>上面回答过了，忽略</p>
</li>
<li><p>不同的类具有相同的serialVersionID，会有什么影响？</p>
<p>不会有什么一项，serialVersionID只在类内部起作用，类之间互不干扰。</p>
</li>
<li><p>同一个类的serialVersionID不同时，会有什么影响？</p>
<p>反序列化时会报错</p>
</li>
<li><p>同一个类演变多次，实际不兼容，却还有一个serialVersionID时，会有什么影响？</p>
<p>可能反序列化时候会报错，也可能不报错，从而产生bug</p>
</li>
</ul>
<h3 id="安全考量"><a href="#安全考量" class="headerlink" title="安全考量"></a>安全考量</h3><p>有时会涉及到敏感信息的序列化和反序列化，可以通过以下方式进行数据保护：</p>
<ul>
<li><p>可以通过transient忽略敏感字段</p>
</li>
<li><p>如果一个类敏感，它就不应该能够被序列化。IDEA还提供了这方面的警告，当在一个安全上下文中使用序列化时报警</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211006184408647.png" alt="image-20211006184408647"></p>
</li>
<li><p>如果实在要序列化，则应该在writeObject()时控制它，在readObject()时候验证它</p>
</li>
</ul>
<blockquote>
<p>PS：敏感数据，压根儿就不应该被序列化</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java自带的序列化，现在其实很少使用，学习它，一方面是作为Java程序员的职责，一方面也是消散心中的执念。</p>
<p>总体来看，我们要关注几个方面</p>
<ul>
<li>Java序列化的使用方式，不只是Serializable那么简单</li>
<li>serialVersionID的正确理解</li>
<li>序列化流协议，可以了解一下，我们要知道一个对象被序列化后长什么样子</li>
</ul>
<p>同时也可以看出它的缺点</p>
<ul>
<li>不能跨平台，自己定义的二进制协议，其它语言不能使用，除非人家实现这个协议，不过别人也没必要去实现这个协议吧</li>
<li>实现中大量使用反射，效率可能会比较低</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html">Java序列化规范</a></p>
</li>
<li><p>ObjectOutputStream、ObjectInputStream源码</p>
</li>
<li><p>一些网络文档</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86-she-ji-mo-shi--li-lun-bu-fen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86-she-ji-mo-shi--li-lun-bu-fen/" class="post-title-link" itemprop="url">设计模式 - 理论部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-04 18:15:32" itemprop="dateCreated datePublished" datetime="2021-10-04T18:15:32+08:00">2021-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这是系列文章</p>
<ul>
<li>设计模式 - 理论（本文）</li>
<li>设计模式 - JDK</li>
<li>设计模式 - Spring</li>
</ul>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86-she-ji-mo-shi--li-lun-bu-fen/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/#%20%E7%90%86%E8%A7%A3UUID%EF%BC%88%E4%BB%AC%EF%BC%89-li-jie-uuid-men-/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="#%20%E7%90%86%E8%A7%A3UUID%EF%BC%88%E4%BB%AC%EF%BC%89-li-jie-uuid-men-/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-30 16:43:00" itemprop="dateCreated datePublished" datetime="2021-09-30T16:43:00+08:00">2021-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">后端 | 算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>UUID，Universal Unique Identifier，全局唯一标识符。也叫做GUID，Global Unique Identifier。</p>
<p>概念都了解，全局唯一嘛，但怎么实现的？多大概率重复？JDK的UUID和PostgreSQL的UUID一样吗？带着这些问题，我们从RFC，到JDK源码、PG手册，一点点看。</p>
<p>本文包含以下内容：</p>
<ul>
<li>UUID实现原理</li>
<li>自己实现一个UUID</li>
<li>JDK的实现方式</li>
<li>PG的实现方式</li>
<li>其它全局唯一ID</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>老样子，要想了解一项基础技术，最好的方式是阅读一手资料。于UUID，它是<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/pdfrfc/rfc4122.txt.pdf">RFC4122</a>。</p>
<p>这一节，更莫如说是对RFC的总结，毕竟规范这东西，写得太啰嗦了，全文字不说，还没有示意图。</p>
<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul>
<li>长度128个bit位。一般通过16位十六进制字符表示，如：4cc9de16-414b-4f68-9b7e-6feeb8f629b0</li>
<li>不需要中心管理，具有跨越时间和空间的唯一性</li>
<li>按照本标准中的算法，支持每台机器每秒高达1000万次高分配速率</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>理解UUID有两个重点：一是理解其组成部分；二是理解各版本对各部分的填充方式。我们先看最重要的——组成部分。</p>
<p>为了较为形象地展示，我画了张图。第一行是结果，第二行是十六进制说明，第三行是二进制说明。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210930084244949.png" alt="image-20210930084244949"></p>
<ul>
<li>time-low：时间戳低位，占用32个bit</li>
<li>time-mid：时间戳中位，占用16个bit</li>
<li>time-high-and-version：时间戳高位+版本号，前者占12个bit，后者占4个bit，注意区分版本号是在前的</li>
<li>clock-seq-high-and-reserved：时钟序列高位+预留位。前者占6个bit，后者占2个bit，也注意他们的前后顺序</li>
<li>clock-seq-low：时间序列低位，占8个bit</li>
<li>node：节点，占用48个bit</li>
</ul>
<p>引出新概念，time、clock-seq、node</p>
<ul>
<li>time：即时间戳</li>
<li>clock-seq：当时间戳或node重复时，使用clock-seq作为附加保证唯一性</li>
<li>node：机器的节点，一般是机器的MAC地址</li>
</ul>
<h3 id="区分版本"><a href="#区分版本" class="headerlink" title="区分版本"></a>区分版本</h3><p>注意到上面说组成时，有一个version字段。UUID是有多个版本的，目前总计5个。</p>
<p>版本规定了各字段的填充方式，版本2比较特殊这里忽略，其它版本如下</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>Timestamp</th>
<th>Clock sequence</th>
<th>node</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>从UTC时间1582-10-15 00:00:00起，100ns的个数</td>
<td>第一个clock sequence应该是随机产生的<br />如果知道本机上一次生成UUID的clock sequence，则此次只需要在其基础上加一<br /> 如果不知道，该字段需要设置成一个随机数</td>
<td>MAC地址 如果没有，则使用随机数</td>
</tr>
<tr>
<td>3</td>
<td>命名空间+名称的MD5只的一部分</td>
<td>命名空间+名称的MD5只的一部分</td>
<td>命名空间+名称的MD5只的一部分</td>
</tr>
<tr>
<td>4</td>
<td>随机数的一部分</td>
<td>随机数的一部分</td>
<td>随机数的一部分</td>
</tr>
<tr>
<td>5</td>
<td>命名空间+名称的SHA1只的一部分</td>
<td>命名空间+名称的SHA1只的一部分</td>
<td>命名空间+名称的SHA1只的一部分</td>
</tr>
</tbody></table>
<p>可以看到，所谓的时间戳、时钟序列、node这些字段，仅对版本1有效，其它版本填充进去的值并无逻辑意义。</p>
<h3 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h3><ul>
<li>对Version 1：它通过MAC地址保证空间唯一性，时间戳+序列号保证时间唯一性</li>
<li>对Version 2：和Version 1类似，只不过会把时间戳的前4位置换为POSIX的UID或GID</li>
<li>对Version 3、5：它纯依赖于名字保证唯一性，这就需要一个规整的命名系统：命名空间+名称</li>
<li>对Version 4：它纯通过随机数保证唯一性，此时一个高质量的随机数发生器就显得尤为重要</li>
</ul>
<h3 id="Version-1生成逻辑"><a href="#Version-1生成逻辑" class="headerlink" title="Version 1生成逻辑"></a>Version 1生成逻辑</h3><ol>
<li><p>获取一个系统级别的全局时钟</p>
</li>
<li><p>从一个系统全局共享的的存储位置，读取上一个UUID的状态：时间戳、始终序列、node等</p>
</li>
<li><p>获取当前时间戳：从UTC时间1582-10-15 00:00:00起，100ns的个数</p>
</li>
<li><p>获取nodeid，即MAC地址</p>
</li>
<li><p>如果上一个UUID状态不稳定（不存在、nodeid与新获取的nodeid不一样），生成一个随机clock value</p>
</li>
<li><p>如果状态存在，但时间戳比当前时间戳还晚，则clock sequence自增</p>
</li>
<li><p>将新的状态保存</p>
</li>
<li><p>将上面的三个部分按照格式组成UUID</p>
</li>
</ol>
<p><strong>有一个bug</strong></p>
<p>MAC地址直接放在nodeid中，就是一个bug，这会暴露用户的MAC地址：梅丽莎病毒制作者的位置就是这么暴露的</p>
<h3 id="Version-4生成逻辑"><a href="#Version-4生成逻辑" class="headerlink" title="Version 4生成逻辑"></a>Version 4生成逻辑</h3><ol>
<li>获取一个随机数</li>
<li>将预留位、版本位之外的位，使用该随机数填充，填充位对应方式，参考RFC</li>
</ol>
<h3 id="Version-3、5生成逻辑"><a href="#Version-3、5生成逻辑" class="headerlink" title="Version 3、5生成逻辑"></a>Version 3、5生成逻辑</h3><ol>
<li>命名空间+名字组成字符串，使用MD5或者SHA1计算摘要</li>
<li>将预留位、版本位之外的位，使用该摘要填充，填充位对应方式，参考RFC</li>
</ol>
<h3 id="为什么时间戳从1582-10-15开始"><a href="#为什么时间戳从1582-10-15开始" class="headerlink" title="为什么时间戳从1582-10-15开始"></a>为什么时间戳从1582-10-15开始</h3><p>这是公历改革到基督教日历的日期，说来话长，我也没啥兴趣去详细了解，如果需要，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/300868434">看看知乎吧</a></p>
<h2 id="自己写一个UUID吧"><a href="#自己写一个UUID吧" class="headerlink" title="自己写一个UUID吧"></a>自己写一个UUID吧</h2><p>尝试着实现了一下抽象定义和基于时间戳的版本，发现主要有几个难点：kotlin的进制转换、二进制操作等。</p>
<p>这是一个不能实际使用的UUID版本（实现它也不是本文的目的），仅作演示。</p>
<p>先是UUID的抽象定义，我们使用两个Long作为底层bit持有对象，定义各字段的set方法，主要是二进制操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UUID</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_LOW_MASK = (<span class="number">0xFFFFFFFFL</span>).shl(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_MID_MASK = (<span class="number">0xFFFFFFFFL</span>).shl(<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VERSION_MASK = (<span class="number">0xFFL</span>).shl(<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_HIGH_MASK = <span class="number">0xFFFFFFL</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> RESERVED_MASK = (<span class="number">0xFL</span>).shl(<span class="number">62</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> CLOCK_SEQ_HIGH_MASK = (<span class="number">0xFFFL</span>).shl(<span class="number">56</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> CLOCK_SEQ_LOW_MASK = (<span class="number">0xFFFFL</span>).shl(<span class="number">48</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NODE_MASK = <span class="number">0xFFFFFFFFFFFFL</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">timeBasedUUID</span><span class="params">()</span></span>: UUID = UUIDVersion1()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高有效位们：靠右</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mostSignificantBits = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低有效位：靠左</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leastSignificantBits = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeLow</span><span class="params">(timeLow: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeLow.toLong().shl(<span class="number">32</span>).and(TIME_LOW_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeMid</span><span class="params">(timeMid: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeMid.toLong().shl(<span class="number">16</span>).and(TIME_MID_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setVersion</span><span class="params">(version: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(version.toLong().shl(<span class="number">12</span>).and(VERSION_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeHigh</span><span class="params">(timeHigh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeHigh.toLong().and(TIME_HIGH_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setReserved</span><span class="params">(reserved: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(reserved.toLong().shl(<span class="number">62</span>).and(RESERVED_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClockSeqHigh</span><span class="params">(clockSeqHigh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(clockSeqHigh.toLong().shl(<span class="number">56</span>).and(CLOCK_SEQ_HIGH_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClockSeqLow</span><span class="params">(clockSeqLow: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(clockSeqLow.toLong().shl(<span class="number">48</span>).and(CLOCK_SEQ_LOW_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setNode</span><span class="params">(nodeId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(nodeId.toLong().and(NODE_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> lsbString = leastSignificantBits.toHexString()</span><br><span class="line">        <span class="keyword">val</span> msgString = mostSignificantBits.toHexString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> seg1 = lsbString.substring(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> seg2 = lsbString.substring(<span class="number">8</span>, <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">val</span> seg3 = lsbString.substring(<span class="number">12</span>, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">val</span> seg4 = msgString.substring(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> seg5 = msgString.substring(<span class="number">4</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$seg1</span>-<span class="variable">$seg2</span>-<span class="variable">$seg3</span>-<span class="variable">$seg4</span>-<span class="variable">$seg5</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一个粗糙的实现类，实现Version 1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UUIDVersion1</span> : <span class="type">UUID</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 计算time</span></span><br><span class="line">        <span class="keyword">val</span> start = LocalDateTime.of(<span class="number">1582</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> end = LocalDateTime.now(ZoneId.of(<span class="string">&quot;UTC&quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> duration = Duration.between(start, end)</span><br><span class="line">        <span class="keyword">val</span> time = duration.toMillis() * <span class="number">10</span></span><br><span class="line">        <span class="comment">// 计算clock seq</span></span><br><span class="line">        <span class="keyword">val</span> clock = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 获取node，我们用随机数替换</span></span><br><span class="line">        <span class="keyword">val</span> node = Random.nextInt()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setTimeLow(time.toInt())</span><br><span class="line">        <span class="keyword">this</span>.setTimeMid(time.shr(<span class="number">32</span>).toInt())</span><br><span class="line">        <span class="keyword">this</span>.setTimeHigh(time.shr(<span class="number">48</span>).toInt())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setClockSeqHigh(clock.shr(<span class="number">8</span>))</span><br><span class="line">        <span class="keyword">this</span>.setClockSeqLow(clock)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setNode(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setVersion(<span class="number">0b001</span>)</span><br><span class="line">        <span class="keyword">this</span>.setReserved(<span class="number">0b10</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以将生成的UUID转换为JDK的UUID进行验证。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uuidString = UUID.timeBasedUUID().toString()</span><br><span class="line">    println(uuidString)</span><br><span class="line">    <span class="keyword">val</span> uuid = java.util.UUID.fromString(uuidString)</span><br><span class="line">    println(uuid.version())</span><br><span class="line">    println(uuid.variant())</span><br><span class="line">    println(uuid.timestamp())</span><br><span class="line">    println(uuid.clockSequence())</span><br><span class="line">    println(uuid.node())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够得到如下输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">51d8c022-7dfc-1000-8000-ffffd963e9ed</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">138522658390050</span><br><span class="line">0</span><br><span class="line">281474328947181</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仔细想想，这个时间戳也不一定要从1580年开始，也可以换成自定义的时间戳，完全看需求。</p>
</blockquote>
<h2 id="JDK-UUID"><a href="#JDK-UUID" class="headerlink" title="JDK UUID"></a>JDK UUID</h2><p>JDK只提供Version 3和Version 4两种UUID，实现上也超级简单。</p>
<p>类似地，它也用两个long来组成128位，构建时直接分配位即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The most significant 64 bits of this UUID.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @serial</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mostSigBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The least significant 64 bits of this UUID.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @serial</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> leastSigBits;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UUID</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> msb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> lsb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">assert</span> data.length == <span class="number">16</span> : <span class="string">&quot;data must be 16 bytes in length&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    msb = (msb &lt;&lt; <span class="number">8</span>) | (data[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    lsb = (lsb &lt;&lt; <span class="number">8</span>) | (data[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">this</span>.mostSigBits = msb;</span><br><span class="line">  <span class="keyword">this</span>.leastSigBits = lsb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Version-4"><a href="#Version-4" class="headerlink" title="Version 4"></a>Version 4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">randomUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SecureRandom ng = Holder.numberGenerator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] randomBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">  ng.nextBytes(randomBytes);</span><br><span class="line">  randomBytes[<span class="number">6</span>]  &amp;= <span class="number">0x0f</span>;  <span class="comment">/* clear version        */</span></span><br><span class="line">  randomBytes[<span class="number">6</span>]  |= <span class="number">0x40</span>;  <span class="comment">/* set to version 4     */</span></span><br><span class="line">  randomBytes[<span class="number">8</span>]  &amp;= <span class="number">0x3f</span>;  <span class="comment">/* clear variant        */</span></span><br><span class="line">  randomBytes[<span class="number">8</span>]  |= <span class="number">0x80</span>;  <span class="comment">/* set to IETF variant  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UUID(randomBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，重点其实在Holder.numberGenerator，它的随机性决定了UUID的重复概率。而其实现SecureRandom，则涉及到另一个知识点——随机数，我们这里挖个坑，后面再探究随机数生成器到底有多随机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> SecureRandom numberGenerator = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static UUID nameUUIDFromBytes(byte[] name) &#123;</span><br><span class="line">  MessageDigest md;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException nsae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> new InternalError(<span class="string">&quot;MD5 not supported&quot;</span>, nsae);</span><br><span class="line">  &#125;</span><br><span class="line">  byte[] md5Bytes = md.digest(name);</span><br><span class="line">  md5Bytes[<span class="number">6</span>]  &amp;= <span class="number">0x0f</span>;  <span class="comment">/* clear version        */</span></span><br><span class="line">  md5Bytes[<span class="number">6</span>]  |= <span class="number">0x30</span>;  <span class="comment">/* set to version 3     */</span></span><br><span class="line">  md5Bytes[<span class="number">8</span>]  &amp;= <span class="number">0x3f</span>;  <span class="comment">/* clear variant        */</span></span><br><span class="line">  md5Bytes[<span class="number">8</span>]  |= <span class="number">0x80</span>;  <span class="comment">/* set to IETF variant  */</span></span><br><span class="line">  <span class="keyword">return</span> new UUID(md5Bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个更简单，做一下MD5，修改相应的bit填入即可，它的唯一性就完全依赖于传入的name了。</p>
<h2 id="PostgreSQL的UUID"><a href="#PostgreSQL的UUID" class="headerlink" title="PostgreSQL的UUID"></a>PostgreSQL的UUID</h2><p>根据<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/functions-uuid.html">手册</a>描述，PG的UUID也是Version 4，即基于随机数生成。</p>
<h2 id="UUID重复的概率"><a href="#UUID重复的概率" class="headerlink" title="UUID重复的概率"></a>UUID重复的概率</h2><p>就是个好奇，我们能够大致算一算，UUID重复的概率有多大，其实可以归结如下。</p>
<ul>
<li><p>对基于时间戳的情况，node稳定时，多个节点不可能重复，而单个节点，由于有记录上一个UUID的状态，因此也不会重复。只不过有生成速率限制，以RFC的方式来说，每个节点每100ns，最多能够生成2^14=16384个UUID，换算成秒，即每秒1.6亿个。</p>
</li>
<li><p>基于随机数的情况，取决于随机数生成器的质量</p>
</li>
<li><p>基于名字的情况，取决于命名系统，这种情况UUID只是命名系统的延伸，应该说不会考虑UUID重复的情况，而是命名系统本身的性能</p>
</li>
<li><p>128bit空间本身是否可能重复呢？用尽了就会，不过这个概率，类似流星撞地球吧。</p>
</li>
</ul>
<h2 id="其它全局唯一ID"><a href="#其它全局唯一ID" class="headerlink" title="其它全局唯一ID"></a>其它全局唯一ID</h2><p>最为大家熟知的恐怕就是雪花算法了吧，此外号段模式也算一个。</p>
<h3 id="雪花算法（SnkwFlake）"><a href="#雪花算法（SnkwFlake）" class="headerlink" title="雪花算法（SnkwFlake）"></a>雪花算法（SnkwFlake）</h3><p>了解了UUID Version 1的生成方式后，雪花算法就很容易理解，也是由时间戳-机器id-序列号组成，不同的是其只需要64个bit。且各字段可以根据实际需求调整bit的个数。雪花算法只是一种思想：将各位打散，再赋予不同的用途。UUID Version 1也是这种思想。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210930142313559.png" alt="image-20210930142313559"></p>
<p><strong>几个需要考虑的问题</strong></p>
<ul>
<li>时钟回拨问题：常见的方式是容忍小范围回拨，即如果当前时间戳比上一个生成的时间戳早，且在一定范围内，则依旧使用上一次的时间戳。这算一种校准方式，即回拨的这个时间差会被算到上一个时间戳的序列中，随着时间的推移，时间回拨问题会被抹平，但这段期间的生成效率会降低。</li>
<li>机器ID的生成方式：机器ID必须是稳定的，常见的解决方式是融合MAC地址。</li>
</ul>
<p><strong>雪花算法和UUID差别</strong></p>
<p>雪花算法得到的id依旧是64位，就是一个long，且时间戳在高位，是有序递增的。有序性，往往很重要。</p>
<p><strong>一些雪花算法的实现</strong></p>
<ul>
<li><p>百度UidGenerator</p>
<p>它解决时钟回拨的方式，是不容忍任何回拨，直接报错</p>
</li>
<li><p>美团Leaf</p>
<p>可选基于雪花算法或基于号段模式两种方案。其中使用雪花算法时，依赖于Zookeeper来分配WorkerID</p>
<p>它解决时钟回拨问题，和上面我们说的类似</p>
</li>
</ul>
<h3 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h3><p>这并不是什么算法，而是一种数据库自增ID的用法，一次取一批ID，用完了再取，保证了唯一性，降低了数据库的访问频率。</p>
<h2 id="分布式ID的选择"><a href="#分布式ID的选择" class="headerlink" title="分布式ID的选择"></a>分布式ID的选择</h2><p>你看，我们已经了解了最重要的全局唯一ID生成方式，那就可以讨论这个问题：分布式ID应该用哪种呢？</p>
<p>UUID优点在于生成简单，唯一性好，几乎所有语言都有标准实现。缺点在于长度过长、不具有单调性，且无意义。</p>
<p>雪花算法优点在于具有单调性，长度适中。缺点在于需要自己实现或引入第三方库。（一说雪花算法缺点在于依赖时间，但要在跨时间上保证唯一性，除了依赖时间，就是依赖随机数，所以我认为也算不上缺点，且时间回拨不是已经有解决方式了嘛）</p>
<p>如果ID需要存入数据库，由于UUID的无序性，可能会使得索引重建花费较长时间，当然使用<strong>雪花算法比较好</strong>。</p>
<h3 id="每记选择UUID作为key，合理吗？"><a href="#每记选择UUID作为key，合理吗？" class="headerlink" title="每记选择UUID作为key，合理吗？"></a>每记选择UUID作为key，合理吗？</h3><p>作为一个离线客户端软件，我们面临以下问题</p>
<ul>
<li>客户端环境千奇百怪，多平台（PC、网页、安卓、IOS等），多版本，总之，就很难信任客户端环境</li>
<li>离线时也要能正常使用</li>
</ul>
<p>如果使用雪花算法，会有几个问题</p>
<ul>
<li>首先，工作机器ID的确定，需要考虑的情况就会比较多，即生成算法需要调试。客户端的时间回拨，那可不就是修正就能够完事的。</li>
<li>其次，即使有序性有了，但多个设备上传的顺序依旧无法保证，受网络、环境影响较大，依旧会造成索引重建时候较多数据的移动</li>
</ul>
<p>如果使用UUID，其实就只有一个问题</p>
<ul>
<li><p>数据库存储的效率：索引重建。如果是聚簇索引，索引重建时移动的数据会很多，这对MySQL的innodb这类引擎来说可能是灾难。但是PgstgreSQL并非以B+树存储数据，所以性能损失并非想象的那么严重。具体如何，待后面详细研究一波PG的各种原理（完蛋，又挖了一个坑）</p>
<p>且，即使是MySQL，依然可以解决：主键设为单调自增的number，来自客户端的UUID仅作为普通字段，在该字段创建索引，会好很多。</p>
</li>
</ul>
<p>综上所述，使用UUID对客户端更方便，在服务端性能也算可以接受，所以说<strong>是合理的</strong>。</p>
<p>作为佐证，我抓了一个印象笔记下类每记产品”印象清单“，它就更加直白了，id字段名为”taskGuid“，值就是UUID。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;syncDataObject&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;tasks&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;state&quot;</span>:<span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;ruleId&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;description&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;clientUpdatedTime&quot;</span>:<span class="number">1632988316566</span>,</span><br><span class="line">          <span class="attr">&quot;sortIndex&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;dueTime&quot;</span>:<span class="number">1632988311635</span>,</span><br><span class="line">          <span class="attr">&quot;operation&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;æµè¯&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;finishedTime&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">          <span class="attr">&quot;taskGuid&quot;</span>:<span class="string">&quot;a1e4836c-4d59-409d-bf00-864d6d31cba0&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;createTime&quot;</span>:<span class="number">1632988316566</span>,</span><br><span class="line">          <span class="attr">&quot;taskListId&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;reminderTime&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">          <span class="attr">&quot;reminderType&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;taskRelatedNote&quot;</span>:[</span><br><span class="line">            </span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>:[</span><br><span class="line">        </span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;taskLists&quot;</span>:[</span><br><span class="line">        </span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h2><p>这篇UUID的文章写的不错，如果结合起来看，可以增进理解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/14343086.html#namespace-name-based-md5%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">冷饭新炒：理解JDK中UUID的底层实现</a></p>
<p>雪花算法呢，这篇文章看起来还行：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/402822041">SnowFlake</a></p>
<p>美团的Leaf，美团技术团队博客有进行说明：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>研究UUID的出发点，只是其RFC很短，仅三十多页，有效内容不到二十页。过程中却有几点意外之喜：</p>
<ul>
<li>顺着UUID的实现原理，了解到JDK的实现方式，自此，UUID于我，成了白盒；</li>
<li>能够体会JDK不提供Version1的原因（它太依赖具体系统，而语言级别的实现，一定是要所有情况通用的，显然Version 1的通用实现，不大好办）；</li>
<li>思路发散到分布式ID，详细了解了雪花算法，它和Version 1是如此接近，却只因为将node和seq换了个位置就能够单调递增，如此相似，结果却如此不同；</li>
<li>离线客户端用SnowFlake如何？它们看起来是大型分布式系统，实则与我们后端常说的分布式系统很不一样，这其中最大的不同是客户端环境不可控。</li>
<li>同时，还挖了两个坑：深入研究随机数、深入研究PostgreSQL</li>
</ul>
<p>本着输出驱动输入的方法完成本文，预期一两天，实则因思路发散花了更多时间，结果是令人满意的，因为它让我对技术，又少了一个模糊地带。</p>
<p>也应验了那句话：持续不断地学习，一定会给你带来惊喜。关键词是：<strong>持续不断</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/Spring%E6%89%AB%E7%9B%B2%E2%80%94%E2%80%94Spring%20Data%20JPA-spring-sao-mang-springdatajpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Spring%E6%89%AB%E7%9B%B2%E2%80%94%E2%80%94Spring%20Data%20JPA-spring-sao-mang-springdatajpa/" class="post-title-link" itemprop="url">Spring扫盲——Spring Data JPA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-28 16:36:39" itemprop="dateCreated datePublished" datetime="2021-09-28T16:36:39+08:00">2021-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Spring | 后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>震惊，查询SQL的创建居然是根据Repository的方法名来生成的。</p>
<p>对于JPA，我们只需要掌握几点。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>配置开启JPA，提供EntityBeanFactory，提供repositories的配置包路径</li>
<li>定义Entity。不用自己写，使用IEAD的插件可以做到</li>
<li>定义Repository，提供灵活的定义方式<ul>
<li>定义查询方法，根据方法名来生成SQL的。这个叫做NamedQuery</li>
<li>自定义查询SQL，使用Query注解</li>
</ul>
</li>
<li>在需要使用的地方注入Repository</li>
</ul>
<h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><ul>
<li><p>Repository的查询方法有点意思，相当于直接吧SQL写成了查询方法</p>
</li>
<li><p>支持Querydsl，一种Java语言的SQL DSL，怎么说呢，如果代码过长，写起来还是不大方便吧</p>
</li>
<li><p>支持将Repository中查询方法的返回类型指定为非Entity的类，比如我们DTO</p>
</li>
<li><p>支持存储过程</p>
</li>
<li><p>如果为IDEA添加了JPA支持，在写Repository时会有提示呢，看起来还挺高级的</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E6%88%AA%E5%B1%8F2021-09-28%20%E4%B8%8B%E5%8D%884.34.31_1632818107252.png" alt="截屏20210928 下午4.34.31.png"></p>
</li>
</ul>
<h3 id="web支持"><a href="#web支持" class="headerlink" title="web支持"></a>web支持</h3><ul>
<li>通过添加EnableSpringDataWebSupport注解，能够提供支持<ul>
<li>定义的Entity能够被web解析和编码到消息体中</li>
<li>能够正常解析Sort、Pageable等参数</li>
<li>能够解析Point、Distance等类，根据具体使用的Spring Data模块而言。如使用Spring Data Redis，可能就有Distance</li>
<li>甚至能够直接把url中的查询参数转换为Querydsl的Predicte对象，即查询条件</li>
</ul>
</li>
</ul>
<h2 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h2><p>优点</p>
<ol>
<li>IDEA支持好</li>
<li>使用简单，只需要配置IDEA生成Entity，然后配置Repository即可</li>
<li>对于创建规范的表格，简单的查询需求，用起来非常不错</li>
<li>一般不让我们直接写裸SQL，而是类SQL，屏蔽了数据库差异。</li>
</ol>
<p>缺点</p>
<ol>
<li>查询效率优化比较麻烦，JPA的设计思想，就是不要让你去管SQL的事情，而是专注业务</li>
<li>但正是这样，有时候生成的SQL并不是我们想要的</li>
<li>SQL能力不如MyBatis强，比如动态SQL能力。举个例子，JPA中，要做in查询，in中的个数是动态，这样怎么办呢？</li>
</ol>
<h2 id="JPA对比MyBatis"><a href="#JPA对比MyBatis" class="headerlink" title="JPA对比MyBatis"></a>JPA对比MyBatis</h2><p>下面这个回答比较中肯。两句话概括</p>
<ul>
<li>JPA面向对象，让用户不要去管SQL的事情。使用友好，但SQL优化不大行。</li>
<li>MyBatis面向SQL，可以直接写SQL。但跨数据源能力不大行。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/348496459/answer/842120407">SpringData JPA也能写sql，为什么还要用mybatis?</a></p>
<p>如果公司自己做业务，看重性能和优化，用MyBatis比较好，而且现在MyBatis有MybatisPlus，也支持Active Record，一定程度上算是集合了JPA和MyBatis的优势。</p>
<p>但如果公司的卖代码的，跨数据库这一点就很重要，使用JPA就很有必要。</p>
<h2 id="个人认为"><a href="#个人认为" class="headerlink" title="个人认为"></a>个人认为</h2><p>我个人的看法，首先，在代码中写复杂SQL这件事，必须PASS，这在呼啦亲子中已经实践过了，是不大可行的。JOOQ的DSL能力尚且不行，那Querydsl的SQL能力肯定是更加不能接受的。</p>
<p>其次，如果使用PG，其中有很多非典型SQL的语法，肯定是要写裸SQL的。但是JPA写裸SQL的能力，肯定是不如MyBatis的。</p>
<p>我也很喜欢JPA，但如果在一个长期维护的项目中使用JPA，很可能出现开始时写得很开心，到后面项目中充斥着大量不符合JPA设计哲学的代码。</p>
<p>所以我会选择MyBatis。</p>
<p>但是。。。如果是自己的小项目，我还是愿意尝试一下JPA。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/%E8%81%8A%E4%B8%80%E8%81%8AJava%E7%9A%84%E7%BC%93%E5%AD%98-liao-yi-liao-java-de-huan-cun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%81%8A%E4%B8%80%E8%81%8AJava%E7%9A%84%E7%BC%93%E5%AD%98-liao-yi-liao-java-de-huan-cun/" class="post-title-link" itemprop="url">聊一聊Java的缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-27 20:43:49 / 修改时间：20:56:20" itemprop="dateCreated datePublished" datetime="2021-09-27T20:43:49+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文，我们主要聊一下Java中缓存的使用，几个点</p>
<ul>
<li>Java对缓存的抽象——JSR107</li>
<li>Spring对缓存的抽象——Spring Cache</li>
<li>Redis如何集成到Spring中——作为Spring Cache的实现、直接使用RedisCache、使用RedisTemplate</li>
</ul>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E8%81%8A%E4%B8%80%E8%81%8AJava%E7%9A%84%E7%BC%93%E5%AD%98-liao-yi-liao-java-de-huan-cun/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/Spring%20STOMP%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E5%8C%BA%E5%88%86%E5%AE%A2%E6%88%B7%E7%AB%AF-springstomp-fa-song-xiao-xi-shi-qu-fen-ke-hu-duan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Spring%20STOMP%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E5%8C%BA%E5%88%86%E5%AE%A2%E6%88%B7%E7%AB%AF-springstomp-fa-song-xiao-xi-shi-qu-fen-ke-hu-duan/" class="post-title-link" itemprop="url">Spring STOMP发送消息时区分客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-16 18:51:53" itemprop="dateCreated datePublished" datetime="2021-09-16T18:51:53+08:00">2021-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现有使用Spring WebSocket库搭建的STOMP通知中心，使用Spring自带功能，能够区分到用户，向来自同一用户的多个连接（会话）广播数据。</p>
<p>这正是我们的使用场景：当用户调用服务端指定接口时，服务端向该用户所在的所有用户发送通知。</p>
<p>现有的配置，在WebSocket握手阶段验证TOKEN，解析成用户ID，存入WebSession；在接口访问时带上TOKEN，再通过SimpMessagingTemplate.convertAndSendToUser()向该用户进行广播。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li><p>X-GD-UID：客户端提供设备识别码的请求头名</p>
</li>
<li><p>X-GD-TOKEN：客户端提供TOKEN的请求头名</p>
</li>
<li><p>uid：设备识别码在服务端内部的流转名</p>
</li>
<li><p>deviceId：设备识别码在服务端内部的流转名</p>
</li>
<li><p>user：用户在服务端内部的流转名</p>
</li>
<li><p>WebSocketSession：WebSocket的Session，一般来说，一个WebSocket连接对应一个Session。该session对应的sessionId，单个服务器</p>
</li>
<li><p>STOMP Session：STOMP的Session，和WebSession等价。源码中，将来自WebSocket的消息包装成STOMP消息，可以直接看到二者的设置关系：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromClient</span><span class="params">(WebSocketSession session,...)</span> </span>&#123;</span><br><span class="line">	... ...</span><br><span class="line">	headerAccessor.setSessionId(session.getId());</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="优化需求"><a href="#优化需求" class="headerlink" title="优化需求"></a>优化需求</h2><p>按照上面的方式，对一个用户广播，会通知到所有设备，即使该设备是通知触发方。逻辑上讲，通知触发方是不应该收到通知的。这正是我们需要实现的需求。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="设备识别"><a href="#设备识别" class="headerlink" title="设备识别"></a>设备识别</h3><p>当前只能通过TOKEN识别用户。但没有识别设备的方式，我们可能有两种</p>
<ul>
<li>IP地址：不可取。网络环境复杂，经过层层转发，我们不一定能保证获取到稳定的IP地址；即时能够获取到，因为SNAT的存在，对处在同一局域网下的多台设备，也不一定能够区分。</li>
<li>设备识别码：取客户端设备的唯一识别码，这是最保险的方法。但根据“客户端不可信原则”。userId+设备识别码才是理论上最靠谱的方式。</li>
</ul>
<h3 id="放在哪"><a href="#放在哪" class="headerlink" title="放在哪"></a>放在哪</h3><p>设备识别码这个参数，比较中性，可以在其他业务上用，因此放在头部比较合适，暂定X-GD-UID。客户端所有请求，都带上该头部。</p>
<h3 id="服务端方案"><a href="#服务端方案" class="headerlink" title="服务端方案"></a>服务端方案</h3><ol>
<li>WebSocket握手时，解析user和uid，放入WebSocketSession。该WebSocketSession会在后面的每次交互中带上此两个参数。</li>
<li>在STOMP进行CONNECT时，我们能够在入方向的拦截器中获取到上一步存放的user、uid，以及新建的STOMP session，我们将他们缓存起来，以便后面使用。</li>
<li>发送STOMP通知时，指定要忽略哪个uid，我们能够在出方向上的拦截器中拦截该消息，如果发现当前通知即将发送的目标设备和指定的uid匹配，则拦截掉该通知。</li>
<li>连接断开时，清除缓存</li>
</ol>
<h3 id="缓存放哪"><a href="#缓存放哪" class="headerlink" title="缓存放哪"></a>缓存放哪</h3><p>三个地方备选，综合来看，放在Redis是比较好的选择。不过需要小心的是Redis的重启</p>
<ul>
<li>本地：多实例时会出问题</li>
<li>Redis：Redis数据库本身的声明周期和项目不一致，有可能在项目运行到一半时关闭</li>
<li>数据库：生命周期大于项目，是理论上最安全的位置，但访问速度可能会比较慢</li>
</ul>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>全流程配置忽略，这里只说关键部分的代码。我们将与当前功能相关的逻辑都放在一个类中，如下。本节其它小节将会直接引用该类中的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> redisTemplate: StringRedisTemplate) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeSession</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">        SimpMessageHeaderAccessor.getSessionId(message.headers)?.let &#123;</span><br><span class="line">            redisTemplate.delete(it.toRedisKey())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deviceBindInterceptor</span><span class="params">()</span></span> = <span class="keyword">object</span> : ChannelInterceptor &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preSend</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;, channel: <span class="type">MessageChannel</span>)</span></span>: Message&lt;*&gt; &#123;</span><br><span class="line">            <span class="comment">// 连接时记录deviceId和当前session的关系</span></span><br><span class="line">            <span class="keyword">val</span> accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (accessor != <span class="literal">null</span> &amp;&amp; StompCommand.CONNECT == accessor.command) &#123;</span><br><span class="line">                <span class="keyword">val</span> user = accessor.user ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> deviceId = accessor.sessionAttributes?.<span class="keyword">get</span>(DEVICE_ID_ATTRIBUTE)?.toString() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> sessionId = accessor.sessionId!!</span><br><span class="line">                redisTemplate.opsForValue().<span class="keyword">set</span>(sessionId.toRedisKey(), genDeviceValue(user.name, deviceId))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deviceIgnoreInterceptor</span><span class="params">()</span></span> = <span class="keyword">object</span> : ChannelInterceptor &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preSend</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;, channel: <span class="type">MessageChannel</span>)</span></span>: Message&lt;*&gt;? &#123;</span><br><span class="line">            <span class="comment">// 发送时滤除指定deviceId的sessionID</span></span><br><span class="line">            <span class="keyword">val</span> accessor = MessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (accessor != <span class="literal">null</span> &amp;&amp; SimpMessageType.MESSAGE == accessor.messageType) &#123;</span><br><span class="line">                <span class="keyword">val</span> username = accessor.removeNativeHeader(USER_ATTRIBUTE)?.singleOrNull() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> ignoreDeviceId = accessor.removeNativeHeader(DEVICE_ID_ATTRIBUTE)?.singleOrNull() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> deviceValueOfMessage = redisTemplate.opsForValue().<span class="keyword">get</span>(accessor.sessionId!!.toRedisKey()) ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">if</span> (deviceValueOfMessage == genDeviceValue(username, ignoreDeviceId)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">genDeviceValue</span><span class="params">(username: <span class="type">String</span>, deviceId: <span class="type">String</span>)</span></span>: String = <span class="string">&quot;<span class="subst">$&#123;username&#125;</span>-<span class="variable">$deviceId</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">toRedisKey</span><span class="params">()</span></span> = <span class="string">&quot;MYLOGS_WEBSOCKET_DEVICE_<span class="variable">$this</span>&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UID解析"><a href="#UID解析" class="headerlink" title="UID解析"></a>UID解析</h3><p>握手拦截器中解析UID</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> class <span class="title">AuthHandshakeInterceptor</span><span class="params">(val objectMapper: ObjectMapper)</span> : HandshakeInterceptor </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">beforeHandshake</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        request: ServerHttpRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">        response: ServerHttpResponse,</span></span></span><br><span class="line"><span class="params"><span class="function">        wsHandler: WebSocketHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">        attributes: MutableMap&lt;String, Any&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span>: Boolean </span>&#123;</span><br><span class="line">        val user = request.parseUser(objectMapper)</span><br><span class="line">        val deviceId = request.parseDeviceId()</span><br><span class="line">				... ...</span><br><span class="line">        <span class="keyword">if</span> (deviceId != <span class="keyword">null</span>) attributes[DEVICE_ID_ATTRIBUTE] = deviceId</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展方法，从头部或query中取X-GD-UID</span></span><br><span class="line">fun ServerHttpRequest.parseDeviceId(): String? &#123;</span><br><span class="line">    val deviceIdInHeader = <span class="keyword">this</span>.headers[DEVICE_UID_HEADER]?.firstOrNull()</span><br><span class="line">    val deviceIdInQuery = lazy &#123; <span class="keyword">this</span>.uri.query?.split(<span class="string">&quot;&amp;&quot;</span>)?.find &#123; it.contains(DEVICE_UID_HEADER) &#125;?.split(<span class="string">&quot;=&quot;</span>)?.last() &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceIdInHeader ?: deviceIdInQuery.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UID缓存"><a href="#UID缓存" class="headerlink" title="UID缓存"></a>UID缓存</h3><p>入方向上的拦截器，取出user、uid、sessionId，放入Redis。参见DeviceHolder.deviceBindInterceptor()。</p>
<h3 id="信息拦截"><a href="#信息拦截" class="headerlink" title="信息拦截"></a>信息拦截</h3><p>出方向上的拦截器，缓存匹配，则忽略。参见DeviceHolder.deviceIgnoreInterceptor()。</p>
<h3 id="连接断开处理"><a href="#连接断开处理" class="headerlink" title="连接断开处理"></a>连接断开处理</h3><p>当STOMP连接或WebSocket连接断开时，会发送SessionDisconnectEvent事件，我们监听该事件，在连接断开时主动清理掉内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisconnectEventListener</span>(</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">val</span> <span class="title">deviceHolder</span>: <span class="title">DeviceHolder</span></span></span><br><span class="line"><span class="class">) : <span class="title">ApplicationListener</span>&lt;<span class="title">SessionDisconnectEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onApplicationEvent</span><span class="params">(event: SessionDisconnectEvent)</span> </span>&#123;</span><br><span class="line">        deviceHolder.removeSession(event.message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方"><a href="#使用方" class="headerlink" title="使用方"></a>使用方</h3><p>使用方需传入用户名、目标地址、要忽略的设备ID、要发送的消息等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SimpMessagingTemplate.<span class="title">notifyUserWithoutDevice</span><span class="params">(userId: <span class="type">Int</span>, deviceId: <span class="type">String</span>?, maxUsn: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User.fromId(userId)</span><br><span class="line">    <span class="keyword">this</span>.convertAndSendToUser(</span><br><span class="line">				<span class="comment">// 用户名</span></span><br><span class="line">        user.name,</span><br><span class="line">				<span class="comment">// 用户地址</span></span><br><span class="line">        STOMP_USER_PULL_NOTIFICATION_TOPIC,</span><br><span class="line">				<span class="comment">// 发送的消息体</span></span><br><span class="line">        PullNotify(maxUsn),</span><br><span class="line">				<span class="comment">// 附带的额外属性。很重要，正是它们携带了用户名、设备id到出方向上的拦截器</span></span><br><span class="line">        mapOf(</span><br><span class="line">            DEVICE_ID_ATTRIBUTE to deviceId,</span><br><span class="line">            USER_ATTRIBUTE to user.name</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>Spring WebSocket为我们提供的参与消息收发的方式主要有握手拦截器、握手处理器、STOMP消息入方向上的拦截器、STOMP消息出方向上的拦截器，正是利用这些特性，我们猜完成了设备识别这一需求</li>
<li>出方向的拦截器无法获取到消息所属用户，因此这里我们在用SimpMessagingTemplate发送消息时将用户放进头中，再在拦截器中取出。这种方式，并不优雅</li>
<li>单实例上的SessionId不会重复，但是多实例之间的SessionId是理论上是可能重复的，此时会存在bug。即一台实例上的session覆盖了另一台实例的缓存，造成有效缓存丢失的情况。有两个解决方案<ul>
<li>保证SessionId绝对不同</li>
<li>存储user-deviceId-sessionId三层结构，这样理论上不会出问题，毕竟同一个用户，在同一台机器上出现一样的sessionId的情况，理论上就不可能出现</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/HTTP2%E9%87%8D%E7%82%B9PICK-http2-zhong-dian-pick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果冻 | Jelly">
      <meta itemprop="description" content="Beat Jelly; Hit Jelly; Kill Jelly.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="果冻 | Jelly">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/HTTP2%E9%87%8D%E7%82%B9PICK-http2-zhong-dian-pick/" class="post-title-link" itemprop="url">HTTP2重点PICK</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-12 23:59:01" itemprop="dateCreated datePublished" datetime="2021-09-12T23:59:01+08:00">2021-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">网络基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>花了两天时间读完HTTP2的<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7540.txt.pdf">RFC</a>，揭开HTTP2的神秘面纱，驱散心中迷雾，它比HTTP1.1，到底改变了什么。</p>
</blockquote>
<h2 id="这是一篇什么样的文章"><a href="#这是一篇什么样的文章" class="headerlink" title="这是一篇什么样的文章"></a>这是一篇什么样的文章</h2><p>这是一篇化繁为简的文章，只pick HTTP2中最为关键的部分，忽略细节实现部分。毕竟，每个人读一个文档的目的是不一样的。像我只是想从原理上理解，以便之后使用时能够更加顺畅；而如果是为了实现一个支持HTTP2的库，则需要抠细节，当然花费的时间肯定也不一样，那会是一遍一遍又一遍。</p>
<p>同时我也受够了网上花花绿绿的文章，它们，十之八九，乃基于数篇至数百篇咀嚼过的N手知识，稀碎拼凑而成。看完之后，给人似懂非懂，缺斤少两的感觉。当然，并不是在说人家不好，我也没那个资格，深以为，大家写文章、做总结，其受众非我等小明小红小丽，实为作者自己。认知闭合，学习金字塔，是公共的概念，也是大家的需求。写文章，也算是教授给他人的一种方式。</p>
<p>并不是说我这个文章就比别人的好，那也不见得。文章的好坏与否，取决于本身质量、表述方式等诸多因素。我写这篇文章，也更多是给今后的自己看，于其他人，和网上其它千百文章并无二致。大家并不会因为看了它对HTTP2变得更加了解，这不符合正常的学习曲线。</p>
<p>不过，硬要说的话，我还是可以推荐一篇写得好的HTTP2文章的，详尽，且带有实例讲解，文章基于RFC，同时查阅了很多其他资料，可说是长篇佳作。但它也有缺点，即没有重点，或重点过多。比如HTTP2的优势一节，服务端推送、应用层重置连接、优先级设置、流量控制等，未见得是优势，对理解来说并无关键作用。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903667569541133#heading-59">HTTP2详解</a></p>
<h2 id="HTTP2升级了什么"><a href="#HTTP2升级了什么" class="headerlink" title="HTTP2升级了什么"></a>HTTP2升级了什么</h2><p>HTTP1.x和HTTP1.1有几个主要的问题</p>
<ul>
<li>对同一地址的多次请求，会创建多个TCP连接。HTTP1.0自不必多说，每个请求就会创建一个连接；HTTP1.1虽有所优化，还引入了pipline技术，但也仅仅是将几个请求合并在一个连接，且pipline技术还会有管线头问题，即响应的顺序必须和请求的顺序一致，如果管线中第一个请求阻塞了，会导致同一管线中其它请求的阻塞，即请求之间互相影响了。</li>
<li>HTTP请求头多且重复，浪费带宽。</li>
</ul>
<p>HTTP2的解决方案，也是HTTP2的主要内容，说是所有内容也不为过</p>
<ul>
<li>针对第一个问题，HTTP2提供的解决方案是多路复用，同一地址只会建立一个连接，节省资源；引入Stream和帧，使得不同请求之间完全不干扰，提升传输效率。</li>
<li>针对请求头多的问题，HTTP2使用HPACK压缩算法，压缩掉重复的请求头。</li>
<li>还有一个额外的优化：服务端推送，它使得服务端可以自动发送预加载资源，而不必客户端主动请求。</li>
</ul>
<h2 id="先强调几个点"><a href="#先强调几个点" class="headerlink" title="先强调几个点"></a>先强调几个点</h2><ul>
<li>HTTP2是一个二进制协议，不像HTTP1.x那样是文本协议。</li>
<li>HTTP2的服务端推送，与WebSocket、SSE等完全不一样，只是为了更快地在浏览器和服务器之间传输数据，我们并不能随意操作。</li>
</ul>
<h2 id="HTTP2通信过程"><a href="#HTTP2通信过程" class="headerlink" title="HTTP2通信过程"></a>HTTP2通信过程</h2><p>在语义上，HTTP2继承了绝大部分HTTP1.1的内容，因此在使用时完全感觉不到，浏览器或者我们HTTP库自动做了升级操作，不信看我们的Ingress访问日志，相当一部分请求已经走的HTTP2协议了。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912104305705.png" alt="image-20210912104305705"></p>
<p>总体来说，一个完整的通信过程包括：协议升级 -&gt; 数据分帧 -&gt; 发送 -&gt; 服务端组装帧 -&gt; 服务端逻辑处理并响应 -&gt; 数据分帧 -&gt; 发送 -&gt; 客户端组装帧 -&gt; 处理响应。</p>
<p>可以看到，相对HTTP1.x，多了两类步骤，其它的和之前的协议一样，怪不得我们感受不到。</p>
<ul>
<li>协议升级</li>
<li>数据分帧、合帧等中间操作</li>
</ul>
<h3 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h3><p>还记得WebSocket的升级方式吗？是一样的。</p>
<p>这样的请求</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Connection: Upgrade, HTTP2-Settings</span><br><span class="line">Upgrade: h2c</span><br><span class="line">HTTP2-Settings: <span class="tag">&lt;<span class="name">base64url</span> <span class="attr">encoding</span> <span class="attr">of</span> <span class="attr">HTTP</span>/<span class="attr">2</span> <span class="attr">SETTINGS</span> <span class="attr">payload</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>升级成功就是这样的响应，然后就在同一个TCP连接上快乐地发送数据了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: h2c</span><br></pre></td></tr></table></figure>

<p>请求头说明</p>
<ul>
<li>Upgrade：表明升级的目标是HTTP2协议。h2c是HTTP2从非加密通道升级时的标识符；加密通道则为h2</li>
<li>HTT2-Settings：关于HTTP2传输参数的配置，配置的参数包括请求头索引表大小、并发流的个数等</li>
</ul>
<h3 id="数据分帧、合帧"><a href="#数据分帧、合帧" class="headerlink" title="数据分帧、合帧"></a>数据分帧、合帧</h3><p>HTTP2是二进制帧，而为了兼容当前的HTTP语义，即请求-响应机制，HTTP请求、响应中又包含请求行、头部、body等，这些内容都会被封装成HTTP2的帧进行传输，到远端再重新合并，这里给出一个RFC中对一些请求的分帧示例。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912111358587.png" alt="image-20210912111358587" style="zoom:80%;" />

<p>例子中的POST请求，共被分为三帧。</p>
<ul>
<li>HEADERS帧：将请求的方法、路径、scheme转换为伪头，封装进一个HEADER帧</li>
<li>CONTINUATION帧：这是作为上面那个HEADER的续帧，将请求的头部封装了进来</li>
<li>DATA帧：封装了该请求的请求体中的内容</li>
</ul>
<p>接收方按照分帧的方式进行合帧，就能得到原始数据</p>
<h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><p>表层看，通信过程就如上面讲的那样，但理解HTTP2的关键，要完全了解帧的概念，它是HTTP2数据传输的最小单位；要了解流的概念，它是实现多路复用的最关键技术；要了解头部压缩，它是实现带宽节省的关键技术。此外，还有两个点我忽略掉了，他们并不会给理解带来任何阻碍：流控和流的优先级</p>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>帧在整个协议栈中的位置如下：</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912115557314.png" alt="image-20210912115557314" style="zoom:80%;" />

<p>这就是HTTP2的帧结构，其实挺简单</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912112208591.png" alt="image-20210912112208591" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>字段名</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>帧的载荷长度</td>
</tr>
<tr>
<td>Type</td>
<td>帧类型</td>
</tr>
<tr>
<td>Flags</td>
<td>标记位，不同的帧类型会使用到不同的标记位</td>
</tr>
<tr>
<td>Stream ID</td>
<td>流ID</td>
</tr>
</tbody></table>
<p>帧类型大概有这么多（忽略了流控（WINDOW_UPADTE）和优先级（PRIORITY）两个类型）</p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DATA</td>
<td>数据帧</td>
</tr>
<tr>
<td>HEADERS</td>
<td>头部帧，用于开启一个流</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>作为HEADERS帧的续帧</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>复位帧，用于中止一个流，当流发生错误时发送。<br />用它只会中止流，对连接上的其它流没有影响</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>设置帧，用于在数据发送交流通信参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>服务端推送帧，服务端发往客户端，表明服务端将要有数据推送下来，客户端等着</td>
</tr>
<tr>
<td>PING</td>
<td>注意这不是心跳，而是测量一个请求-响应完成时间的帧</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>整个连接关闭前发送的帧，该帧携带了远端处理成功的最后一个流ID，以便接收方做优雅关闭</td>
</tr>
</tbody></table>
<p>这么多帧，数据相关的帧只有前三种，其它都是控制帧。</p>
<h3 id="多路复用（Stream、Frame）"><a href="#多路复用（Stream、Frame）" class="headerlink" title="多路复用（Stream、Frame）"></a>多路复用（Stream、Frame）</h3><p>三张图对比最原始的HTTP请求响应、pipeline、HTTP多路复用的区别。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912114949108.png" alt="image-20210912114949108" style="zoom:80%;" />

<p>解读</p>
<ul>
<li><p>无pipeline时，一个HTTP请求必须等待上一个请求响应完成后才可进行，完全串行</p>
</li>
<li><p>有pipeline时，请求可以不等待响应直接发送了，但是响应的顺序和请求的顺序必须完全一致。如果第一个请求响应很慢，会阻塞其它两个请求。</p>
<p>这个，顶多相当于批量执行。</p>
</li>
<li><p>多路复用时，与pipeline的区别，是响应之间互不干涉，随便怎么发都行。</p>
</li>
</ul>
<p><strong>怎么理解多路复用</strong></p>
<p>多路：其实指的是请求与响应两路；也可以理解为一个请求响应理解为一路，多个请求连接复用一个连接。</p>
<p>复用：即同一个TCP连接，可以同时传输请求与响应的数据，数据之间互不干扰。这在之前可是不行的哦。</p>
<p><strong>如何实现</strong></p>
<p>多路复用，是帧（Frame）和流（Stream）共同作用的结果。</p>
<ul>
<li>帧有两个作用：一是可以携带额外的控制参数，如流ID；二是拆分数据包</li>
<li>流则是一个逻辑上的抽象：一个TCP连接上所承载的数据，通过流进行逻辑识别。应用到HTTP语义的协议上，一个请求对应一个流，而TCP连接上胡乱交叉的请求与响应的数据帧才能被正确识别，因为有唯一识别符——流ID嘛</li>
</ul>
<p>比如下面这个图，如果stream 3这两帧被服务端处理完后，服务端发送响应，只需要将响应帧的流也标识为stream 3，这样，无乱什么时候发过来，客户端都知道这个响应对应的是原来stream 3发出去的那个请求。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912120902351.png" alt="image-20210912120902351" style="zoom:80%;" />

<p><strong>HTTP1.1为什么不做多路复用</strong></p>
<p>这是交付模型的直接结果，HTTP1.x还是直接的请求-响应模型，如果顺序打乱，将无法在茫茫请求中找到将发送的响应到底属于哪个请求，客户端在接收方也无法区分出收到的这个响应到底是哪个请求发送出去的。而HTTP2不一样，每个请求都被对应一个Stream（流），流有ID，逻辑上只要保证流内部的帧顺序不出错即可，至于响应，无论什么时候，我处理完的请求发送回去只要带流ID即可，客户端知道这个流ID对应的请求是谁。</p>
<p><strong>流多说两点</strong></p>
<p>HTTP2中的流，是一个逻辑概念，即拥有连续帧的抽象。关于流，有几个注意事项</p>
<ul>
<li>一个流内部，帧之间的顺序是绝对的，不然收到之后组装不回去，会报错的</li>
<li>流可以指定优先级，优先级高的流会被优先处理，这在资源有限时会比较有用</li>
</ul>
<h3 id="头部编排和压缩"><a href="#头部编排和压缩" class="headerlink" title="头部编排和压缩"></a>头部编排和压缩</h3><p>HTTP2的HEADERS帧并不直接对应HTTP1.x语义的头部哦，有没有发现HTTP2并没有为请求行和状态行这些HTTP1.x语义的内容留专门的定义，事实上确实没有，因此在进行HTTP1.x数据传输时，需要先做头部编排。</p>
<p>其中最重要的是将请求行编排为<strong>伪头</strong>，以冒号开头，具体来说</p>
<table>
<thead>
<tr>
<th>伪头</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:method</td>
<td>GET</td>
<td>方法</td>
</tr>
<tr>
<td>:scheme</td>
<td>https</td>
<td>协议</td>
</tr>
<tr>
<td>:host</td>
<td>api.wemore.com</td>
<td>主机地址</td>
</tr>
<tr>
<td>:path</td>
<td>/resource</td>
<td>资源路径</td>
</tr>
</tbody></table>
<p>至于压缩，HTTP2采用HPACK压缩算法，即构建一个索引表，将传输过的头部存入表中，下次传输时，如果头部已经在表中，则传索引号即可，否则传输实际请求头。需要注意的是，这个索引表是针对整个连接都有效的，所以能够跨Stream使用。</p>
<p>如下，第一个请求时，传输完整的头部，第二次请求时，仅有一个头部不一样，因此只传输这个头部即可，其它头部传索引（图中没画出来）。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912114305063.png" alt="image-20210912114305063" style="zoom:80%;" />

<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>相信我，它并不是你想象的那个样子。</p>
<p>我刚开始想象的样子：有了HTTP2，我们将不再需要WebSocket，因为它是长连接，也是支持服务端主动发送数据。</p>
<p>但我想多了，看<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">这里</a>可以了解到，HTTP2所谓的服务端推送，只是打破了一个请求对应一个响应的语义，只有有限场景能够用到，即服务端知道客户端将要请求什么数据，比如服务端返回一个网页，网页内嵌了很多图片、css、js等静态资源，按照以往的规则，都是要等待客户端发起推送的，但现在不一样，服务端可以告诉客户端：你先等着，我还有数据要发给你。</p>
<p><strong>实现方式</strong></p>
<p>服务端发送PUSH_PROMISE帧，客户端收到之后，不关闭流，而是待机等待。</p>
<p><strong>应用范围</strong></p>
<p>目前还很窄，nginx支持简单的静态资源推送，如下</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这表明访问index.html时，服务端会主动推送下面这些静态文件</span></span><br><span class="line"><span class="attribute">location</span> = /index.html &#123;</span><br><span class="line">  <span class="attribute">http2_push</span> /css/style.css;</span><br><span class="line">  <span class="attribute">http2_push</span> /js/main.js;</span><br><span class="line">  <span class="attribute">http2_push</span> /img/yule.jpg;</span><br><span class="line">  <span class="attribute">http2_push</span> /img/avatar.jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它场景应用也不是很多，主要还是对资源加载的优化，并不像WebSocket那样，完全将客户端-服务端之间数据传输的控制权完全交给用户。</p>
<h2 id="抓个包看一下"><a href="#抓个包看一下" class="headerlink" title="抓个包看一下"></a>抓个包看一下</h2><p>主要抓包有三种方式，网上搜一搜就知道了</p>
<ul>
<li>chrome：并不能通过控制台看到HTTP2的通信过程，而是要通过特殊的工具：chrome://net-internals/#http2</li>
<li><a target="_blank" rel="noopener" href="https://github.com/nghttp2/nghttp2">nghttp2</a>：一个开源命令行工具，能够抓取一个网站的HTTP2完整的通信过程</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jesse131/p/12686304.html">wireshark</a>：TCP抓包工具，但是要抓HTTP2包需要先配置秘钥，配置方式和Charles等不一样：Charles是伪造TLS证书，wireshark是窃取TLS握手成功后交换的对称秘钥</li>
</ul>
<p>我用nghttp2抓了一个nghttp2.org网站的包，可以看到大致流程</p>
<ul>
<li>建立连接，协议升级，https内标识：h2</li>
<li>发送SETTINGS帧，设置的内容有<ul>
<li>客户端流最大并发度：100</li>
<li>客户端的流控窗口初始值：65535</li>
</ul>
</li>
<li>发送PRIORITY帧，分别设置了流3、5、7、9、11、13的优先级（weight），依赖关系（dep_stream_id），流优先级及依赖关系请自行参考RFC</li>
<li>发送HEADERS帧，对GET <a target="_blank" rel="noopener" href="https://nghttp2.org进行访问/">https://nghttp2.org进行访问</a></li>
<li>收到服务端发来的SETTINGS帧，设置的内容有<ul>
<li>服务端流最大并发度：100</li>
<li>服务端流控窗口初始值：1048576</li>
<li>请求头索引表大小：8192</li>
</ul>
</li>
<li>收到服务端对之前SETTINGS帧的ACK响应（这是ACK可靠传输的机制，参见RFC）</li>
<li>收到PUSH_PROMISE帧，服务端即将推送screen.css帧给我们</li>
<li>发送对之前服务端SETTINGS帧的ACK响应</li>
<li>收到DATA帧，即传输内容</li>
<li>处理处理完收到的内容后，本地处理能力有所变化，发送WINDOW_UPDATE帧给客户端，通知对方调整流控窗口</li>
<li>收到带有END_STREAM标记的DATA帧，表明数据传输完成</li>
<li>发送GOAWAY帧，告诉客户端连接即将关闭，同时告知上一个成功的流ID为2，且没有任何错误，方便服务端进行优雅地关闭。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">zouguodong@zouguodongdeMacBook-Pro ~ % nghttp -nv https://nghttp2.org/</span><br><span class="line">[  0.228] Connected</span><br><span class="line">The negotiated protocol: h2</span><br><span class="line">[  0.358] send SETTINGS frame &lt;length=12, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=2)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):100]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):65535]</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=3&gt;</span><br><span class="line">          (dep_stream_id=0, weight=201, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=5&gt;</span><br><span class="line">          (dep_stream_id=0, weight=101, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=7&gt;</span><br><span class="line">          (dep_stream_id=0, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=9&gt;</span><br><span class="line">          (dep_stream_id=7, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=11&gt;</span><br><span class="line">          (dep_stream_id=3, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send HEADERS frame &lt;length=36, flags=0x25, stream_id=13&gt;</span><br><span class="line">          ; END_STREAM | END_HEADERS | PRIORITY</span><br><span class="line">          (padlen=0, dep_stream_id=11, weight=16, exclusive=0)</span><br><span class="line">          ; Open new stream</span><br><span class="line">          :method: GET</span><br><span class="line">          :path: /</span><br><span class="line">          :scheme: https</span><br><span class="line">          :authority: nghttp2.org</span><br><span class="line">          accept: */*</span><br><span class="line">          accept-encoding: gzip, deflate</span><br><span class="line">          user-agent: nghttp2/1.43.0</span><br><span class="line">[  0.474] recv SETTINGS frame &lt;length=24, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=4)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):100]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):1048576]</span><br><span class="line">          [SETTINGS_ENABLE_CONNECT_PROTOCOL(0x08):1]</span><br><span class="line">          [SETTINGS_HEADER_TABLE_SIZE(0x01):8192]</span><br><span class="line">[  0.475] recv SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br><span class="line">[  0.475] recv (stream_id=13) :method: GET</span><br><span class="line">[  0.475] recv (stream_id=13) :scheme: https</span><br><span class="line">[  0.475] recv (stream_id=13) :path: /stylesheets/screen.css</span><br><span class="line">[  0.475] recv (stream_id=13) :authority: nghttp2.org</span><br><span class="line">[  0.475] recv (stream_id=13) accept-encoding: gzip, deflate</span><br><span class="line">[  0.475] recv (stream_id=13) user-agent: nghttp2/1.43.0</span><br><span class="line">[  0.475] recv PUSH_PROMISE frame &lt;length=47, flags=0x04, stream_id=13&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0, promised_stream_id=2)</span><br><span class="line">[  0.475] send SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br><span class="line">[  0.673] recv (stream_id=13) :status: 200</span><br><span class="line">[  0.673] recv (stream_id=13) date: Sun, 12 Sep 2021 04:53:16 GMT</span><br><span class="line">[  0.673] recv (stream_id=13) content-type: text/html</span><br><span class="line">[  0.673] recv (stream_id=13) last-modified: Sun, 18 Jul 2021 04:17:59 GMT</span><br><span class="line">[  0.673] recv (stream_id=13) etag: <span class="string">&quot;60f3ab77-19d8&quot;</span></span><br><span class="line">[  0.673] recv (stream_id=13) accept-ranges: bytes</span><br><span class="line">[  0.673] recv (stream_id=13) content-length: 6616</span><br><span class="line">[  0.673] recv (stream_id=13) x-backend-header-rtt: 0.001926</span><br><span class="line">[  0.673] recv (stream_id=13) strict-transport-security: max-age=31536000</span><br><span class="line">[  0.673] recv (stream_id=13) server: nghttpx</span><br><span class="line">[  0.673] recv (stream_id=13) alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=3600</span><br><span class="line">[  0.673] recv (stream_id=13) via: 2 nghttpx</span><br><span class="line">[  0.673] recv (stream_id=13) x-frame-options: SAMEORIGIN</span><br><span class="line">[  0.673] recv (stream_id=13) x-xss-protection: 1; mode=block</span><br><span class="line">[  0.673] recv (stream_id=13) x-content-type-options: nosniff</span><br><span class="line">[  0.673] recv HEADERS frame &lt;length=235, flags=0x04, stream_id=13&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0)</span><br><span class="line">          ; First response header</span><br><span class="line">[  0.673] recv (stream_id=2) :status: 200</span><br><span class="line">[  0.673] recv (stream_id=2) date: Sun, 12 Sep 2021 04:53:16 GMT</span><br><span class="line">[  0.673] recv (stream_id=2) content-type: text/css</span><br><span class="line">[  0.674] recv (stream_id=2) last-modified: Sun, 18 Jul 2021 04:17:59 GMT</span><br><span class="line">[  0.674] recv (stream_id=2) etag: <span class="string">&quot;60f3ab77-98aa&quot;</span></span><br><span class="line">[  0.674] recv (stream_id=2) accept-ranges: bytes</span><br><span class="line">[  0.674] recv (stream_id=2) content-length: 39082</span><br><span class="line">[  0.674] recv (stream_id=2) x-backend-header-rtt: 0.002213</span><br><span class="line">[  0.674] recv (stream_id=2) strict-transport-security: max-age=31536000</span><br><span class="line">[  0.674] recv (stream_id=2) server: nghttpx</span><br><span class="line">[  0.674] recv (stream_id=2) alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=3600</span><br><span class="line">[  0.674] recv (stream_id=2) via: 2 nghttpx</span><br><span class="line">[  0.674] recv (stream_id=2) x-frame-options: SAMEORIGIN</span><br><span class="line">[  0.674] recv (stream_id=2) x-xss-protection: 1; mode=block</span><br><span class="line">[  0.674] recv (stream_id=2) x-content-type-options: nosniff</span><br><span class="line">[  0.674] recv (stream_id=2) x-http2-push: 1</span><br><span class="line">[  0.674] recv HEADERS frame &lt;length=63, flags=0x04, stream_id=2&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0)</span><br><span class="line">          ; First push response header</span><br><span class="line">[  0.674] recv DATA frame &lt;length=6616, flags=0x01, stream_id=13&gt;</span><br><span class="line">          ; END_STREAM</span><br><span class="line">[  0.674] recv DATA frame &lt;length=9434, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.763] recv DATA frame &lt;length=14467, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.851] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.851] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] send WINDOW_UPDATE frame &lt;length=4, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (window_size_increment=33140)</span><br><span class="line">[  0.852] send WINDOW_UPDATE frame &lt;length=4, flags=0x00, stream_id=2&gt;</span><br><span class="line">          (window_size_increment=34393)</span><br><span class="line">[  0.943] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.964] recv DATA frame &lt;length=2066, flags=0x01, stream_id=2&gt;</span><br><span class="line">          ; END_STREAM</span><br><span class="line">[  0.964] send GOAWAY frame &lt;length=8, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (last_stream_id=2, error_code=NO_ERROR(0x00), opaque_data(0)=[])</span><br></pre></td></tr></table></figure>

<h2 id="请注意"><a href="#请注意" class="headerlink" title="请注意"></a>请注意</h2><p>HTTP2是一个二进制协议，Stream、分帧等行为，并不具有更多语义上的意义（尽管帧类型规定是那些，但帧类型是可扩展的，协议也留出了扩展空间），也就是说，它能被用在其它应用场景下，比如GRPC</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">果冻 | Jelly</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
