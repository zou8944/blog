<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86-she-ji-mo-shi--li-lun-bu-fen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86-she-ji-mo-shi--li-lun-bu-fen/" class="post-title-link" itemprop="url">设计模式 - 理论部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-04 18:15:32" itemprop="dateCreated datePublished" datetime="2021-10-04T18:15:32+08:00">2021-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这是系列文章</p>
<ul>
<li>设计模式 - 理论（本文）</li>
<li>设计模式 - JDK</li>
<li>设计模式 - Spring</li>
</ul>
</blockquote>
<h2 id="避免陷阱"><a href="#避免陷阱" class="headerlink" title="避免陷阱"></a>避免陷阱</h2><p>以前也学习过设计模式，而且不止一次，都以失败告终。究其原因：</p>
<p>一是教材选用不对——《大话设计模式》，虽然这本书豆瓣评分8.3，但显然不适合我。讲的太啰嗦，我会讨厌弱智似的故事情节：什么大鸟小鸟老鸟、王二狗林蛋大，读者都是技术人员，作者却还是用小学生作为的语气讲故事，亦或是，难道大家真的都习惯了这种口吻接受知识？</p>
<p>二来，技术书籍也好，网络文章也好，好像都是一个模子刻出来的，上来就是UML图、代码实现，模式解决了什么问题一笔带过。读者注意力转移不说，还很容易流于形式：更多考虑的是这个模式为什么要定义这个接口？而不是什么情况下、为什么使用这个模式？——后者搞清楚了，与模式规定的接口不一样也没有关系。</p>
<p>三是，实践不够多，代码量不够，看到的代码也不够——时机不成熟。</p>
<p>每本设计模式的教材都教我们，不要轻易使用设计模式，只有需要时才使用，以避免过度设计。我觉得这是一个误解，在甚至搞不清楚三个工厂模式具体区别时，弄懂设计模式才是关键。至于使用，我认为该多用，直到熟悉之后，再考虑用得合不合适。</p>
<p>前段时间Github Daily推荐了<a target="_blank" rel="noopener" href="https://github.com/kamranahmedse/design-patterns-for-humans">《给人看的设计模式》</a>，没有UML图，短小精悍，再次触发了我学习设计模式的兴趣。</p>
<p>这是一篇总结性的文章，视图用一句话描述一个设计模式存在的价值</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创造类"><a href="#创造类" class="headerlink" title="创造类"></a>创造类</h3><p>创造类设计模式，主要关注对创建对象的方式，根据不同的创造需求产生了对应的设计模式。</p>
<ul>
<li>当创建一个对象有一定的逻辑复杂度，我们不希望用户直接接触到创建过程，就有了<strong>简单工厂模式</strong>，封装创建过程</li>
<li>当创建一个对象有一定的逻辑复杂度，但创建过程会依据对象的实现而不同，就有了<strong>工厂方法模式</strong>，定义工厂抽象类，具体创建逻辑留在工厂子类实现，这在SPI经常使用</li>
<li>当需要创建一族而不是一个相互关联的对象时，就有了<strong>抽象工厂模式</strong></li>
<li>当创建一个对象可能需要多个步骤，且步骤之间可以自由组合，就有了<strong>建造器模式</strong>，它解决了构造方法地狱的问题</li>
<li>当一个对象的创建是直接来源于同类的其它对象时，就有了<strong>原型模式</strong></li>
<li>当需要控制一个类在整个系统仅有一个对象时，就有了<strong>单例模式</strong></li>
</ul>
<h3 id="结构类"><a href="#结构类" class="headerlink" title="结构类"></a>结构类</h3><p>结构类设计模式，主要关注对象之间的组合方式，即对象之间如何相互作用。关注的是对象之间的关系</p>
<ul>
<li><p>当一个类需要使用另一个类，但类之间接口不兼容时，就有了<strong>适配器模式</strong>，为“另一个类”创建适配器，使其变得兼容</p>
</li>
<li><p>当一个类中的某个特性发生变化，使用继承表达这种变化会引发子类泛滥时，就有了<strong>桥接模式</strong>，将变化的特性抽出，任其自身变化，再“桥接”回原类。</p>
<p>这是一个使用组合替换继承的典型场景</p>
</li>
<li><p>当多个对象本身的逻辑关系为树状结构时，我们自然地通过组合的方式将他们联系在一起，用户只需要获取根对象就能操作整套对象，这就是<strong>组合模式</strong></p>
</li>
<li><p>当需要为一个类动态增加一系列功能，而又不改变原类，且增加的功能要灵活增减，就有了<strong>装饰器模式</strong></p>
</li>
<li><p>当需要为一个功能复杂的类提供一套使用简单的访问接口时，就有了<strong>外观模式</strong></p>
</li>
<li><p>当系统中有大量相同对象，为了减少内容消耗，我们让这些对象共用一个存储位置，就有了<strong>享元模式</strong></p>
</li>
<li><p>当需要在调用对象时增加额外的控制逻辑，或者因某些原因不方便直接调用该对象，就有了<strong>代理模式</strong></p>
</li>
</ul>
<h3 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h3><p>行为类设计模式关注的是如何在对象之间进行通讯，即如何在软件组件中运行行为</p>
<ul>
<li><p>当对同一个源对象，我们有多套处理方案，或多套处理逻辑，此时可以使用<strong>责任链模式</strong>，将每个方案或逻辑抽象为一个责任对象，他们共同构成责任链，源对象从责任链的这头走到那头，依次应用每一个逻辑</p>
</li>
<li><p>将行为封装在对象中，然后传递给执行者，这就是<strong>命令模式</strong>，它将执行者和行为解耦。想象操作系统是执行者，各种shell命令就是被封装的行为对象。</p>
</li>
<li><p>当我们需要在不暴露底层实现的情况下，提供一个简单的接口访问容器元素，这就是<strong>迭代器模式</strong></p>
</li>
<li><p>当两个或多个对象需要相互交流时，就有了<strong>中介者模式</strong>，中介者定义了这些类交流的行为，提供了一个平台。</p>
</li>
<li><p>当需要永久保留程序运行状态，并提供日后恢复可能性时，就有了<strong>备忘录模式</strong>，它提供了回滚的能力</p>
</li>
<li><p>当一个对象需要对另一个对象的状态变化做出响应时，就有了<strong>观察者模式</strong>，这个就太常用了</p>
</li>
<li><p>当要对一个对象添加更多操作，又不想修改他们时，就有了<strong>访问者模式</strong>，将添加的操作集中到访问者</p>
<p>被访问者需要提供接收访问者的接口；访问者一般访问的是被访问者的实现类</p>
</li>
<li><p>当需要将行为的算法抽象出来，在运行时候动态动态应用不同的算法抽象，就有了<strong>策略模式</strong>，典型的如比较器</p>
</li>
<li><p>当对象的行为需要根据“状态”变化，就有了<strong>状态设计模式</strong>，它允许我们通过修改“状态”来修改对象的行为</p>
</li>
<li><p>当对象的行为步骤固定，但步骤的具体实现要放到子类中实现，就有了<strong>模板方法模式</strong>，他允许我们先定义算法框架，后定义算法实现</p>
</li>
</ul>
<h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><h3 id="三个工厂模式如何区分"><a href="#三个工厂模式如何区分" class="headerlink" title="三个工厂模式如何区分"></a>三个工厂模式如何区分</h3><ul>
<li>简单工厂：静态方法，只是封装了单个对象的创建过程</li>
<li>工厂方法：非静态方法，对象创建的具体过程需要等到子类实现</li>
<li>抽象工厂：非静态方法，提供的是多个创建方法，创建一组关联的对象</li>
</ul>
<p>当抽象工厂的创建方法只有一个时，退化为工厂方法；当工厂方法的实现类和抽象类变成一个，且方法变成静态时，退化为简单工厂</p>
<h3 id="命令模式与策略模式区分"><a href="#命令模式与策略模式区分" class="headerlink" title="命令模式与策略模式区分"></a>命令模式与策略模式区分</h3><p>疑惑点：都是将行为抽象出来</p>
<p>不同点：前者可能会包含命令接收者的状态信息，相对来说，它更加完整，增加一个环境就能运行了；后者只是一个纯粹算法的抽象</p>
<h3 id="迭代器模式和外观模式区分"><a href="#迭代器模式和外观模式区分" class="headerlink" title="迭代器模式和外观模式区分"></a>迭代器模式和外观模式区分</h3><p>疑惑点：都隐藏了底层实现，通过简单接口暴露</p>
<p>不同点：从隐藏底层暴露简单接口这一点看，后者是包含前者的，因为前者仅针对容器类对象；但后者在实现上，是单独创建一个类对原类进行封装；而前者往往是一个可迭代接口</p>
<h3 id="中介者模式和适配器模式区分"><a href="#中介者模式和适配器模式区分" class="headerlink" title="中介者模式和适配器模式区分"></a>中介者模式和适配器模式区分</h3><p>疑惑点：都是为两个对象提供“沟通渠道”</p>
<p>不同点：其实二者完全不同，前者是真的提供沟通渠道；后者只是在接口形式上使得二者兼容</p>
<h3 id="访问者模式和装饰器模式区分"><a href="#访问者模式和装饰器模式区分" class="headerlink" title="访问者模式和装饰器模式区分"></a>访问者模式和装饰器模式区分</h3><p>疑惑点：都是不修改原对象的情况下添加了更多操作</p>
<p>不同点：后者是真的完全不改变原有对象，通过创建新类将原类进行包装，在新类中添加功能，新类除了方法调用外，是访问不到原类内部的；前者并非无痛，访问者为了能够访问到被访问者，需要被访问者暴露方法将访问者注入。</p>
<p>且装饰器模式重点在”添加“功能；访问者模式重点在”访问“，正因为是”访问“，才需要将访问者注入被访问者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文没有代码，没有UML图，只有使用场景和容易搞混的设计模式区分。适合已经了解设计模式的人加深印象，要想详细了解，还是十分建议去看<a target="_blank" rel="noopener" href="https://github.com/kamranahmedse/design-patterns-for-humans">《给人看的设计模式》</a>。此外，强调几个点：</p>
<ul>
<li>忘记UML图，忘记UML图，忘记UML图，重要的事情说三遍。UML图只是形式上的定义，不用想肯定记不住，重点在于理解场景和实现思路。只要思路正确，和标准UML图差一点也没关系，并且，我们实现的代码最终一定会靠向该模式的标准结构。</li>
<li>不要一个一个看，全部看完并理解，才能有对比。</li>
<li>很多设计模式看起来比较相似，实际上他们确实有共通点，此时就需要自己体会了，不大好讲通。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/30/#%20%E7%90%86%E8%A7%A3UUID%EF%BC%88%E4%BB%AC%EF%BC%89-li-jie-uuid-men-/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/30/#%20%E7%90%86%E8%A7%A3UUID%EF%BC%88%E4%BB%AC%EF%BC%89-li-jie-uuid-men-/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-30 16:43:00" itemprop="dateCreated datePublished" datetime="2021-09-30T16:43:00+08:00">2021-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">后端 | 算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>UUID，Universal Unique Identifier，全局唯一标识符。也叫做GUID，Global Unique Identifier。</p>
<p>概念都了解，全局唯一嘛，但怎么实现的？多大概率重复？JDK的UUID和PostgreSQL的UUID一样吗？带着这些问题，我们从RFC，到JDK源码、PG手册，一点点看。</p>
<p>本文包含以下内容：</p>
<ul>
<li>UUID实现原理</li>
<li>自己实现一个UUID</li>
<li>JDK的实现方式</li>
<li>PG的实现方式</li>
<li>其它全局唯一ID</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>老样子，要想了解一项基础技术，最好的方式是阅读一手资料。于UUID，它是<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/pdfrfc/rfc4122.txt.pdf">RFC4122</a>。</p>
<p>这一节，更莫如说是对RFC的总结，毕竟规范这东西，写得太啰嗦了，全文字不说，还没有示意图。</p>
<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul>
<li>长度128个bit位。一般通过16位十六进制字符表示，如：4cc9de16-414b-4f68-9b7e-6feeb8f629b0</li>
<li>不需要中心管理，具有跨越时间和空间的唯一性</li>
<li>按照本标准中的算法，支持每台机器每秒高达1000万次高分配速率</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>理解UUID有两个重点：一是理解其组成部分；二是理解各版本对各部分的填充方式。我们先看最重要的——组成部分。</p>
<p>为了较为形象地展示，我画了张图。第一行是结果，第二行是十六进制说明，第三行是二进制说明。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210930084244949.png" alt="image-20210930084244949"></p>
<ul>
<li>time-low：时间戳低位，占用32个bit</li>
<li>time-mid：时间戳中位，占用16个bit</li>
<li>time-high-and-version：时间戳高位+版本号，前者占12个bit，后者占4个bit，注意区分版本号是在前的</li>
<li>clock-seq-high-and-reserved：时钟序列高位+预留位。前者占6个bit，后者占2个bit，也注意他们的前后顺序</li>
<li>clock-seq-low：时间序列低位，占8个bit</li>
<li>node：节点，占用48个bit</li>
</ul>
<p>引出新概念，time、clock-seq、node</p>
<ul>
<li>time：即时间戳</li>
<li>clock-seq：当时间戳或node重复时，使用clock-seq作为附加保证唯一性</li>
<li>node：机器的节点，一般是机器的MAC地址</li>
</ul>
<h3 id="区分版本"><a href="#区分版本" class="headerlink" title="区分版本"></a>区分版本</h3><p>注意到上面说组成时，有一个version字段。UUID是有多个版本的，目前总计5个。</p>
<p>版本规定了各字段的填充方式，版本2比较特殊这里忽略，其它版本如下</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>Timestamp</th>
<th>Clock sequence</th>
<th>node</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>从UTC时间1582-10-15 00:00:00起，100ns的个数</td>
<td>第一个clock sequence应该是随机产生的<br />如果知道本机上一次生成UUID的clock sequence，则此次只需要在其基础上加一<br /> 如果不知道，该字段需要设置成一个随机数</td>
<td>MAC地址 如果没有，则使用随机数</td>
</tr>
<tr>
<td>3</td>
<td>命名空间+名称的MD5只的一部分</td>
<td>命名空间+名称的MD5只的一部分</td>
<td>命名空间+名称的MD5只的一部分</td>
</tr>
<tr>
<td>4</td>
<td>随机数的一部分</td>
<td>随机数的一部分</td>
<td>随机数的一部分</td>
</tr>
<tr>
<td>5</td>
<td>命名空间+名称的SHA1只的一部分</td>
<td>命名空间+名称的SHA1只的一部分</td>
<td>命名空间+名称的SHA1只的一部分</td>
</tr>
</tbody></table>
<p>可以看到，所谓的时间戳、时钟序列、node这些字段，仅对版本1有效，其它版本填充进去的值并无逻辑意义。</p>
<h3 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h3><ul>
<li>对Version 1：它通过MAC地址保证空间唯一性，时间戳+序列号保证时间唯一性</li>
<li>对Version 2：和Version 1类似，只不过会把时间戳的前4位置换为POSIX的UID或GID</li>
<li>对Version 3、5：它纯依赖于名字保证唯一性，这就需要一个规整的命名系统：命名空间+名称</li>
<li>对Version 4：它纯通过随机数保证唯一性，此时一个高质量的随机数发生器就显得尤为重要</li>
</ul>
<h3 id="Version-1生成逻辑"><a href="#Version-1生成逻辑" class="headerlink" title="Version 1生成逻辑"></a>Version 1生成逻辑</h3><ol>
<li><p>获取一个系统级别的全局时钟</p>
</li>
<li><p>从一个系统全局共享的的存储位置，读取上一个UUID的状态：时间戳、始终序列、node等</p>
</li>
<li><p>获取当前时间戳：从UTC时间1582-10-15 00:00:00起，100ns的个数</p>
</li>
<li><p>获取nodeid，即MAC地址</p>
</li>
<li><p>如果上一个UUID状态不稳定（不存在、nodeid与新获取的nodeid不一样），生成一个随机clock value</p>
</li>
<li><p>如果状态存在，但时间戳比当前时间戳还晚，则clock sequence自增</p>
</li>
<li><p>将新的状态保存</p>
</li>
<li><p>将上面的三个部分按照格式组成UUID</p>
</li>
</ol>
<p><strong>有一个bug</strong></p>
<p>MAC地址直接放在nodeid中，就是一个bug，这会暴露用户的MAC地址：梅丽莎病毒制作者的位置就是这么暴露的</p>
<h3 id="Version-4生成逻辑"><a href="#Version-4生成逻辑" class="headerlink" title="Version 4生成逻辑"></a>Version 4生成逻辑</h3><ol>
<li>获取一个随机数</li>
<li>将预留位、版本位之外的位，使用该随机数填充，填充位对应方式，参考RFC</li>
</ol>
<h3 id="Version-3、5生成逻辑"><a href="#Version-3、5生成逻辑" class="headerlink" title="Version 3、5生成逻辑"></a>Version 3、5生成逻辑</h3><ol>
<li>命名空间+名字组成字符串，使用MD5或者SHA1计算摘要</li>
<li>将预留位、版本位之外的位，使用该摘要填充，填充位对应方式，参考RFC</li>
</ol>
<h3 id="为什么时间戳从1582-10-15开始"><a href="#为什么时间戳从1582-10-15开始" class="headerlink" title="为什么时间戳从1582-10-15开始"></a>为什么时间戳从1582-10-15开始</h3><p>这是公历改革到基督教日历的日期，说来话长，我也没啥兴趣去详细了解，如果需要，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/300868434">看看知乎吧</a></p>
<h2 id="自己写一个UUID吧"><a href="#自己写一个UUID吧" class="headerlink" title="自己写一个UUID吧"></a>自己写一个UUID吧</h2><p>尝试着实现了一下抽象定义和基于时间戳的版本，发现主要有几个难点：kotlin的进制转换、二进制操作等。</p>
<p>这是一个不能实际使用的UUID版本（实现它也不是本文的目的），仅作演示。</p>
<p>先是UUID的抽象定义，我们使用两个Long作为底层bit持有对象，定义各字段的set方法，主要是二进制操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UUID</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_LOW_MASK = (<span class="number">0xFFFFFFFFL</span>).shl(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_MID_MASK = (<span class="number">0xFFFFFFFFL</span>).shl(<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VERSION_MASK = (<span class="number">0xFFL</span>).shl(<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_HIGH_MASK = <span class="number">0xFFFFFFL</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> RESERVED_MASK = (<span class="number">0xFL</span>).shl(<span class="number">62</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> CLOCK_SEQ_HIGH_MASK = (<span class="number">0xFFFL</span>).shl(<span class="number">56</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> CLOCK_SEQ_LOW_MASK = (<span class="number">0xFFFFL</span>).shl(<span class="number">48</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NODE_MASK = <span class="number">0xFFFFFFFFFFFFL</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">timeBasedUUID</span><span class="params">()</span></span>: UUID = UUIDVersion1()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高有效位们：靠右</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mostSignificantBits = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低有效位：靠左</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leastSignificantBits = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeLow</span><span class="params">(timeLow: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeLow.toLong().shl(<span class="number">32</span>).and(TIME_LOW_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeMid</span><span class="params">(timeMid: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeMid.toLong().shl(<span class="number">16</span>).and(TIME_MID_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setVersion</span><span class="params">(version: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(version.toLong().shl(<span class="number">12</span>).and(VERSION_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeHigh</span><span class="params">(timeHigh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeHigh.toLong().and(TIME_HIGH_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setReserved</span><span class="params">(reserved: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(reserved.toLong().shl(<span class="number">62</span>).and(RESERVED_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClockSeqHigh</span><span class="params">(clockSeqHigh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(clockSeqHigh.toLong().shl(<span class="number">56</span>).and(CLOCK_SEQ_HIGH_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClockSeqLow</span><span class="params">(clockSeqLow: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(clockSeqLow.toLong().shl(<span class="number">48</span>).and(CLOCK_SEQ_LOW_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setNode</span><span class="params">(nodeId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(nodeId.toLong().and(NODE_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> lsbString = leastSignificantBits.toHexString()</span><br><span class="line">        <span class="keyword">val</span> msgString = mostSignificantBits.toHexString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> seg1 = lsbString.substring(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> seg2 = lsbString.substring(<span class="number">8</span>, <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">val</span> seg3 = lsbString.substring(<span class="number">12</span>, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">val</span> seg4 = msgString.substring(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> seg5 = msgString.substring(<span class="number">4</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$seg1</span>-<span class="variable">$seg2</span>-<span class="variable">$seg3</span>-<span class="variable">$seg4</span>-<span class="variable">$seg5</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一个粗糙的实现类，实现Version 1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UUIDVersion1</span> : <span class="type">UUID</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 计算time</span></span><br><span class="line">        <span class="keyword">val</span> start = LocalDateTime.of(<span class="number">1582</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> end = LocalDateTime.now(ZoneId.of(<span class="string">&quot;UTC&quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> duration = Duration.between(start, end)</span><br><span class="line">        <span class="keyword">val</span> time = duration.toMillis() * <span class="number">10</span></span><br><span class="line">        <span class="comment">// 计算clock seq</span></span><br><span class="line">        <span class="keyword">val</span> clock = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 获取node，我们用随机数替换</span></span><br><span class="line">        <span class="keyword">val</span> node = Random.nextInt()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setTimeLow(time.toInt())</span><br><span class="line">        <span class="keyword">this</span>.setTimeMid(time.shr(<span class="number">32</span>).toInt())</span><br><span class="line">        <span class="keyword">this</span>.setTimeHigh(time.shr(<span class="number">48</span>).toInt())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setClockSeqHigh(clock.shr(<span class="number">8</span>))</span><br><span class="line">        <span class="keyword">this</span>.setClockSeqLow(clock)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setNode(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setVersion(<span class="number">0b001</span>)</span><br><span class="line">        <span class="keyword">this</span>.setReserved(<span class="number">0b10</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以将生成的UUID转换为JDK的UUID进行验证。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uuidString = UUID.timeBasedUUID().toString()</span><br><span class="line">    println(uuidString)</span><br><span class="line">    <span class="keyword">val</span> uuid = java.util.UUID.fromString(uuidString)</span><br><span class="line">    println(uuid.version())</span><br><span class="line">    println(uuid.variant())</span><br><span class="line">    println(uuid.timestamp())</span><br><span class="line">    println(uuid.clockSequence())</span><br><span class="line">    println(uuid.node())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够得到如下输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">51d8c022-7dfc-1000-8000-ffffd963e9ed</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">138522658390050</span><br><span class="line">0</span><br><span class="line">281474328947181</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仔细想想，这个时间戳也不一定要从1580年开始，也可以换成自定义的时间戳，完全看需求。</p>
</blockquote>
<h2 id="JDK-UUID"><a href="#JDK-UUID" class="headerlink" title="JDK UUID"></a>JDK UUID</h2><p>JDK只提供Version 3和Version 4两种UUID，实现上也超级简单。</p>
<p>类似地，它也用两个long来组成128位，构建时直接分配位即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The most significant 64 bits of this UUID.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @serial</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mostSigBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The least significant 64 bits of this UUID.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @serial</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> leastSigBits;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UUID</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> msb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> lsb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">assert</span> data.length == <span class="number">16</span> : <span class="string">&quot;data must be 16 bytes in length&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    msb = (msb &lt;&lt; <span class="number">8</span>) | (data[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    lsb = (lsb &lt;&lt; <span class="number">8</span>) | (data[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">this</span>.mostSigBits = msb;</span><br><span class="line">  <span class="keyword">this</span>.leastSigBits = lsb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Version-4"><a href="#Version-4" class="headerlink" title="Version 4"></a>Version 4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">randomUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SecureRandom ng = Holder.numberGenerator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] randomBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">  ng.nextBytes(randomBytes);</span><br><span class="line">  randomBytes[<span class="number">6</span>]  &amp;= <span class="number">0x0f</span>;  <span class="comment">/* clear version        */</span></span><br><span class="line">  randomBytes[<span class="number">6</span>]  |= <span class="number">0x40</span>;  <span class="comment">/* set to version 4     */</span></span><br><span class="line">  randomBytes[<span class="number">8</span>]  &amp;= <span class="number">0x3f</span>;  <span class="comment">/* clear variant        */</span></span><br><span class="line">  randomBytes[<span class="number">8</span>]  |= <span class="number">0x80</span>;  <span class="comment">/* set to IETF variant  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UUID(randomBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，重点其实在Holder.numberGenerator，它的随机性决定了UUID的重复概率。而其实现SecureRandom，则涉及到另一个知识点——随机数，我们这里挖个坑，后面再探究随机数生成器到底有多随机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> SecureRandom numberGenerator = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static UUID nameUUIDFromBytes(byte[] name) &#123;</span><br><span class="line">  MessageDigest md;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException nsae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> new InternalError(<span class="string">&quot;MD5 not supported&quot;</span>, nsae);</span><br><span class="line">  &#125;</span><br><span class="line">  byte[] md5Bytes = md.digest(name);</span><br><span class="line">  md5Bytes[<span class="number">6</span>]  &amp;= <span class="number">0x0f</span>;  <span class="comment">/* clear version        */</span></span><br><span class="line">  md5Bytes[<span class="number">6</span>]  |= <span class="number">0x30</span>;  <span class="comment">/* set to version 3     */</span></span><br><span class="line">  md5Bytes[<span class="number">8</span>]  &amp;= <span class="number">0x3f</span>;  <span class="comment">/* clear variant        */</span></span><br><span class="line">  md5Bytes[<span class="number">8</span>]  |= <span class="number">0x80</span>;  <span class="comment">/* set to IETF variant  */</span></span><br><span class="line">  <span class="keyword">return</span> new UUID(md5Bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个更简单，做一下MD5，修改相应的bit填入即可，它的唯一性就完全依赖于传入的name了。</p>
<h2 id="PostgreSQL的UUID"><a href="#PostgreSQL的UUID" class="headerlink" title="PostgreSQL的UUID"></a>PostgreSQL的UUID</h2><p>根据<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/functions-uuid.html">手册</a>描述，PG的UUID也是Version 4，即基于随机数生成。</p>
<h2 id="UUID重复的概率"><a href="#UUID重复的概率" class="headerlink" title="UUID重复的概率"></a>UUID重复的概率</h2><p>就是个好奇，我们能够大致算一算，UUID重复的概率有多大，其实可以归结如下。</p>
<ul>
<li><p>对基于时间戳的情况，node稳定时，多个节点不可能重复，而单个节点，由于有记录上一个UUID的状态，因此也不会重复。只不过有生成速率限制，以RFC的方式来说，每个节点每100ns，最多能够生成2^14=16384个UUID，换算成秒，即每秒1.6亿个。</p>
</li>
<li><p>基于随机数的情况，取决于随机数生成器的质量</p>
</li>
<li><p>基于名字的情况，取决于命名系统，这种情况UUID只是命名系统的延伸，应该说不会考虑UUID重复的情况，而是命名系统本身的性能</p>
</li>
<li><p>128bit空间本身是否可能重复呢？用尽了就会，不过这个概率，类似流星撞地球吧。</p>
</li>
</ul>
<h2 id="其它全局唯一ID"><a href="#其它全局唯一ID" class="headerlink" title="其它全局唯一ID"></a>其它全局唯一ID</h2><p>最为大家熟知的恐怕就是雪花算法了吧，此外号段模式也算一个。</p>
<h3 id="雪花算法（SnkwFlake）"><a href="#雪花算法（SnkwFlake）" class="headerlink" title="雪花算法（SnkwFlake）"></a>雪花算法（SnkwFlake）</h3><p>了解了UUID Version 1的生成方式后，雪花算法就很容易理解，也是由时间戳-机器id-序列号组成，不同的是其只需要64个bit。且各字段可以根据实际需求调整bit的个数。雪花算法只是一种思想：将各位打散，再赋予不同的用途。UUID Version 1也是这种思想。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210930142313559.png" alt="image-20210930142313559"></p>
<p><strong>几个需要考虑的问题</strong></p>
<ul>
<li>时钟回拨问题：常见的方式是容忍小范围回拨，即如果当前时间戳比上一个生成的时间戳早，且在一定范围内，则依旧使用上一次的时间戳。这算一种校准方式，即回拨的这个时间差会被算到上一个时间戳的序列中，随着时间的推移，时间回拨问题会被抹平，但这段期间的生成效率会降低。</li>
<li>机器ID的生成方式：机器ID必须是稳定的，常见的解决方式是融合MAC地址。</li>
</ul>
<p><strong>雪花算法和UUID差别</strong></p>
<p>雪花算法得到的id依旧是64位，就是一个long，且时间戳在高位，是有序递增的。有序性，往往很重要。</p>
<p><strong>一些雪花算法的实现</strong></p>
<ul>
<li><p>百度UidGenerator</p>
<p>它解决时钟回拨的方式，是不容忍任何回拨，直接报错</p>
</li>
<li><p>美团Leaf</p>
<p>可选基于雪花算法或基于号段模式两种方案。其中使用雪花算法时，依赖于Zookeeper来分配WorkerID</p>
<p>它解决时钟回拨问题，和上面我们说的类似</p>
</li>
</ul>
<h3 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h3><p>这并不是什么算法，而是一种数据库自增ID的用法，一次取一批ID，用完了再取，保证了唯一性，降低了数据库的访问频率。</p>
<h2 id="分布式ID的选择"><a href="#分布式ID的选择" class="headerlink" title="分布式ID的选择"></a>分布式ID的选择</h2><p>你看，我们已经了解了最重要的全局唯一ID生成方式，那就可以讨论这个问题：分布式ID应该用哪种呢？</p>
<p>UUID优点在于生成简单，唯一性好，几乎所有语言都有标准实现。缺点在于长度过长、不具有单调性，且无意义。</p>
<p>雪花算法优点在于具有单调性，长度适中。缺点在于需要自己实现或引入第三方库。（一说雪花算法缺点在于依赖时间，但要在跨时间上保证唯一性，除了依赖时间，就是依赖随机数，所以我认为也算不上缺点，且时间回拨不是已经有解决方式了嘛）</p>
<p>如果ID需要存入数据库，由于UUID的无序性，可能会使得索引重建花费较长时间，当然使用<strong>雪花算法比较好</strong>。</p>
<h3 id="每记选择UUID作为key，合理吗？"><a href="#每记选择UUID作为key，合理吗？" class="headerlink" title="每记选择UUID作为key，合理吗？"></a>每记选择UUID作为key，合理吗？</h3><p>作为一个离线客户端软件，我们面临以下问题</p>
<ul>
<li>客户端环境千奇百怪，多平台（PC、网页、安卓、IOS等），多版本，总之，就很难信任客户端环境</li>
<li>离线时也要能正常使用</li>
</ul>
<p>如果使用雪花算法，会有几个问题</p>
<ul>
<li>首先，工作机器ID的确定，需要考虑的情况就会比较多，即生成算法需要调试。客户端的时间回拨，那可不就是修正就能够完事的。</li>
<li>其次，即使有序性有了，但多个设备上传的顺序依旧无法保证，受网络、环境影响较大，依旧会造成索引重建时候较多数据的移动</li>
</ul>
<p>如果使用UUID，其实就只有一个问题</p>
<ul>
<li><p>数据库存储的效率：索引重建。如果是聚簇索引，索引重建时移动的数据会很多，这对MySQL的innodb这类引擎来说可能是灾难。但是PgstgreSQL并非以B+树存储数据，所以性能损失并非想象的那么严重。具体如何，待后面详细研究一波PG的各种原理（完蛋，又挖了一个坑）</p>
<p>且，即使是MySQL，依然可以解决：主键设为单调自增的number，来自客户端的UUID仅作为普通字段，在该字段创建索引，会好很多。</p>
</li>
</ul>
<p>综上所述，使用UUID对客户端更方便，在服务端性能也算可以接受，所以说<strong>是合理的</strong>。</p>
<p>作为佐证，我抓了一个印象笔记下类每记产品”印象清单“，它就更加直白了，id字段名为”taskGuid“，值就是UUID。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;syncDataObject&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;tasks&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;state&quot;</span>:<span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;ruleId&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;description&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;clientUpdatedTime&quot;</span>:<span class="number">1632988316566</span>,</span><br><span class="line">          <span class="attr">&quot;sortIndex&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;dueTime&quot;</span>:<span class="number">1632988311635</span>,</span><br><span class="line">          <span class="attr">&quot;operation&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;æµè¯&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;finishedTime&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">          <span class="attr">&quot;taskGuid&quot;</span>:<span class="string">&quot;a1e4836c-4d59-409d-bf00-864d6d31cba0&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;createTime&quot;</span>:<span class="number">1632988316566</span>,</span><br><span class="line">          <span class="attr">&quot;taskListId&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;reminderTime&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">          <span class="attr">&quot;reminderType&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;taskRelatedNote&quot;</span>:[</span><br><span class="line">            </span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>:[</span><br><span class="line">        </span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;taskLists&quot;</span>:[</span><br><span class="line">        </span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h2><p>这篇UUID的文章写的不错，如果结合起来看，可以增进理解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/14343086.html#namespace-name-based-md5%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">冷饭新炒：理解JDK中UUID的底层实现</a></p>
<p>雪花算法呢，这篇文章看起来还行：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/402822041">SnowFlake</a></p>
<p>美团的Leaf，美团技术团队博客有进行说明：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>研究UUID的出发点，只是其RFC很短，仅三十多页，有效内容不到二十页。过程中却有几点意外之喜：</p>
<ul>
<li>顺着UUID的实现原理，了解到JDK的实现方式，自此，UUID于我，成了白盒；</li>
<li>能够体会JDK不提供Version1的原因（它太依赖具体系统，而语言级别的实现，一定是要所有情况通用的，显然Version 1的通用实现，不大好办）；</li>
<li>思路发散到分布式ID，详细了解了雪花算法，它和Version 1是如此接近，却只因为将node和seq换了个位置就能够单调递增，如此相似，结果却如此不同；</li>
<li>离线客户端用SnowFlake如何？它们看起来是大型分布式系统，实则与我们后端常说的分布式系统很不一样，这其中最大的不同是客户端环境不可控。</li>
<li>同时，还挖了两个坑：深入研究随机数、深入研究PostgreSQL</li>
</ul>
<p>本着输出驱动输入的方法完成本文，预期一两天，实则因思路发散花了更多时间，结果是令人满意的，因为它让我对技术，又少了一个模糊地带。</p>
<p>也应验了那句话：持续不断地学习，一定会给你带来惊喜。关键词是：<strong>持续不断</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/28/Spring%E6%89%AB%E7%9B%B2%E2%80%94%E2%80%94Spring%20Data%20JPA-spring-sao-mang-springdatajpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/28/Spring%E6%89%AB%E7%9B%B2%E2%80%94%E2%80%94Spring%20Data%20JPA-spring-sao-mang-springdatajpa/" class="post-title-link" itemprop="url">Spring扫盲——Spring Data JPA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-28 16:36:39" itemprop="dateCreated datePublished" datetime="2021-09-28T16:36:39+08:00">2021-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Spring | 后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>震惊，查询SQL的创建居然是根据Repository的方法名来生成的。</p>
<p>对于JPA，我们只需要掌握几点。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>配置开启JPA，提供EntityBeanFactory，提供repositories的配置包路径</li>
<li>定义Entity。不用自己写，使用IEAD的插件可以做到</li>
<li>定义Repository，提供灵活的定义方式<ul>
<li>定义查询方法，根据方法名来生成SQL的。这个叫做NamedQuery</li>
<li>自定义查询SQL，使用Query注解</li>
</ul>
</li>
<li>在需要使用的地方注入Repository</li>
</ul>
<h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><ul>
<li><p>Repository的查询方法有点意思，相当于直接吧SQL写成了查询方法</p>
</li>
<li><p>支持Querydsl，一种Java语言的SQL DSL，怎么说呢，如果代码过长，写起来还是不大方便吧</p>
</li>
<li><p>支持将Repository中查询方法的返回类型指定为非Entity的类，比如我们DTO</p>
</li>
<li><p>支持存储过程</p>
</li>
<li><p>如果为IDEA添加了JPA支持，在写Repository时会有提示呢，看起来还挺高级的</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E6%88%AA%E5%B1%8F2021-09-28%20%E4%B8%8B%E5%8D%884.34.31_1632818107252.png" alt="截屏20210928 下午4.34.31.png"></p>
</li>
</ul>
<h3 id="web支持"><a href="#web支持" class="headerlink" title="web支持"></a>web支持</h3><ul>
<li>通过添加EnableSpringDataWebSupport注解，能够提供支持<ul>
<li>定义的Entity能够被web解析和编码到消息体中</li>
<li>能够正常解析Sort、Pageable等参数</li>
<li>能够解析Point、Distance等类，根据具体使用的Spring Data模块而言。如使用Spring Data Redis，可能就有Distance</li>
<li>甚至能够直接把url中的查询参数转换为Querydsl的Predicte对象，即查询条件</li>
</ul>
</li>
</ul>
<h2 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h2><p>优点</p>
<ol>
<li>IDEA支持好</li>
<li>使用简单，只需要配置IDEA生成Entity，然后配置Repository即可</li>
<li>对于创建规范的表格，简单的查询需求，用起来非常不错</li>
<li>一般不让我们直接写裸SQL，而是类SQL，屏蔽了数据库差异。</li>
</ol>
<p>缺点</p>
<ol>
<li>查询效率优化比较麻烦，JPA的设计思想，就是不要让你去管SQL的事情，而是专注业务</li>
<li>但正是这样，有时候生成的SQL并不是我们想要的</li>
<li>SQL能力不如MyBatis强，比如动态SQL能力。举个例子，JPA中，要做in查询，in中的个数是动态，这样怎么办呢？</li>
</ol>
<h2 id="JPA对比MyBatis"><a href="#JPA对比MyBatis" class="headerlink" title="JPA对比MyBatis"></a>JPA对比MyBatis</h2><p>下面这个回答比较中肯。两句话概括</p>
<ul>
<li>JPA面向对象，让用户不要去管SQL的事情。使用友好，但SQL优化不大行。</li>
<li>MyBatis面向SQL，可以直接写SQL。但跨数据源能力不大行。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/348496459/answer/842120407">SpringData JPA也能写sql，为什么还要用mybatis?</a></p>
<p>如果公司自己做业务，看重性能和优化，用MyBatis比较好，而且现在MyBatis有MybatisPlus，也支持Active Record，一定程度上算是集合了JPA和MyBatis的优势。</p>
<p>但如果公司的卖代码的，跨数据库这一点就很重要，使用JPA就很有必要。</p>
<h2 id="个人认为"><a href="#个人认为" class="headerlink" title="个人认为"></a>个人认为</h2><p>我个人的看法，首先，在代码中写复杂SQL这件事，必须PASS，这在呼啦亲子中已经实践过了，是不大可行的。JOOQ的DSL能力尚且不行，那Querydsl的SQL能力肯定是更加不能接受的。</p>
<p>其次，如果使用PG，其中有很多非典型SQL的语法，肯定是要写裸SQL的。但是JPA写裸SQL的能力，肯定是不如MyBatis的。</p>
<p>我也很喜欢JPA，但如果在一个长期维护的项目中使用JPA，很可能出现开始时写得很开心，到后面项目中充斥着大量不符合JPA设计哲学的代码。</p>
<p>所以我会选择MyBatis。</p>
<p>但是。。。如果是自己的小项目，我还是愿意尝试一下JPA。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/27/%E8%81%8A%E4%B8%80%E8%81%8AJava%E7%9A%84%E7%BC%93%E5%AD%98-liao-yi-liao-java-de-huan-cun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/27/%E8%81%8A%E4%B8%80%E8%81%8AJava%E7%9A%84%E7%BC%93%E5%AD%98-liao-yi-liao-java-de-huan-cun/" class="post-title-link" itemprop="url">聊一聊Java的缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-27 20:43:49 / Modified: 20:56:20" itemprop="dateCreated datePublished" datetime="2021-09-27T20:43:49+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文，我们主要聊一下Java中缓存的使用，几个点</p>
<ul>
<li>Java对缓存的抽象——JSR107</li>
<li>Spring对缓存的抽象——Spring Cache</li>
<li>Redis如何集成到Spring中——作为Spring Cache的实现、直接使用RedisCache、使用RedisTemplate</li>
</ul>
</blockquote>
<h2 id="先说点啥"><a href="#先说点啥" class="headerlink" title="先说点啥"></a>先说点啥</h2><p>缓存嘛，都知道是咋回事。常见的缓存如Memcached、Redis、Caffine等，各自也有对应的API。使用它们，直接操作API即可。当然，本文并非讨论各种缓存的API的用法，而是在Java中使用缓存的标准方法。无关具体实现，即，Java中的缓存抽象。</p>
<p>就Java本身而言，有JSR107，专门对缓存定义的抽象；如果使用Spring，则有Spring Cache抽象，二者虽不同，但大体思想一致，且Spring Cache还提供了对JSR107注解的兼容。我们具体来看。</p>
<h2 id="JSR107"><a href="#JSR107" class="headerlink" title="JSR107"></a>JSR107</h2><p>JSR107是Java针对缓存所定的规范，旨在让Java程序员以最低的学习成本学会缓存的使用。有兴趣可阅读<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit">规范原文</a>。<br>简单来讲，它包含几个方面</p>
<ul>
<li>一套核心接口，用于编程式缓存</li>
<li>一套注解，用于声明式缓存</li>
<li>其它</li>
</ul>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><p>定义了如下五个核心接口，也就是说，如果要定义自己的缓存实现，实现这些接口即可。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CachingProvider</td>
<td>用于管理CacheManager</td>
</tr>
<tr>
<td>CacheManager</td>
<td>用于管理Cache，具体来说，它的作用有<br />- 创建、配置具有特定名称的Cache，配置通过xxxConfiguration类实现<br />- 根据名称获取Cache<br />- 关闭Cache<br />- 销毁Cache及其中的内容<br />- 关闭自己及所管理的Cache<br />- 提供Cache的统计信息<br />- 获取CachingProvider中特定的属性</td>
</tr>
<tr>
<td>Cache</td>
<td>类似Map的数据结构，用于存储键值对，存储的是Entry<br />用于获取、更新、移除这些键值对</td>
</tr>
<tr>
<td>Entry</td>
<td>即一个单独的键值对，存储于Cache中</td>
</tr>
<tr>
<td>ExpiryPolicy</td>
<td>过期策略</td>
</tr>
</tbody></table>
<p>它们之间的关系，用一个图来表示的话（我在网上偷了一张图）。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210925225220620.png" alt="image-20210925225220620"></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>定义了几个核心注解，Spring兼容的，就是这几个注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CacheDefaults</td>
<td>类级别注解。用于设置应用于整个类的属性<br />- 缓存名<br />- 缓存解析器<br />- key生成器</td>
</tr>
<tr>
<td>CacheResult</td>
<td>方法级别注解。表明该方法的返回值将被缓存<br />- 缓存key由方法参数参与生成<br />- 下次调用将优先取缓存中的值</td>
</tr>
<tr>
<td>CachePut</td>
<td>方法级别注解。表明该方法的某个参数将被写入缓存<br />- 目标参数必须用@CacheValue标注，否则会报错</td>
</tr>
<tr>
<td>CacheRemove</td>
<td>方法级别注解。表明方法调用结果对应的缓存entry将被删除，通过key匹配</td>
</tr>
<tr>
<td>CacheRemoveAll</td>
<td>方法级别注解。表明将删除所有匹配的entry，通过value匹配，value满足条件就会被删除</td>
</tr>
</tbody></table>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>下面这些不是该标准的主要内容，但我认为有参考价值，特拿出来讲讲。</p>
<h4 id="Cache和Map的不同"><a href="#Cache和Map的不同" class="headerlink" title="Cache和Map的不同"></a>Cache和Map的不同</h4><p>从API长相来看，Cache和Map大差不差，有很多相似之处，但这里只关注不同点。</p>
<ul>
<li>Cache的key和value都不能为null</li>
<li>Cache的key和value需要支持序列化和反序列化</li>
<li>Cache的entry可以过期</li>
<li>Cache的entry可能因为某种策略被驱逐</li>
<li>Cache支持CAS操作</li>
<li>Cache可以按值存储，也可以按引用存储</li>
</ul>
<blockquote>
<p>注意，这里的不同，仅限于JSR107的定义，在别处不一定是这样</p>
</blockquote>
<h4 id="缓存值还是引用"><a href="#缓存值还是引用" class="headerlink" title="缓存值还是引用"></a>缓存值还是引用</h4><p>这是一个问题。我们常用Redis，它缓存的肯定是值嘛，缓存值时就涉及到序列化问题；但还有一种选择是缓存引用，这在本机的堆缓存是比较有用的，我们不一定能够用到，但要知道还有缓存引用这种方式。</p>
<h4 id="一致性考量"><a href="#一致性考量" class="headerlink" title="一致性考量"></a>一致性考量</h4><p>同上，日常调用时可能不大会用，但要知道。</p>
<p>一致性，指的是并发操作缓存时，缓存所表现出的样子。JSR107定义了三种一致性结果。</p>
<ul>
<li>happen-before：即悲观锁，各个线程依顺序获取锁</li>
<li>last value：无锁，各线程并发调用缓存，但是以最后一个操作成功的线程的结果为准</li>
<li>CAS：乐观锁，即满足给定条件才执行</li>
</ul>
<p>这三种一致性结果应用于不同的API，我们这里大致列一下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210926090210075.png" alt="image-20210926090210075"></p>
<h4 id="哪些没讲"><a href="#哪些没讲" class="headerlink" title="哪些没讲"></a>哪些没讲</h4><p>JSR107涉及到方方面面，当然还有没讲到的，这部分可以直接去看官方手册，列一下。</p>
<ul>
<li>缓存的类型安全保证：分为编译器类型安全和运行时类型安全。前者通过泛型保证，后者通过传入类对象在运行时校验保证</li>
<li>分布式缓存的实现方式：涉及到一系列缓存事件和事件监听器</li>
<li>缓存过期策略：按照缓存创建、访问等时间<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210926091050637.png" alt="image-20210926091050637"></li>
</ul>
<h3 id="哪些缓存实现了JSR107"><a href="#哪些缓存实现了JSR107" class="headerlink" title="哪些缓存实现了JSR107"></a>哪些缓存实现了JSR107</h3><p>说是Java标准，但并非所有库都支持，我们大致看一下。</p>
<table>
<thead>
<tr>
<th>库</th>
<th>支持与否</th>
</tr>
</thead>
<tbody><tr>
<td>Caffeine</td>
<td>支持</td>
</tr>
<tr>
<td>Lettuce</td>
<td>不支持，但可以通过Spring Data变相部分支持</td>
</tr>
<tr>
<td>Jedis</td>
<td>不支持，但可以通过Spring Data变相部分支持</td>
</tr>
<tr>
<td>Hazalcast</td>
<td>支持</td>
</tr>
</tbody></table>
<blockquote>
<p>注：这里说的变相支持，是因为Spring Data底层使用了lettuce或jedis，而Spring Data Cache支持JSR107的注解，因此可以说是部分兼容了。</p>
</blockquote>
<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>在介绍篇幅上，读者很容易被Spring手册骗了，因为它花了大量篇幅在注解及其功能的介绍上，即更多地关注声明式的使用方式，弱化了编程式的使用方式。其实后者也是可以使用的。</p>
<p>就缓存抽象本身，无论从定义的内容，还是关注的点，和JSR107是差不多的。</p>
<ul>
<li>一套核心接口</li>
<li>一套注解</li>
<li>扩展功能和一致性考量等</li>
</ul>
<h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><table>
<thead>
<tr>
<th>Spring注解</th>
<th>说明</th>
<th>对应JSR107注解</th>
</tr>
</thead>
<tbody><tr>
<td>Cacheable</td>
<td>将调用结果作为缓存，且下次调用时直接取缓存</td>
<td>CacheResult</td>
</tr>
<tr>
<td>CacheEvict</td>
<td>缓存驱逐，如果加上allEntries，则是驱逐value值匹配到的所有条目</td>
<td>CacheRemove/CacheRemoveAll</td>
</tr>
<tr>
<td>CachePut</td>
<td>将方法的执行结果放入缓存</td>
<td>CachePut</td>
</tr>
<tr>
<td>Caching</td>
<td>一个大的调用，Caching内部可以使用上面那三个注解</td>
<td></td>
</tr>
<tr>
<td>CacheConfig</td>
<td>针对整个类的配置</td>
<td>CacheDefaults</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，这些注解在语义上和JSR107可以说是一一对应，但在实际使用方式上其实是不同的，比如CachePut，Spring是将方法的执行结果放入缓存，而JSR107是将带有@CacheValue的参数放入缓存。</p>
</blockquote>
<p>Spring Cache兼容JSR107的注解，即，直接使用JSR107的注解，在Spring环境中依然能够正常工作。</p>
<h3 id="核心接口-1"><a href="#核心接口-1" class="headerlink" title="核心接口"></a>核心接口</h3><p>Spring文档开头，指出了实现缓存抽象的关键接口</p>
<ul>
<li>org.springframework.cache.Cache：缓存，实际执行缓存操作的接口</li>
<li>org.springframework.cache.CacheManager：缓存管理器，管理Cache实例</li>
</ul>
<p>如果要为Spring的缓存抽象适配缓存实现，只需要实现这两个接口。比如Redis，有RedisCache和RedisCacheManager实现，使用时只需创建RedisCacheManager并注入容器，其它的就不用管了，RedisCacheManager会为我们创建并管理RedisCache。</p>
<p>具体使用方法，后文会有详细描述。</p>
<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><ul>
<li>自定义key：可通过注解的key属性+SPEL表达式，还有，keyGenerator属性这两种方式自定义key</li>
<li>同步缓存：通过sync属性指定。这一点对应JSR107的一致性考量</li>
<li>条件缓存：通过condition或unless属性+SPEL表达式指定缓存条件，即什么情况下使用缓存，什么情况下不使用缓存</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>两相对比，Spring Cache简单不少，毕竟只有两个接口。日常使用较多的还是Spring Cache，JSR107仅作了解。</p>
<h2 id="Spring中使用Redis"><a href="#Spring中使用Redis" class="headerlink" title="Spring中使用Redis"></a>Spring中使用Redis</h2><p>现在来用用看。假设使用场景：一个简单的视频系统——两张表，如下：</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210927185529108.png" alt="undefined"></p>
<p>video表存储视频的描述信息，如标题、描述、封面地址等；video_play_info存储视频播放地址和来源，他们是一对多的关系。</p>
<p>考虑到这里重缓存的演示，一切从简，数据库使用HashMap模拟；路由层去除，直接在单元测试中调用。于是，总共就这么几个类：配置、数据定义、数据操作、逻辑操作、一些全局变量、Spring Boot启动类。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210927151957978.png" alt="undefined"></p>
<p>数据定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> videoId: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> description: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coverUrl: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPlayInfo</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: String,</span><br><span class="line">    <span class="keyword">val</span> videoId: String,</span><br><span class="line">    <span class="keyword">val</span> playUrl: String,</span><br><span class="line">    <span class="keyword">val</span> source: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>repo操作接口，稍后需要在它的实现类添加缓存支持。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">VideoRelatedRepo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addVideo</span><span class="params">(video: <span class="type">Video</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateVideo</span><span class="params">(video: <span class="type">Video</span>)</span></span>: Video</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addVideoPlayInfo</span><span class="params">(videoPlayInfo: <span class="type">VideoPlayInfo</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listVideoPlayInfo</span><span class="params">(videoIds: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;VideoPlayInfo&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateVideoPlayInfo</span><span class="params">(videoPlayInfo: <span class="type">VideoPlayInfo</span>)</span></span>: VideoPlayInfo</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteVideoPlayInfo</span><span class="params">(id: <span class="type">String</span>)</span></span>: VideoPlayInfo</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们结合实际代码，解读使用方式。</p>
<h3 id="使用前配置"><a href="#使用前配置" class="headerlink" title="使用前配置"></a>使用前配置</h3><p>如前所说，为Spring Cache提供实现，只需要实现CacheManager和Cache接口，而由于Cache实例实际由CacheManager创建和管理，因此在配置时只需提供CacheManager，对于Redis，引入Spring-Data-Redis后，在配置类中创建RedisCacheManger。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里我们提供一个超级简单的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_NAME_VIDEO = <span class="string">&quot;VIDEO&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_NAME_PLAY_INFO = <span class="string">&quot;PLAY_INFO&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_PREFIX = <span class="string">&quot;SPRING_DEMO_VIDEO&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_EXPIRE_DAYS = <span class="number">1L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cacheManager</span><span class="params">(connectionFactory: <span class="type">RedisConnectionFactory</span>)</span></span>: RedisCacheManager &#123;</span><br><span class="line">        <span class="keyword">val</span> objectMapper = jacksonObjectMapper().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.EVERYTHING,</span><br><span class="line">                JsonTypeInfo.As.PROPERTY</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> valueSerializer = GenericJackson2JsonRedisSerializer(objectMapper)</span><br><span class="line">        <span class="keyword">val</span> shareConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .entryTtl(Duration.ofDays(REDIS_CACHE_EXPIRE_DAYS))</span><br><span class="line">            .disableCachingNullValues()</span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.string()))</span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer))</span><br><span class="line">            .computePrefixWith &#123; cacheName -&gt; <span class="string">&quot;<span class="subst">$&#123;REDIS_CACHE_PREFIX&#125;</span><span class="subst">$&#123;CacheKeyPrefix.SEPARATOR&#125;</span><span class="subst">$&#123;cacheName&#125;</span><span class="subst">$&#123;CacheKeyPrefix.SEPARATOR&#125;</span>&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager</span><br><span class="line">            .builder(connectionFactory)</span><br><span class="line">            .withCacheConfiguration(REDIS_CACHE_NAME_VIDEO, shareConfiguration)</span><br><span class="line">            .withCacheConfiguration(REDIS_CACHE_NAME_PLAY_INFO, shareConfiguration)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做几点说明</p>
<ol>
<li>需要提供RedisConnectionFactory，即连接信息。如果在配置文件配过了，则直接注入即可；或者直接创建RedisConnectionFactory的bean也可。</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">120.78.147.168</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">16379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">test123</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">2000</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建Manager时需要同时提供针对缓存的配置，可以针对特定名的Cache配置，也可以提供针对所有名字的Cache配置。上面，分别为名为video和videoPlayInfo的缓存实例，提供配置。配置类是RedisCacheConfiguration。</li>
<li>RedisCacheConfiguration配置能力如下</li>
</ol>
<ul>
<li><p>TTL</p>
</li>
<li><p>是否缓存null值，这里是指value为null，且缓存null时也并非真的写入一个null进去，而是使用替代对象，如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> byte[] BINARY_NULL_VALUE = RedisSerializer.java().serialize(NullValue.INSTANCE);</span><br></pre></td></tr></table></figure></li>
<li><p>key的前缀，这个最最常用。因为我们往往是多个系统共用一个Redis DB，难免会有key冲突的情况，为每个系统设置自己的前缀，可以避免这个问题。<br>有三种方式提供前缀</p>
</li>
<li><p>写死的字符串</p>
</li>
<li><p>CachePrefix对象</p>
</li>
<li><p>lambda表达式</p>
<p>这里使用了lambda表达式，使得固定前缀为SPRING_DEMO_VIDEO::VIDEO::。其中”::”分隔符来自CachePrefix的常量。</p>
</li>
<li><p>针对key和value的序列化对，即序列化和反序列化器，这个比较常用，如果对序列化有特殊需求，就要配置它们</p>
<p>我们要将对象序列化为json，因此有所自定义，序列化器这点，在下文的“问题”中有所描述。</p>
</li>
<li><p>类型转换器，用的是Spring Core的ConversionService</p>
</li>
</ul>
<p><strong>关于缓存名</strong></p>
<p>问：cache name，即缓存的名字，会发现它无处不在：获取缓存实例时需要、配置缓存时需要、使用注解时也需要。该怎么理解它？</p>
<p>答：它，就是用来区分Cache实例的，一个CacheManager，可以管理多个Cache实例，使用name区分。</p>
<p><strong>关于Cache实例</strong></p>
<p>问：Cache这个接口，及其实例，存在的必要是什么？与缓存连接有什么关系？多个Cache实例之间是什么关系？Cache实例创建几个比较好？</p>
<p>答：这些问题，可以结合Cache接口和RedisCache实现来看。</p>
<p>看Cache接口，它只是提供了缓存的抽象，上面我们说过，Cache和Map很像，Cache接口就用于提供缓存的基本操作的；</p>
<p>再看RedisCache，其主要包含的四个属性。其中CacheWriter中包含了RedisConnectionFactory，是共享的；RedisCacheConfiguration、ConversionService是独享的。可以看出，RedisCache只是为不同场景持有不同的配置提供了方便，即，一个项目，多套配置，使用name区分。比如对用户的缓存需要ttl为1天，对session的缓存只要一小时，这就形成了两套配置需求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RedisCacheWriter cacheWriter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RedisCacheConfiguration cacheConfig;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br></pre></td></tr></table></figure>

<p>针对上面的问题：</p>
<ul>
<li><p>Cache存在的必要</p>
<p>就是缓存的抽象而已。</p>
</li>
<li><p>与Redis的连接关系</p>
<p>没有关系，不管多少个Cache实例，他们共用一个RedisConnectionFactory，连接池共享。</p>
</li>
<li><p>多个Cache实例之间的关系</p>
<p>共享连接池；独享缓存配置。</p>
</li>
<li><p>Cache实例创建几个</p>
<p>依据情况而定，有几个缓存场景就可以创建多少个Cache实例，不会影响性能</p>
</li>
</ul>
<h3 id="声明式缓存-—-注解"><a href="#声明式缓存-—-注解" class="headerlink" title="声明式缓存 — 注解"></a>声明式缓存 — 注解</h3><p>大部分情况，都可以用注解解决问题，在获取单个对象时创建缓存，在更新时更新缓存，在删除时驱逐缓存。下面是对video对象操作的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRelatedRepoImpl</span></span>(cacheManager: CacheManager) : VideoRelatedRepo &#123;</span><br><span class="line"> </span><br><span class="line">  ... ...</span><br><span class="line">  <span class="meta">@Cacheable(cacheNames = [REDIS_CACHE_NAME_VIDEO], key = <span class="meta-string">&quot;#id&quot;</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;通过数据库获取值&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> videoDB[id] <span class="keyword">as</span> Video</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CachePut(cacheNames = [REDIS_CACHE_NAME_VIDEO], key = <span class="meta-string">&quot;#video.id&quot;</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateVideo</span><span class="params">(video: <span class="type">Video</span>)</span></span>: Video &#123;</span><br><span class="line">    videoDB[video.id] = video</span><br><span class="line">    <span class="keyword">return</span> videoDB[video.id] <span class="keyword">as</span> Video</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CacheEvict(cacheNames = [REDIS_CACHE_NAME_VIDEO], key = <span class="meta-string">&quot;#id&quot;</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video &#123;</span><br><span class="line">    <span class="keyword">return</span> videoDB.remove(id) <span class="keyword">as</span> Video</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程式缓存-—-RedisCache"><a href="#编程式缓存-—-RedisCache" class="headerlink" title="编程式缓存 — RedisCache"></a>编程式缓存 — RedisCache</h3><p>本例有一个特殊场景，根据videoId批量获取播放信息，由于播放信息可能随时变化，因此缓存单个播放信息比较科学，这就需要部分从缓存中取，部分从数据库中取。此时注解无能为力。需要直接使用RedisCache操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRelatedRepoImpl</span></span>(cacheManager: CacheManager) : VideoRelatedRepo &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取Cache对象的方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> videoPlayInfoCache = cacheManager.getCache(REDIS_CACHE_NAME_PLAY_INFO)!!</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">listVideoPlayInfo</span><span class="params">(videoIds: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;VideoPlayInfo&gt; &#123;</span><br><span class="line">    <span class="comment">// 读取对应关系</span></span><br><span class="line">    <span class="keyword">val</span> playInfoIds = selectIdByVideoIds(videoIds)</span><br><span class="line">    <span class="comment">// 先从缓存获取</span></span><br><span class="line">    <span class="keyword">val</span> infosInCache = playInfoIds.mapNotNull &#123; videoPlayInfoCache.<span class="keyword">get</span>(it, VideoPlayInfo::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">    <span class="keyword">val</span> infoIdsInDB = playInfoIds.filterNot &#123; id -&gt; infosInCache.any &#123; it.id == id &#125; &#125;</span><br><span class="line">    <span class="comment">// 再从数据库获取</span></span><br><span class="line">    <span class="keyword">val</span> infosInDB = videoPlayInfoDB.multiGet(infoIdsInDB).map &#123; it <span class="keyword">as</span> VideoPlayInfo &#125;</span><br><span class="line">    <span class="comment">// 再写入缓存</span></span><br><span class="line">    infosInDB.forEach &#123; videoPlayInfoCache.put(it.id, it) &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;通过缓存获取了<span class="subst">$&#123;infosInCache.size&#125;</span>; 通过数据库获取了<span class="subst">$&#123;infosInDB.size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> infosInCache + infosInDB</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RedisTemplate怎么说"><a href="#RedisTemplate怎么说" class="headerlink" title="RedisTemplate怎么说"></a>RedisTemplate怎么说</h3><p>这算乱入了，RedisTemplate和缓存抽象半毛钱关系没有。它只是一个Redis客户端，关于它的使用方式，官方手册也有说明。这里就不说了。</p>
<p>倒是值得分清楚几个问题</p>
<p><strong>分清楚RedisTemplate和CacheManager</strong></p>
<p>我好奇过：为啥配置了CacheManager，还要配置一遍RedisTemplate？</p>
<p>因为它们根本就没关系呀，前者是Spring Cache抽象的一部分；后者是Redis客户端。谁也不包含谁，当然要分开配置。</p>
<p><strong>分清楚RedisCache和RedisTemplate</strong></p>
<p>他俩没关系，前者只是缓存抽象的实现，功能简单，顶多不过put数据、驱逐数据等缓存常规操作；后者是<strong>全功能</strong>Redis客户端。</p>
<p><strong>RedisTemplate强滴很</strong></p>
<p>翻翻看RedisTemplate源码，可以看到它包含了Redis的几乎所有操作，三个字：强滴很。</p>
<p><strong>啥时候用RedisTemplate</strong></p>
<p>它强是强，但用起来也复杂呀，并且能统一设置前缀、过期时间等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().<span class="keyword">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, Duration.ofHours(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>因此，在只有缓存需求时，使用Cache抽象最方便，有额外需求时，才考虑使用RedisTemplate。</p>
<h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><p>上面展示的配置是最终版，但中间是有遇到问题的</p>
<ul>
<li><p>序列化问题：DefaultSerializer requires a Serializable payload but received an object of type [xxx.VideoPlayInfo]</p>
<p>首先，前面提到过我们可以指定key和value的序列化器和反序列化器，如果我们不指定，就会使用DefaultSerializer，而它是要求目标类实现Serializable接口的，然后，我们并没有实现该接口。</p>
<p>解决方案1：为目标类实现Serializable接口，尝试过，这样是OK的。</p>
<p>解决方案2：换一个序列化和反序列化器，我们使用RedisSerializer.json()得到一个json序列化器</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置片段</span></span><br><span class="line">.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.json()))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>反序列化问题：Could not read JSON: Could not resolve subtype of [simple type, class java.lang.Object]: missing type id property ‘@class’</p>
<p>对象序列化成JSON写入Redis了，读出来却无法转回目标对象。因为少了@class属性。所以这里还少了一点配置。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> objectMapper = jacksonObjectMapper().apply &#123;</span><br><span class="line">  <span class="comment">// 管家配置</span></span><br><span class="line">  <span class="keyword">this</span>.activateDefaultTyping(</span><br><span class="line">    LaissezFaireSubTypeValidator.instance,</span><br><span class="line">    ObjectMapper.DefaultTyping.EVERYTHING,</span><br><span class="line">    JsonTypeInfo.As.PROPERTY</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> valueSerializer = GenericJackson2JsonRedisSerializer(objectMapper)</span><br><span class="line"><span class="comment">// 配置片段</span></span><br><span class="line">.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer))</span><br></pre></td></tr></table></figure>

<h2 id="这里有个Demo"><a href="#这里有个Demo" class="headerlink" title="这里有个Demo"></a>这里有个Demo</h2><p>说是这么说，写是这么写，上面的内容，构建了一个可运行的项目，忘了的时候，可以来看看。</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/zou8944/spring-me/tree/master/spring-cache">&lt;我就是那个项目&gt;</a></p>
<blockquote>
<p>注意，我们没有使用数据库，因此在启动SpringBoot时要排除数据源</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = [DataSourceAutoConfiguration::class, HibernateJpaAutoConfiguration::class])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringMeApplication</span></span></span><br></pre></td></tr></table></figure>

<p>运行项目的单元测试，可以观察到缓存内容，如下图展示：一个视频信息、两个播放信息，注意观察key的组成和存储值的格式。<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210927203046805.png" alt="undefined"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit">JSR107</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/cache.html">Spring Cache Abstraction</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/2.5.5/reference/html/#reference">Spring Data Redis</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/16/Spring%20STOMP%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E5%8C%BA%E5%88%86%E5%AE%A2%E6%88%B7%E7%AB%AF-springstomp-fa-song-xiao-xi-shi-qu-fen-ke-hu-duan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/16/Spring%20STOMP%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E5%8C%BA%E5%88%86%E5%AE%A2%E6%88%B7%E7%AB%AF-springstomp-fa-song-xiao-xi-shi-qu-fen-ke-hu-duan/" class="post-title-link" itemprop="url">Spring STOMP发送消息时区分客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-16 18:51:53" itemprop="dateCreated datePublished" datetime="2021-09-16T18:51:53+08:00">2021-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现有使用Spring WebSocket库搭建的STOMP通知中心，使用Spring自带功能，能够区分到用户，向来自同一用户的多个连接（会话）广播数据。</p>
<p>这正是我们的使用场景：当用户调用服务端指定接口时，服务端向该用户所在的所有用户发送通知。</p>
<p>现有的配置，在WebSocket握手阶段验证TOKEN，解析成用户ID，存入WebSession；在接口访问时带上TOKEN，再通过SimpMessagingTemplate.convertAndSendToUser()向该用户进行广播。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li><p>X-GD-UID：客户端提供设备识别码的请求头名</p>
</li>
<li><p>X-GD-TOKEN：客户端提供TOKEN的请求头名</p>
</li>
<li><p>uid：设备识别码在服务端内部的流转名</p>
</li>
<li><p>deviceId：设备识别码在服务端内部的流转名</p>
</li>
<li><p>user：用户在服务端内部的流转名</p>
</li>
<li><p>WebSocketSession：WebSocket的Session，一般来说，一个WebSocket连接对应一个Session。该session对应的sessionId，单个服务器</p>
</li>
<li><p>STOMP Session：STOMP的Session，和WebSession等价。源码中，将来自WebSocket的消息包装成STOMP消息，可以直接看到二者的设置关系：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromClient</span><span class="params">(WebSocketSession session,...)</span> </span>&#123;</span><br><span class="line">	... ...</span><br><span class="line">	headerAccessor.setSessionId(session.getId());</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="优化需求"><a href="#优化需求" class="headerlink" title="优化需求"></a>优化需求</h2><p>按照上面的方式，对一个用户广播，会通知到所有设备，即使该设备是通知触发方。逻辑上讲，通知触发方是不应该收到通知的。这正是我们需要实现的需求。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="设备识别"><a href="#设备识别" class="headerlink" title="设备识别"></a>设备识别</h3><p>当前只能通过TOKEN识别用户。但没有识别设备的方式，我们可能有两种</p>
<ul>
<li>IP地址：不可取。网络环境复杂，经过层层转发，我们不一定能保证获取到稳定的IP地址；即时能够获取到，因为SNAT的存在，对处在同一局域网下的多台设备，也不一定能够区分。</li>
<li>设备识别码：取客户端设备的唯一识别码，这是最保险的方法。但根据“客户端不可信原则”。userId+设备识别码才是理论上最靠谱的方式。</li>
</ul>
<h3 id="放在哪"><a href="#放在哪" class="headerlink" title="放在哪"></a>放在哪</h3><p>设备识别码这个参数，比较中性，可以在其他业务上用，因此放在头部比较合适，暂定X-GD-UID。客户端所有请求，都带上该头部。</p>
<h3 id="服务端方案"><a href="#服务端方案" class="headerlink" title="服务端方案"></a>服务端方案</h3><ol>
<li>WebSocket握手时，解析user和uid，放入WebSocketSession。该WebSocketSession会在后面的每次交互中带上此两个参数。</li>
<li>在STOMP进行CONNECT时，我们能够在入方向的拦截器中获取到上一步存放的user、uid，以及新建的STOMP session，我们将他们缓存起来，以便后面使用。</li>
<li>发送STOMP通知时，指定要忽略哪个uid，我们能够在出方向上的拦截器中拦截该消息，如果发现当前通知即将发送的目标设备和指定的uid匹配，则拦截掉该通知。</li>
<li>连接断开时，清除缓存</li>
</ol>
<h3 id="缓存放哪"><a href="#缓存放哪" class="headerlink" title="缓存放哪"></a>缓存放哪</h3><p>三个地方备选，综合来看，放在Redis是比较好的选择。不过需要小心的是Redis的重启</p>
<ul>
<li>本地：多实例时会出问题</li>
<li>Redis：Redis数据库本身的声明周期和项目不一致，有可能在项目运行到一半时关闭</li>
<li>数据库：生命周期大于项目，是理论上最安全的位置，但访问速度可能会比较慢</li>
</ul>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>全流程配置忽略，这里只说关键部分的代码。我们将与当前功能相关的逻辑都放在一个类中，如下。本节其它小节将会直接引用该类中的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> redisTemplate: StringRedisTemplate) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeSession</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">        SimpMessageHeaderAccessor.getSessionId(message.headers)?.let &#123;</span><br><span class="line">            redisTemplate.delete(it.toRedisKey())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deviceBindInterceptor</span><span class="params">()</span></span> = <span class="keyword">object</span> : ChannelInterceptor &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preSend</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;, channel: <span class="type">MessageChannel</span>)</span></span>: Message&lt;*&gt; &#123;</span><br><span class="line">            <span class="comment">// 连接时记录deviceId和当前session的关系</span></span><br><span class="line">            <span class="keyword">val</span> accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (accessor != <span class="literal">null</span> &amp;&amp; StompCommand.CONNECT == accessor.command) &#123;</span><br><span class="line">                <span class="keyword">val</span> user = accessor.user ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> deviceId = accessor.sessionAttributes?.<span class="keyword">get</span>(DEVICE_ID_ATTRIBUTE)?.toString() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> sessionId = accessor.sessionId!!</span><br><span class="line">                redisTemplate.opsForValue().<span class="keyword">set</span>(sessionId.toRedisKey(), genDeviceValue(user.name, deviceId))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deviceIgnoreInterceptor</span><span class="params">()</span></span> = <span class="keyword">object</span> : ChannelInterceptor &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preSend</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;, channel: <span class="type">MessageChannel</span>)</span></span>: Message&lt;*&gt;? &#123;</span><br><span class="line">            <span class="comment">// 发送时滤除指定deviceId的sessionID</span></span><br><span class="line">            <span class="keyword">val</span> accessor = MessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (accessor != <span class="literal">null</span> &amp;&amp; SimpMessageType.MESSAGE == accessor.messageType) &#123;</span><br><span class="line">                <span class="keyword">val</span> username = accessor.removeNativeHeader(USER_ATTRIBUTE)?.singleOrNull() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> ignoreDeviceId = accessor.removeNativeHeader(DEVICE_ID_ATTRIBUTE)?.singleOrNull() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> deviceValueOfMessage = redisTemplate.opsForValue().<span class="keyword">get</span>(accessor.sessionId!!.toRedisKey()) ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">if</span> (deviceValueOfMessage == genDeviceValue(username, ignoreDeviceId)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">genDeviceValue</span><span class="params">(username: <span class="type">String</span>, deviceId: <span class="type">String</span>)</span></span>: String = <span class="string">&quot;<span class="subst">$&#123;username&#125;</span>-<span class="variable">$deviceId</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">toRedisKey</span><span class="params">()</span></span> = <span class="string">&quot;MYLOGS_WEBSOCKET_DEVICE_<span class="variable">$this</span>&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UID解析"><a href="#UID解析" class="headerlink" title="UID解析"></a>UID解析</h3><p>握手拦截器中解析UID</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> class <span class="title">AuthHandshakeInterceptor</span><span class="params">(val objectMapper: ObjectMapper)</span> : HandshakeInterceptor </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">beforeHandshake</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        request: ServerHttpRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">        response: ServerHttpResponse,</span></span></span><br><span class="line"><span class="params"><span class="function">        wsHandler: WebSocketHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">        attributes: MutableMap&lt;String, Any&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span>: Boolean </span>&#123;</span><br><span class="line">        val user = request.parseUser(objectMapper)</span><br><span class="line">        val deviceId = request.parseDeviceId()</span><br><span class="line">				... ...</span><br><span class="line">        <span class="keyword">if</span> (deviceId != <span class="keyword">null</span>) attributes[DEVICE_ID_ATTRIBUTE] = deviceId</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展方法，从头部或query中取X-GD-UID</span></span><br><span class="line">fun ServerHttpRequest.parseDeviceId(): String? &#123;</span><br><span class="line">    val deviceIdInHeader = <span class="keyword">this</span>.headers[DEVICE_UID_HEADER]?.firstOrNull()</span><br><span class="line">    val deviceIdInQuery = lazy &#123; <span class="keyword">this</span>.uri.query?.split(<span class="string">&quot;&amp;&quot;</span>)?.find &#123; it.contains(DEVICE_UID_HEADER) &#125;?.split(<span class="string">&quot;=&quot;</span>)?.last() &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceIdInHeader ?: deviceIdInQuery.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UID缓存"><a href="#UID缓存" class="headerlink" title="UID缓存"></a>UID缓存</h3><p>入方向上的拦截器，取出user、uid、sessionId，放入Redis。参见DeviceHolder.deviceBindInterceptor()。</p>
<h3 id="信息拦截"><a href="#信息拦截" class="headerlink" title="信息拦截"></a>信息拦截</h3><p>出方向上的拦截器，缓存匹配，则忽略。参见DeviceHolder.deviceIgnoreInterceptor()。</p>
<h3 id="连接断开处理"><a href="#连接断开处理" class="headerlink" title="连接断开处理"></a>连接断开处理</h3><p>当STOMP连接或WebSocket连接断开时，会发送SessionDisconnectEvent事件，我们监听该事件，在连接断开时主动清理掉内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisconnectEventListener</span>(</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">val</span> <span class="title">deviceHolder</span>: <span class="title">DeviceHolder</span></span></span><br><span class="line"><span class="class">) : <span class="title">ApplicationListener</span>&lt;<span class="title">SessionDisconnectEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onApplicationEvent</span><span class="params">(event: SessionDisconnectEvent)</span> </span>&#123;</span><br><span class="line">        deviceHolder.removeSession(event.message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方"><a href="#使用方" class="headerlink" title="使用方"></a>使用方</h3><p>使用方需传入用户名、目标地址、要忽略的设备ID、要发送的消息等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SimpMessagingTemplate.<span class="title">notifyUserWithoutDevice</span><span class="params">(userId: <span class="type">Int</span>, deviceId: <span class="type">String</span>?, maxUsn: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User.fromId(userId)</span><br><span class="line">    <span class="keyword">this</span>.convertAndSendToUser(</span><br><span class="line">				<span class="comment">// 用户名</span></span><br><span class="line">        user.name,</span><br><span class="line">				<span class="comment">// 用户地址</span></span><br><span class="line">        STOMP_USER_PULL_NOTIFICATION_TOPIC,</span><br><span class="line">				<span class="comment">// 发送的消息体</span></span><br><span class="line">        PullNotify(maxUsn),</span><br><span class="line">				<span class="comment">// 附带的额外属性。很重要，正是它们携带了用户名、设备id到出方向上的拦截器</span></span><br><span class="line">        mapOf(</span><br><span class="line">            DEVICE_ID_ATTRIBUTE to deviceId,</span><br><span class="line">            USER_ATTRIBUTE to user.name</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>Spring WebSocket为我们提供的参与消息收发的方式主要有握手拦截器、握手处理器、STOMP消息入方向上的拦截器、STOMP消息出方向上的拦截器，正是利用这些特性，我们猜完成了设备识别这一需求</li>
<li>出方向的拦截器无法获取到消息所属用户，因此这里我们在用SimpMessagingTemplate发送消息时将用户放进头中，再在拦截器中取出。这种方式，并不优雅</li>
<li>单实例上的SessionId不会重复，但是多实例之间的SessionId是理论上是可能重复的，此时会存在bug。即一台实例上的session覆盖了另一台实例的缓存，造成有效缓存丢失的情况。有两个解决方案<ul>
<li>保证SessionId绝对不同</li>
<li>存储user-deviceId-sessionId三层结构，这样理论上不会出问题，毕竟同一个用户，在同一台机器上出现一样的sessionId的情况，理论上就不可能出现</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/12/HTTP2%E9%87%8D%E7%82%B9PICK-http2-zhong-dian-pick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/12/HTTP2%E9%87%8D%E7%82%B9PICK-http2-zhong-dian-pick/" class="post-title-link" itemprop="url">HTTP2重点PICK</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-12 23:59:01" itemprop="dateCreated datePublished" datetime="2021-09-12T23:59:01+08:00">2021-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">网络基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>花了两天时间读完HTTP2的<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7540.txt.pdf">RFC</a>，揭开HTTP2的神秘面纱，驱散心中迷雾，它比HTTP1.1，到底改变了什么。</p>
</blockquote>
<h2 id="这是一篇什么样的文章"><a href="#这是一篇什么样的文章" class="headerlink" title="这是一篇什么样的文章"></a>这是一篇什么样的文章</h2><p>这是一篇化繁为简的文章，只pick HTTP2中最为关键的部分，忽略细节实现部分。毕竟，每个人读一个文档的目的是不一样的。像我只是想从原理上理解，以便之后使用时能够更加顺畅；而如果是为了实现一个支持HTTP2的库，则需要抠细节，当然花费的时间肯定也不一样，那会是一遍一遍又一遍。</p>
<p>同时我也受够了网上花花绿绿的文章，它们，十之八九，乃基于数篇至数百篇咀嚼过的N手知识，稀碎拼凑而成。看完之后，给人似懂非懂，缺斤少两的感觉。当然，并不是在说人家不好，我也没那个资格，深以为，大家写文章、做总结，其受众非我等小明小红小丽，实为作者自己。认知闭合，学习金字塔，是公共的概念，也是大家的需求。写文章，也算是教授给他人的一种方式。</p>
<p>并不是说我这个文章就比别人的好，那也不见得。文章的好坏与否，取决于本身质量、表述方式等诸多因素。我写这篇文章，也更多是给今后的自己看，于其他人，和网上其它千百文章并无二致。大家并不会因为看了它对HTTP2变得更加了解，这不符合正常的学习曲线。</p>
<p>不过，硬要说的话，我还是可以推荐一篇写得好的HTTP2文章的，详尽，且带有实例讲解，文章基于RFC，同时查阅了很多其他资料，可说是长篇佳作。但它也有缺点，即没有重点，或重点过多。比如HTTP2的优势一节，服务端推送、应用层重置连接、优先级设置、流量控制等，未见得是优势，对理解来说并无关键作用。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903667569541133#heading-59">HTTP2详解</a></p>
<h2 id="HTTP2升级了什么"><a href="#HTTP2升级了什么" class="headerlink" title="HTTP2升级了什么"></a>HTTP2升级了什么</h2><p>HTTP1.x和HTTP1.1有几个主要的问题</p>
<ul>
<li>对同一地址的多次请求，会创建多个TCP连接。HTTP1.0自不必多说，每个请求就会创建一个连接；HTTP1.1虽有所优化，还引入了pipline技术，但也仅仅是将几个请求合并在一个连接，且pipline技术还会有管线头问题，即响应的顺序必须和请求的顺序一致，如果管线中第一个请求阻塞了，会导致同一管线中其它请求的阻塞，即请求之间互相影响了。</li>
<li>HTTP请求头多且重复，浪费带宽。</li>
</ul>
<p>HTTP2的解决方案，也是HTTP2的主要内容，说是所有内容也不为过</p>
<ul>
<li>针对第一个问题，HTTP2提供的解决方案是多路复用，同一地址只会建立一个连接，节省资源；引入Stream和帧，使得不同请求之间完全不干扰，提升传输效率。</li>
<li>针对请求头多的问题，HTTP2使用HPACK压缩算法，压缩掉重复的请求头。</li>
<li>还有一个额外的优化：服务端推送，它使得服务端可以自动发送预加载资源，而不必客户端主动请求。</li>
</ul>
<h2 id="先强调几个点"><a href="#先强调几个点" class="headerlink" title="先强调几个点"></a>先强调几个点</h2><ul>
<li>HTTP2是一个二进制协议，不像HTTP1.x那样是文本协议。</li>
<li>HTTP2的服务端推送，与WebSocket、SSE等完全不一样，只是为了更快地在浏览器和服务器之间传输数据，我们并不能随意操作。</li>
</ul>
<h2 id="HTTP2通信过程"><a href="#HTTP2通信过程" class="headerlink" title="HTTP2通信过程"></a>HTTP2通信过程</h2><p>在语义上，HTTP2继承了绝大部分HTTP1.1的内容，因此在使用时完全感觉不到，浏览器或者我们HTTP库自动做了升级操作，不信看我们的Ingress访问日志，相当一部分请求已经走的HTTP2协议了。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912104305705.png" alt="image-20210912104305705"></p>
<p>总体来说，一个完整的通信过程包括：协议升级 -&gt; 数据分帧 -&gt; 发送 -&gt; 服务端组装帧 -&gt; 服务端逻辑处理并响应 -&gt; 数据分帧 -&gt; 发送 -&gt; 客户端组装帧 -&gt; 处理响应。</p>
<p>可以看到，相对HTTP1.x，多了两类步骤，其它的和之前的协议一样，怪不得我们感受不到。</p>
<ul>
<li>协议升级</li>
<li>数据分帧、合帧等中间操作</li>
</ul>
<h3 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h3><p>还记得WebSocket的升级方式吗？是一样的。</p>
<p>这样的请求</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Connection: Upgrade, HTTP2-Settings</span><br><span class="line">Upgrade: h2c</span><br><span class="line">HTTP2-Settings: <span class="tag">&lt;<span class="name">base64url</span> <span class="attr">encoding</span> <span class="attr">of</span> <span class="attr">HTTP</span>/<span class="attr">2</span> <span class="attr">SETTINGS</span> <span class="attr">payload</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>升级成功就是这样的响应，然后就在同一个TCP连接上快乐地发送数据了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: h2c</span><br></pre></td></tr></table></figure>

<p>请求头说明</p>
<ul>
<li>Upgrade：表明升级的目标是HTTP2协议。h2c是HTTP2从非加密通道升级时的标识符；加密通道则为h2</li>
<li>HTT2-Settings：关于HTTP2传输参数的配置，配置的参数包括请求头索引表大小、并发流的个数等</li>
</ul>
<h3 id="数据分帧、合帧"><a href="#数据分帧、合帧" class="headerlink" title="数据分帧、合帧"></a>数据分帧、合帧</h3><p>HTTP2是二进制帧，而为了兼容当前的HTTP语义，即请求-响应机制，HTTP请求、响应中又包含请求行、头部、body等，这些内容都会被封装成HTTP2的帧进行传输，到远端再重新合并，这里给出一个RFC中对一些请求的分帧示例。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912111358587.png" alt="image-20210912111358587" style="zoom:80%;" />

<p>例子中的POST请求，共被分为三帧。</p>
<ul>
<li>HEADERS帧：将请求的方法、路径、scheme转换为伪头，封装进一个HEADER帧</li>
<li>CONTINUATION帧：这是作为上面那个HEADER的续帧，将请求的头部封装了进来</li>
<li>DATA帧：封装了该请求的请求体中的内容</li>
</ul>
<p>接收方按照分帧的方式进行合帧，就能得到原始数据</p>
<h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><p>表层看，通信过程就如上面讲的那样，但理解HTTP2的关键，要完全了解帧的概念，它是HTTP2数据传输的最小单位；要了解流的概念，它是实现多路复用的最关键技术；要了解头部压缩，它是实现带宽节省的关键技术。此外，还有两个点我忽略掉了，他们并不会给理解带来任何阻碍：流控和流的优先级</p>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>帧在整个协议栈中的位置如下：</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912115557314.png" alt="image-20210912115557314" style="zoom:80%;" />

<p>这就是HTTP2的帧结构，其实挺简单</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912112208591.png" alt="image-20210912112208591" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>字段名</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>帧的载荷长度</td>
</tr>
<tr>
<td>Type</td>
<td>帧类型</td>
</tr>
<tr>
<td>Flags</td>
<td>标记位，不同的帧类型会使用到不同的标记位</td>
</tr>
<tr>
<td>Stream ID</td>
<td>流ID</td>
</tr>
</tbody></table>
<p>帧类型大概有这么多（忽略了流控（WINDOW_UPADTE）和优先级（PRIORITY）两个类型）</p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DATA</td>
<td>数据帧</td>
</tr>
<tr>
<td>HEADERS</td>
<td>头部帧，用于开启一个流</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>作为HEADERS帧的续帧</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>复位帧，用于中止一个流，当流发生错误时发送。<br />用它只会中止流，对连接上的其它流没有影响</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>设置帧，用于在数据发送交流通信参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>服务端推送帧，服务端发往客户端，表明服务端将要有数据推送下来，客户端等着</td>
</tr>
<tr>
<td>PING</td>
<td>注意这不是心跳，而是测量一个请求-响应完成时间的帧</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>整个连接关闭前发送的帧，该帧携带了远端处理成功的最后一个流ID，以便接收方做优雅关闭</td>
</tr>
</tbody></table>
<p>这么多帧，数据相关的帧只有前三种，其它都是控制帧。</p>
<h3 id="多路复用（Stream、Frame）"><a href="#多路复用（Stream、Frame）" class="headerlink" title="多路复用（Stream、Frame）"></a>多路复用（Stream、Frame）</h3><p>三张图对比最原始的HTTP请求响应、pipeline、HTTP多路复用的区别。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912114949108.png" alt="image-20210912114949108" style="zoom:80%;" />

<p>解读</p>
<ul>
<li><p>无pipeline时，一个HTTP请求必须等待上一个请求响应完成后才可进行，完全串行</p>
</li>
<li><p>有pipeline时，请求可以不等待响应直接发送了，但是响应的顺序和请求的顺序必须完全一致。如果第一个请求响应很慢，会阻塞其它两个请求。</p>
<p>这个，顶多相当于批量执行。</p>
</li>
<li><p>多路复用时，与pipeline的区别，是响应之间互不干涉，随便怎么发都行。</p>
</li>
</ul>
<p><strong>怎么理解多路复用</strong></p>
<p>多路：其实指的是请求与响应两路；也可以理解为一个请求响应理解为一路，多个请求连接复用一个连接。</p>
<p>复用：即同一个TCP连接，可以同时传输请求与响应的数据，数据之间互不干扰。这在之前可是不行的哦。</p>
<p><strong>如何实现</strong></p>
<p>多路复用，是帧（Frame）和流（Stream）共同作用的结果。</p>
<ul>
<li>帧有两个作用：一是可以携带额外的控制参数，如流ID；二是拆分数据包</li>
<li>流则是一个逻辑上的抽象：一个TCP连接上所承载的数据，通过流进行逻辑识别。应用到HTTP语义的协议上，一个请求对应一个流，而TCP连接上胡乱交叉的请求与响应的数据帧才能被正确识别，因为有唯一识别符——流ID嘛</li>
</ul>
<p>比如下面这个图，如果stream 3这两帧被服务端处理完后，服务端发送响应，只需要将响应帧的流也标识为stream 3，这样，无乱什么时候发过来，客户端都知道这个响应对应的是原来stream 3发出去的那个请求。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912120902351.png" alt="image-20210912120902351" style="zoom:80%;" />

<p><strong>HTTP1.1为什么不做多路复用</strong></p>
<p>这是交付模型的直接结果，HTTP1.x还是直接的请求-响应模型，如果顺序打乱，将无法在茫茫请求中找到将发送的响应到底属于哪个请求，客户端在接收方也无法区分出收到的这个响应到底是哪个请求发送出去的。而HTTP2不一样，每个请求都被对应一个Stream（流），流有ID，逻辑上只要保证流内部的帧顺序不出错即可，至于响应，无论什么时候，我处理完的请求发送回去只要带流ID即可，客户端知道这个流ID对应的请求是谁。</p>
<p><strong>流多说两点</strong></p>
<p>HTTP2中的流，是一个逻辑概念，即拥有连续帧的抽象。关于流，有几个注意事项</p>
<ul>
<li>一个流内部，帧之间的顺序是绝对的，不然收到之后组装不回去，会报错的</li>
<li>流可以指定优先级，优先级高的流会被优先处理，这在资源有限时会比较有用</li>
</ul>
<h3 id="头部编排和压缩"><a href="#头部编排和压缩" class="headerlink" title="头部编排和压缩"></a>头部编排和压缩</h3><p>HTTP2的HEADERS帧并不直接对应HTTP1.x语义的头部哦，有没有发现HTTP2并没有为请求行和状态行这些HTTP1.x语义的内容留专门的定义，事实上确实没有，因此在进行HTTP1.x数据传输时，需要先做头部编排。</p>
<p>其中最重要的是将请求行编排为<strong>伪头</strong>，以冒号开头，具体来说</p>
<table>
<thead>
<tr>
<th>伪头</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:method</td>
<td>GET</td>
<td>方法</td>
</tr>
<tr>
<td>:scheme</td>
<td>https</td>
<td>协议</td>
</tr>
<tr>
<td>:host</td>
<td>api.wemore.com</td>
<td>主机地址</td>
</tr>
<tr>
<td>:path</td>
<td>/resource</td>
<td>资源路径</td>
</tr>
</tbody></table>
<p>至于压缩，HTTP2采用HPACK压缩算法，即构建一个索引表，将传输过的头部存入表中，下次传输时，如果头部已经在表中，则传索引号即可，否则传输实际请求头。需要注意的是，这个索引表是针对整个连接都有效的，所以能够跨Stream使用。</p>
<p>如下，第一个请求时，传输完整的头部，第二次请求时，仅有一个头部不一样，因此只传输这个头部即可，其它头部传索引（图中没画出来）。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912114305063.png" alt="image-20210912114305063" style="zoom:80%;" />

<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>相信我，它并不是你想象的那个样子。</p>
<p>我刚开始想象的样子：有了HTTP2，我们将不再需要WebSocket，因为它是长连接，也是支持服务端主动发送数据。</p>
<p>但我想多了，看<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">这里</a>可以了解到，HTTP2所谓的服务端推送，只是打破了一个请求对应一个响应的语义，只有有限场景能够用到，即服务端知道客户端将要请求什么数据，比如服务端返回一个网页，网页内嵌了很多图片、css、js等静态资源，按照以往的规则，都是要等待客户端发起推送的，但现在不一样，服务端可以告诉客户端：你先等着，我还有数据要发给你。</p>
<p><strong>实现方式</strong></p>
<p>服务端发送PUSH_PROMISE帧，客户端收到之后，不关闭流，而是待机等待。</p>
<p><strong>应用范围</strong></p>
<p>目前还很窄，nginx支持简单的静态资源推送，如下</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这表明访问index.html时，服务端会主动推送下面这些静态文件</span></span><br><span class="line"><span class="attribute">location</span> = /index.html &#123;</span><br><span class="line">  <span class="attribute">http2_push</span> /css/style.css;</span><br><span class="line">  <span class="attribute">http2_push</span> /js/main.js;</span><br><span class="line">  <span class="attribute">http2_push</span> /img/yule.jpg;</span><br><span class="line">  <span class="attribute">http2_push</span> /img/avatar.jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它场景应用也不是很多，主要还是对资源加载的优化，并不像WebSocket那样，完全将客户端-服务端之间数据传输的控制权完全交给用户。</p>
<h2 id="抓个包看一下"><a href="#抓个包看一下" class="headerlink" title="抓个包看一下"></a>抓个包看一下</h2><p>主要抓包有三种方式，网上搜一搜就知道了</p>
<ul>
<li>chrome：并不能通过控制台看到HTTP2的通信过程，而是要通过特殊的工具：chrome://net-internals/#http2</li>
<li><a target="_blank" rel="noopener" href="https://github.com/nghttp2/nghttp2">nghttp2</a>：一个开源命令行工具，能够抓取一个网站的HTTP2完整的通信过程</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jesse131/p/12686304.html">wireshark</a>：TCP抓包工具，但是要抓HTTP2包需要先配置秘钥，配置方式和Charles等不一样：Charles是伪造TLS证书，wireshark是窃取TLS握手成功后交换的对称秘钥</li>
</ul>
<p>我用nghttp2抓了一个nghttp2.org网站的包，可以看到大致流程</p>
<ul>
<li>建立连接，协议升级，https内标识：h2</li>
<li>发送SETTINGS帧，设置的内容有<ul>
<li>客户端流最大并发度：100</li>
<li>客户端的流控窗口初始值：65535</li>
</ul>
</li>
<li>发送PRIORITY帧，分别设置了流3、5、7、9、11、13的优先级（weight），依赖关系（dep_stream_id），流优先级及依赖关系请自行参考RFC</li>
<li>发送HEADERS帧，对GET <a target="_blank" rel="noopener" href="https://nghttp2.org进行访问/">https://nghttp2.org进行访问</a></li>
<li>收到服务端发来的SETTINGS帧，设置的内容有<ul>
<li>服务端流最大并发度：100</li>
<li>服务端流控窗口初始值：1048576</li>
<li>请求头索引表大小：8192</li>
</ul>
</li>
<li>收到服务端对之前SETTINGS帧的ACK响应（这是ACK可靠传输的机制，参见RFC）</li>
<li>收到PUSH_PROMISE帧，服务端即将推送screen.css帧给我们</li>
<li>发送对之前服务端SETTINGS帧的ACK响应</li>
<li>收到DATA帧，即传输内容</li>
<li>处理处理完收到的内容后，本地处理能力有所变化，发送WINDOW_UPDATE帧给客户端，通知对方调整流控窗口</li>
<li>收到带有END_STREAM标记的DATA帧，表明数据传输完成</li>
<li>发送GOAWAY帧，告诉客户端连接即将关闭，同时告知上一个成功的流ID为2，且没有任何错误，方便服务端进行优雅地关闭。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">zouguodong@zouguodongdeMacBook-Pro ~ % nghttp -nv https://nghttp2.org/</span><br><span class="line">[  0.228] Connected</span><br><span class="line">The negotiated protocol: h2</span><br><span class="line">[  0.358] send SETTINGS frame &lt;length=12, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=2)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):100]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):65535]</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=3&gt;</span><br><span class="line">          (dep_stream_id=0, weight=201, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=5&gt;</span><br><span class="line">          (dep_stream_id=0, weight=101, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=7&gt;</span><br><span class="line">          (dep_stream_id=0, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=9&gt;</span><br><span class="line">          (dep_stream_id=7, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=11&gt;</span><br><span class="line">          (dep_stream_id=3, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send HEADERS frame &lt;length=36, flags=0x25, stream_id=13&gt;</span><br><span class="line">          ; END_STREAM | END_HEADERS | PRIORITY</span><br><span class="line">          (padlen=0, dep_stream_id=11, weight=16, exclusive=0)</span><br><span class="line">          ; Open new stream</span><br><span class="line">          :method: GET</span><br><span class="line">          :path: /</span><br><span class="line">          :scheme: https</span><br><span class="line">          :authority: nghttp2.org</span><br><span class="line">          accept: */*</span><br><span class="line">          accept-encoding: gzip, deflate</span><br><span class="line">          user-agent: nghttp2/1.43.0</span><br><span class="line">[  0.474] recv SETTINGS frame &lt;length=24, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=4)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):100]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):1048576]</span><br><span class="line">          [SETTINGS_ENABLE_CONNECT_PROTOCOL(0x08):1]</span><br><span class="line">          [SETTINGS_HEADER_TABLE_SIZE(0x01):8192]</span><br><span class="line">[  0.475] recv SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br><span class="line">[  0.475] recv (stream_id=13) :method: GET</span><br><span class="line">[  0.475] recv (stream_id=13) :scheme: https</span><br><span class="line">[  0.475] recv (stream_id=13) :path: /stylesheets/screen.css</span><br><span class="line">[  0.475] recv (stream_id=13) :authority: nghttp2.org</span><br><span class="line">[  0.475] recv (stream_id=13) accept-encoding: gzip, deflate</span><br><span class="line">[  0.475] recv (stream_id=13) user-agent: nghttp2/1.43.0</span><br><span class="line">[  0.475] recv PUSH_PROMISE frame &lt;length=47, flags=0x04, stream_id=13&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0, promised_stream_id=2)</span><br><span class="line">[  0.475] send SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br><span class="line">[  0.673] recv (stream_id=13) :status: 200</span><br><span class="line">[  0.673] recv (stream_id=13) date: Sun, 12 Sep 2021 04:53:16 GMT</span><br><span class="line">[  0.673] recv (stream_id=13) content-type: text/html</span><br><span class="line">[  0.673] recv (stream_id=13) last-modified: Sun, 18 Jul 2021 04:17:59 GMT</span><br><span class="line">[  0.673] recv (stream_id=13) etag: <span class="string">&quot;60f3ab77-19d8&quot;</span></span><br><span class="line">[  0.673] recv (stream_id=13) accept-ranges: bytes</span><br><span class="line">[  0.673] recv (stream_id=13) content-length: 6616</span><br><span class="line">[  0.673] recv (stream_id=13) x-backend-header-rtt: 0.001926</span><br><span class="line">[  0.673] recv (stream_id=13) strict-transport-security: max-age=31536000</span><br><span class="line">[  0.673] recv (stream_id=13) server: nghttpx</span><br><span class="line">[  0.673] recv (stream_id=13) alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=3600</span><br><span class="line">[  0.673] recv (stream_id=13) via: 2 nghttpx</span><br><span class="line">[  0.673] recv (stream_id=13) x-frame-options: SAMEORIGIN</span><br><span class="line">[  0.673] recv (stream_id=13) x-xss-protection: 1; mode=block</span><br><span class="line">[  0.673] recv (stream_id=13) x-content-type-options: nosniff</span><br><span class="line">[  0.673] recv HEADERS frame &lt;length=235, flags=0x04, stream_id=13&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0)</span><br><span class="line">          ; First response header</span><br><span class="line">[  0.673] recv (stream_id=2) :status: 200</span><br><span class="line">[  0.673] recv (stream_id=2) date: Sun, 12 Sep 2021 04:53:16 GMT</span><br><span class="line">[  0.673] recv (stream_id=2) content-type: text/css</span><br><span class="line">[  0.674] recv (stream_id=2) last-modified: Sun, 18 Jul 2021 04:17:59 GMT</span><br><span class="line">[  0.674] recv (stream_id=2) etag: <span class="string">&quot;60f3ab77-98aa&quot;</span></span><br><span class="line">[  0.674] recv (stream_id=2) accept-ranges: bytes</span><br><span class="line">[  0.674] recv (stream_id=2) content-length: 39082</span><br><span class="line">[  0.674] recv (stream_id=2) x-backend-header-rtt: 0.002213</span><br><span class="line">[  0.674] recv (stream_id=2) strict-transport-security: max-age=31536000</span><br><span class="line">[  0.674] recv (stream_id=2) server: nghttpx</span><br><span class="line">[  0.674] recv (stream_id=2) alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=3600</span><br><span class="line">[  0.674] recv (stream_id=2) via: 2 nghttpx</span><br><span class="line">[  0.674] recv (stream_id=2) x-frame-options: SAMEORIGIN</span><br><span class="line">[  0.674] recv (stream_id=2) x-xss-protection: 1; mode=block</span><br><span class="line">[  0.674] recv (stream_id=2) x-content-type-options: nosniff</span><br><span class="line">[  0.674] recv (stream_id=2) x-http2-push: 1</span><br><span class="line">[  0.674] recv HEADERS frame &lt;length=63, flags=0x04, stream_id=2&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0)</span><br><span class="line">          ; First push response header</span><br><span class="line">[  0.674] recv DATA frame &lt;length=6616, flags=0x01, stream_id=13&gt;</span><br><span class="line">          ; END_STREAM</span><br><span class="line">[  0.674] recv DATA frame &lt;length=9434, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.763] recv DATA frame &lt;length=14467, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.851] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.851] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] send WINDOW_UPDATE frame &lt;length=4, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (window_size_increment=33140)</span><br><span class="line">[  0.852] send WINDOW_UPDATE frame &lt;length=4, flags=0x00, stream_id=2&gt;</span><br><span class="line">          (window_size_increment=34393)</span><br><span class="line">[  0.943] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.964] recv DATA frame &lt;length=2066, flags=0x01, stream_id=2&gt;</span><br><span class="line">          ; END_STREAM</span><br><span class="line">[  0.964] send GOAWAY frame &lt;length=8, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (last_stream_id=2, error_code=NO_ERROR(0x00), opaque_data(0)=[])</span><br></pre></td></tr></table></figure>

<h2 id="请注意"><a href="#请注意" class="headerlink" title="请注意"></a>请注意</h2><p>HTTP2是一个二进制协议，Stream、分帧等行为，并不具有更多语义上的意义（尽管帧类型规定是那些，但帧类型是可扩展的，协议也留出了扩展空间），也就是说，它能被用在其它应用场景下，比如GRPC</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/%E3%80%8A%E8%B6%85%E8%B6%8A%E6%84%9F%E8%A7%89%E3%80%8B%E2%80%94%E2%80%94%E6%B2%A1%E6%9C%89%E9%A2%84%E6%9C%9F%E7%9A%84%E9%82%A3%E6%A0%B7%E5%A5%BD--chao-yue-gan-jue--mei-you-yu-qi-de-na-yang-hao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/11/%E3%80%8A%E8%B6%85%E8%B6%8A%E6%84%9F%E8%A7%89%E3%80%8B%E2%80%94%E2%80%94%E6%B2%A1%E6%9C%89%E9%A2%84%E6%9C%9F%E7%9A%84%E9%82%A3%E6%A0%B7%E5%A5%BD--chao-yue-gan-jue--mei-you-yu-qi-de-na-yang-hao/" class="post-title-link" itemprop="url">《超越感觉》——没有预期的那样好</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-11 23:41:18" itemprop="dateCreated datePublished" datetime="2021-09-11T23:41:18+08:00">2021-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E6%83%B3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">随想 | 读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>阅读时间：6.5小时<br>阅读粒度：较粗</p>
</blockquote>
<h2 id="背景篇"><a href="#背景篇" class="headerlink" title="背景篇"></a>背景篇</h2><p>全书的思路很清晰，也能看出作者想要表达什么。</p>
<p>大家认识自我我们每个人，都受到特定的时间和空间的限制，拥有不同的文化背景，从小被灌输特定的道德观念，因此我们看待问题的角度一定是不一样的；我们的想法、思绪，受外界影响，大众媒体的发展，导致我们花在手机、电视上的时间比花在学习上的时间多好几倍，而这些媒介只是受商业或政治驱使的工具，具有很强的“洗脑”作用，无形中影响着我们看问题的角度；就算我们是一个爱学习的好孩子，我们的认知也会收到当前时代局限性的影响：人类从古至今的发展，几乎一直是进步的，每个时代都认为自己拥有超高水平的认知。但历史一次次证明，以前看起来无懈可击的理论，随着更多发现和研究，看起来变得颇为可笑，日心说如此，甚至经典力学也不能完全适用所有情况。这是第一章所阐述的内容，是全书最有意义的一章。</p>
<p>要拥有批判性思维，首先应该有上述觉悟，我们有局限性，我们的时代有局限性。应当始终坚持一个观点：“我知道我有局限性并且容易出错。而且，毫无疑问，我将永远不可能找到自己想知道的所有答案。但是我可以观察得更准确一点，权衡问题更全面一点，作出决定时更加仔细一点，如果我这么做了，我就会更加接近真理”。</p>
<p>这里引出一个方法问题，如何才算批判性思维呢？从事理性研究工作的人应该比较有体会。</p>
<ul>
<li>对于任何信息、观点，都不能直接相信</li>
<li>需要针对它提出问题 → 搜集资料、证据 → 分析论证 → 得出结论</li>
</ul>
<p>这一过程，也是我们日常工作的一部分。有人说，WebSocket是服务端推送最好的方式，针对这一观点，我们可以提出几个疑问</p>
<ul>
<li>这个观点本身是真的吗？</li>
<li>服务端推送是什么？</li>
<li>服务端推送还有哪些技术实现方案？</li>
<li>有最好的方式吗？“最好”岂不是银弹？这个世界上有银弹吗？</li>
</ul>
<p>然后，通过搜集整理，我们会发现除了WebSocket外，还有long-polling、SSE、HTTP2都与服务端推送相关，只是说WebSocket的功能更加全面，但它也有缺点，如不能使用现有的HTTP基础设施，这个角度讲，长轮询和SSE反而更好。还有使用场景，如果仅仅想要一个简单的服务端推送，几个技术都能满足，此时就要从实现的简单程度上考虑了。</p>
<p>这里又引出一个问题，那就是持有批判性思维，必然要求我们对大量资料和数据进行分析，如此大量的输入，要求我们有较为丰富的知识储备：丰富的知识，是又一个重点。</p>
<p>至于本篇后面几章，只是对前两章的扩展，论证说明几个点，过于啰嗦，直接略过。</p>
<ul>
<li>自我认知是有局限性的</li>
<li>任何资料都可能出错，包括感知、记忆、信息、权威，我们要做的，是判断它的确信度</li>
<li>得出观点要有充分的依据</li>
<li>为了面子坚持自己错误的观点是愚蠢的，理智地改变自己的观点并不会被人嘲笑</li>
<li>自我要求：要从受限的环境中通过一次次理性的批判分析赢得“个性”</li>
</ul>
<h2 id="易犯的错误"><a href="#易犯的错误" class="headerlink" title="易犯的错误"></a>易犯的错误</h2><p>本篇列举多达十几种错误。从根源看的话，无非两类：自我认知问题和方式方法问题</p>
<ul>
<li>自我认知问题：以自我为中心，不听从他人意见，容易受情绪影响；或者是受外界影响，无法坚持自己，容易盲从；多多少少有一些观点偏向性，导致发现的证据和做出的结论带有偏见。</li>
<li>方式方法问题：搜集资料不够多，不能做出正确的判断；缺乏耐心，急于下结论，导致得到一个草率的结论，甚至错误的结论。</li>
</ul>
<p>要解决这些问题，觉得应该做到几点</p>
<ul>
<li>扩展知识面</li>
<li>保持谦逊的态度，保持求知的态度</li>
<li>保持自信，却不盲目自信：这前提是观点经过自己反复论证</li>
<li>保持耐心</li>
</ul>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>如果说前面讨论的是理论基础，这里说的就是方法了，但这几章我直接跳过了，因为除了提纲，它所传达的细节内容对我不会有任何帮助。</p>
<p>那我们来大致说一下方法论。</p>
<ul>
<li>认识自己：批判性思考，一般来说是思考自己在生活中遇到的问题。但自己才是所有问题的首要，很多人愤怒、堕落，正是因为没有从批判的角度看清自己。</li>
<li>善于观察：不只是善于观察生活，还要善于观察方方面面，以我为例，行业、技术，都算。</li>
<li>选择议题：即批判性思考的目标。首先要从各方面拆分问题，再根据这些方面搜集资料。</li>
<li>资料搜集：搜集的资料，来自各种途径、有各种类型，要针对途径、类型再次以批判性眼光进行论证。</li>
<li>下结论：什么时候能下结论？当你认为事情已经有明确证据证明的时候。</li>
<li>说服他人：我为什么要说服他人？</li>
</ul>
<p>看，这也只是对第一篇批判性思考执行方法的具体扩展，所以呢，不读也罢。</p>
<p>而且，批判性思维这种东西，重在指导，具体怎么做，还是看个人。</p>
<h2 id="总体怎么讲"><a href="#总体怎么讲" class="headerlink" title="总体怎么讲"></a>总体怎么讲</h2><p>总体来说是本好书，但读完之后有种啥也没看的感觉，原因是干扰项太多。至少有两个干扰项——不够本土化的例子、过于啰嗦的表述方式。</p>
<p>仔细回想，我能记得的关键点就只有几个</p>
<ul>
<li>怀疑一切，包括自己：证据有可能是假的；自己是有局限性的</li>
<li>凡事经过论证：只有充分的证据表明一件事情是那样的，它才是那样的，别人说的，一概不信</li>
<li>问-找-结：从各方面充分提问，找论据做支撑，得出结论</li>
</ul>
<p>这本书适合谁？</p>
<p>至少不适合我，或者不完全适合我。一来，对于我认为是问题的问题，已经采取了书中所说的方法进行论证解析，因此没有带来太多东西；二来，表达过于学术化，可能因为它叫”批判性思考指南“吧，所以提出的任何一个观点，都会有一堆素材作为证据。而这些论据往往带有美国独有的历史、政治、民族特性，我完全无感，对阅读体验来说是负面的。与此相对，《认知觉醒》中的例子十分符合中国国情，队理解起到了正面作用。</p>
<p>适合谁呢🤔。可能适合学生，每一章后有应用题，而且作者也有提及”学期“这种字眼，想必就是为学生专门设计。我这种只想从中获取观点和方法的人，粗略看一遍即可；而想要细致培养批判性思维方式的学生、学者，可以按照书的节奏试一试。</p>
<h2 id="本书对我的影响"><a href="#本书对我的影响" class="headerlink" title="本书对我的影响"></a>本书对我的影响</h2><ul>
<li>认识到自己有局限性，别人也有局限性，所以不应该对别人有莫名的高期望值。别人，是你文章的读者，你的同事，也是你的聊天对象。</li>
<li>局限于专业会导致看问题视角过窄，因此保持对学习的激情，保持对问题的好奇，多多探索，才是批判性探索的应对之道。</li>
<li>批判所有，问题本身、提出问题的人、为解决问题而找出的资料，批判是递归的。</li>
<li>保持耐心：“我知道我有局限性并且容易出错。而且，毫无疑问，我将永远不可能找到自己想知道的所有答案。但是我可以观察得更准确一点，权衡问题更全面一点，作出决定时更加仔细一点，如果我这么做了，我就会更加接近真理”。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E6%88%91%E5%AF%B9%E8%B7%A8%E5%9F%9F%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BA%9B%E8%AF%AF%E8%A7%A3-2021-09-08-22-42-45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/08/%E6%88%91%E5%AF%B9%E8%B7%A8%E5%9F%9F%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BA%9B%E8%AF%AF%E8%A7%A3-2021-09-08-22-42-45/" class="post-title-link" itemprop="url">我对跨域可能有些误解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-08 22:42:45" itemprop="dateCreated datePublished" datetime="2021-09-08T22:42:45+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-24 17:10:10" itemprop="dateModified" datetime="2021-09-24T17:10:10+08:00">2021-09-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">后端 | 网络基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="已知"><a href="#已知" class="headerlink" title="已知"></a>已知</h2><p>不得不说，我(们)对跨域可能有些误解。确切地讲，是对跨域的使用有些误解。</p>
<p>我的跨域知识从哪里来？从这里——<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN</a></p>
<p>能总结出几点</p>
<ul>
<li>跨域是一种允许服务端对来自浏览器的访问进行控制的机制</li>
<li>它涉及到一系列专用的请求头<ul>
<li>浏览器端<ul>
<li>Origin：声明源站</li>
<li>Access-Control-Request-Method：声明自己将要使用什么方法</li>
<li>Access-Control-Request-Headers：声明自己将要携带哪些自定义头部</li>
</ul>
</li>
<li>服务端<ul>
<li>Access-Control-Allow-Origin：声明本站允许的源站</li>
<li>Access-Control-Allow-Methods：声明本站允许的方法</li>
<li>Access-Control-Allow-Headers：声明本真允许的自定义头部</li>
<li>Access-Control-Max-Age：声明一个预检请求的有效期，有效期内同一个请求无须再次预检</li>
</ul>
</li>
</ul>
</li>
<li>请求被划分为简单请求和复杂请求<ul>
<li>复杂请求在请求实际发出之前，会发出OPTIONS预检请求进行跨域询问</li>
<li>简单请求不需要预检</li>
</ul>
</li>
</ul>
<p>在实际使用中，我们为了方便，尝尝会将服务端的所有响应配置为“*”，即允许所有源站、方法、自定义首部的请求进行访问。</p>
<p>然而，这招在需要传输Cookie的请求中，行不通，浏览器会报如下错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx from origin <span class="string">&#x27;xxxx&#x27;</span> has been blocked by CORS policy: The value of the <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header <span class="keyword">in</span> the response must not be the wildcard <span class="string">&#x27;*&#x27;</span> when the request<span class="string">&#x27;s credentials mode is &#x27;</span>include<span class="string">&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span></span><br></pre></td></tr></table></figure>

<h2 id="盲区"><a href="#盲区" class="headerlink" title="盲区"></a>盲区</h2><p>出现这个问题，是因为漏掉了关键的一点：附带身份凭证的请求。其明确规定一点</p>
<ul>
<li><p>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”</p>
<p>  相应的，它必须是确切地和请求中的Origin进行匹配，即，如果请求的Origin是<a target="_blank" rel="noopener" href="http://xyc.com,则响应的access-control-allow-origin也必须为http//xyc.com">http://xyc.com，则响应的Access-Control-Allow-Origin也必须为http://xyc.com</a></p>
</li>
</ul>
<p>这一点可以验证，并且牵出一个新的响应请求头</p>
<ul>
<li>Access-Control-Allow-Credentials: 是否允许跨域携带凭证。为true时，代表允许，相应地Access-Control-Allow-Origin 就一定不会为“*”</li>
</ul>
<p>出现上面的错误只有一种情况，即响应只有Access-Control-Allow-Origin: *，而没有Access-Control-Allow-Credentials，或者其值为false。</p>
<p>解决办法，加上Access-Control-Allow-Credentials: true，并修改Access-Control-Allow-Origin。</p>
<h2 id="Spring对跨域的支持"><a href="#Spring对跨域的支持" class="headerlink" title="Spring对跨域的支持"></a>Spring对跨域的支持</h2><p>所有Spring Web模块，都支持直接配置跨域。下面是正确且唯一正确的配置</p>
<p>web服务的代码中配置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">corsFilter</span><span class="params">()</span></span>: CorsFilter &#123;</span><br><span class="line">    <span class="keyword">val</span> config = CorsConfiguration()</span><br><span class="line">    <span class="comment">// 预检请求有效期</span></span><br><span class="line">    config.maxAge = <span class="number">3600</span></span><br><span class="line">    <span class="comment">// 允许跨域发送身份凭证</span></span><br><span class="line">    config.allowCredentials = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 允许跨域的源为所有，注意与origin:*进行区分</span></span><br><span class="line">    config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="comment">// 允许所有请求头</span></span><br><span class="line">    config.addAllowedHeader(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="comment">// 允许所有请求方法</span></span><br><span class="line">    config.addAllowedMethod(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> source = UrlBasedCorsConfigurationSource().apply &#123;</span><br><span class="line">        <span class="comment">// 上述配置针对所有请求路径生效</span></span><br><span class="line">        registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CorsFilter(source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Gateway中配置文件的配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /**表示配置针对所有路径</span></span><br><span class="line"><span class="comment"># 允许</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-headers=*</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-methods=*</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-origin-patterns=*</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allow-credentials=true</span></span><br></pre></td></tr></table></figure>

<p>这里尤其注意区分</p>
<p><code>addAllowedOriginPattern(&quot;*&quot;)</code>和<code>addOrigins(&quot;*&quot;)</code>的区别</p>
<ul>
<li><p>前者的*表示通配符，用来匹配请求的Origin，如果匹配成功，响应的Access-Control-Allow-Origin就直接被设置为请求的Origin</p>
</li>
<li><p>后者表示直接将所有的Access-Control-Allow-Origin值都设置为”*“。这个在和allowCredentials=true一起使用的情况下要注意</p>
</li>
<li><p>如果两个都设置，将会是<code>addOrigins(&quot;*&quot;)</code>生效。这一点可以去翻源码</p>
<p>  位置：org.springframework.web.cors.CorsConfiguration#checkOrigin</p>
</li>
</ul>
<h2 id="请求头冲突的问题"><a href="#请求头冲突的问题" class="headerlink" title="请求头冲突的问题"></a>请求头冲突的问题</h2><p>如果使用Spring Gateway作为网关，后面再挂着Spring Web作为服务，并且它们都正确配置了跨域。那么正常情况下，响应的请求头就会出现两份完全一样的跨域头部，像下面这样</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vary:</span> <span class="string">Origin</span></span><br><span class="line"><span class="attr">access-control-allow-credentials:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">access-control-allow-origin:</span> <span class="string">xxxx</span></span><br><span class="line"><span class="attr">vary:</span> <span class="string">Origin</span></span><br><span class="line"><span class="attr">access-control-allow-credentials:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">access-control-allow-origin:</span> <span class="string">xxxx</span></span><br></pre></td></tr></table></figure>

<p>这似乎不违反HTTP关于请求头重复的规定，但在跨域的机制中，却是不可接收的，可能出现这种错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;xxxxx&#x27;</span> from origin <span class="string">&#x27;http://localhost:3200&#x27;</span> has been blocked by CORS policy: </span><br><span class="line">The <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header contains multiple values <span class="string">&#x27;*, http://localhost:3200&#x27;</span>, but only one is allowed.</span><br></pre></td></tr></table></figure>

<p>解决办法就是在网关对重复的头部进行处理，我们可以用过滤器：DedupeResponseHeader</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.cloud.gateway.default-filters[0]=DedupeResponseHeader=Vary</span> <span class="string">Access-Control-Allow-Origin</span> <span class="string">Access-Control-Allow-Credentials</span></span><br></pre></td></tr></table></figure>

<p>它默认保留重复头中的第一个，具体参见<a href="%5Bhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-deduperesponseheader-gatewayfilter-factory%5D(https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-deduperesponseheader-gatewayfilter-factory)">手册</a></p>
<h2 id="Vary怎么说"><a href="#Vary怎么说" class="headerlink" title="Vary怎么说"></a>Vary怎么说</h2><p>我们总是能看到响应中有Vary头部，它有什么用？服务端是如何生成的？</p>
<p>根据<a href="%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)">标准</a>，它是被服务器用来声明一个请求的响应的变化依据，浏览器可用它来控制缓存。比如对<code>Vary: Origin</code>，它表示，对同一个请求，服务器针对不同的源站有不同的响应。</p>
<p>服务端是如何生成的呢？确切地讲，不同场景下有不同的生成方式，比如Spring Web中如果开启了跨域，默认会在响应上添加Vary请求头，写死的，其值包含</p>
<ul>
<li>Origin</li>
<li>Access-Control-Request-Method</li>
<li>Access-Control-Request-Headers</li>
</ul>
<p>源码参见：org.springframework.web.cors.reactive.DefaultCorsProcessor#VARY_HEADERS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; VARY_HEADERS = Arrays.asList(</span><br><span class="line">			HttpHeaders.ORIGIN, HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="meta">@Nullable</span> CorsConfiguration config, ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">	ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">	HttpHeaders responseHeaders = response.getHeaders();</span><br><span class="line"></span><br><span class="line">	List&lt;String&gt; varyHeaders = responseHeaders.get(HttpHeaders.VARY);</span><br><span class="line">        <span class="comment">// 如果当前响应没有包含Vary，则加上</span></span><br><span class="line">	<span class="keyword">if</span> (varyHeaders == <span class="keyword">null</span>) &#123;</span><br><span class="line">		responseHeaders.addAll(HttpHeaders.VARY, VARY_HEADERS);</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud同时使用DedupeResponseHeader和WebSocket"><a href="#Spring-Cloud同时使用DedupeResponseHeader和WebSocket" class="headerlink" title="Spring Cloud同时使用DedupeResponseHeader和WebSocket"></a>Spring Cloud同时使用DedupeResponseHeader和WebSocket</h2><p>Spring Cloud中同时使用DedupeResponseHeader和WebSocket会报错。如下，这是握手成功后抛出的异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedOperationException</span><br><span class="line">	at org.springframework.http.ReadOnlyHttpHeaders.set(ReadOnlyHttpHeaders.java:106)</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong></p>
<p>Spring Cloud对WebSocket有特殊处理，位于过滤器WebsocketRoutingFilter中，与这部分相关的逻辑位于：org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy#upgrade</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;<span class="built_in">Void</span>&gt; upgrade(ServerWebExchange exchange, WebSocketHandler handler,</span><br><span class="line">		<span class="meta">@Nullable</span> String subProtocol, Supplier&lt;HandshakeInfo&gt; handshakeInfoFactory) &#123;</span><br><span class="line"></span><br><span class="line">	ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">	HttpServerResponse reactorResponse = ServerHttpResponseDecorator.getNativeResponse(response);</span><br><span class="line">	HandshakeInfo handshakeInfo = handshakeInfoFactory.<span class="keyword">get</span>();</span><br><span class="line">	NettyDataBufferFactory bufferFactory = (NettyDataBufferFactory) response.bufferFactory();</span><br><span class="line">	URI uri = exchange.getRequest().getURI();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger WebFlux preCommit actions and upgrade</span></span><br><span class="line">	<span class="keyword">return</span> response.setComplete()</span><br><span class="line">			.then(Mono.defer(() -&gt; &#123;</span><br><span class="line">				WebsocketServerSpec spec = buildSpec(subProtocol);</span><br><span class="line">				<span class="keyword">return</span> reactorResponse.sendWebsocket((<span class="keyword">in</span>, <span class="keyword">out</span>) -&gt; &#123;</span><br><span class="line">					ReactorNettyWebSocketSession session =</span><br><span class="line">							new ReactorNettyWebSocketSession(</span><br><span class="line">									<span class="keyword">in</span>, <span class="keyword">out</span>, handshakeInfo, bufferFactory, spec.maxFramePayloadLength());</span><br><span class="line">					<span class="keyword">return</span> handler.handle(session).checkpoint(uri + <span class="string">&quot; [ReactorNettyRequestUpgradeStrategy]&quot;</span>);</span><br><span class="line">				&#125;, spec);</span><br><span class="line">			&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键点是，response.setComplete()，这里已经将response设置为完成状态，后续过滤器就无法再操作其内容，而我们设置的DedupeResponseHeader过滤器就在它的后面，因此报错。</p>
<p><strong>解决</strong></p>
<p>这里，要明白两个点</p>
<ul>
<li>WebSocket握手成功后的响应头，不会存在重复的情况，这一点由WebSocket相关的Filter自己去保证</li>
<li>DedupeResponseHeader，不会去判断response是否已经完成</li>
</ul>
<p>为此，可以自定义DedupeResponseHeader，加上对response的完成状态进行判断的逻辑。如下，整个逻辑完全照抄DedupeResponseHeaderGatewayFilterFactory，连Config和Strategy都沿用，这样能够使得对它的使用上完全和DedupeResponseHeader一致。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDedupeResponseHeaderGatewayFilterFactory</span> : <span class="type">AbstractGatewayFilterFactory</span>&lt;<span class="type">Config</span>&gt;</span>(Config::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Loaded GatewayFilterFactory [CustomDedupeResponseHeader]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shortcutFieldOrder</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> listOf(NAME_KEY, <span class="string">&quot;strategy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(config: <span class="type">Config</span>)</span></span> = GatewayFilter &#123; exchange, chain -&gt;</span><br><span class="line">        chain.filter(exchange).then(Mono.fromRunnable &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exchange.response.isCommitted) &#123;</span><br><span class="line">                dedupe(exchange.response.headers, config)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dedupe</span><span class="params">(headers: <span class="type">HttpHeaders</span>?, config: <span class="type">Config</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> names = config.name</span><br><span class="line">        <span class="keyword">val</span> strategy = config.strategy</span><br><span class="line">        <span class="keyword">if</span> (headers == <span class="literal">null</span> || names == <span class="literal">null</span> || strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (name <span class="keyword">in</span> names.split(<span class="string">&quot; &quot;</span>.toRegex()).toTypedArray()) &#123;</span><br><span class="line">            dedupe(headers, name.trim &#123; it &lt;= <span class="string">&#x27; &#x27;</span> &#125;, strategy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dedupe</span><span class="params">(headers: <span class="type">HttpHeaders</span>, name: <span class="type">String</span>, strategy: <span class="type">Strategy</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> values = headers[name]</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="literal">null</span> || values.size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">when</span> (strategy) &#123;</span><br><span class="line">            Strategy.RETAIN_FIRST -&gt; headers[name] = values[<span class="number">0</span>]</span><br><span class="line">            Strategy.RETAIN_LAST -&gt; headers[name] = values[values.size - <span class="number">1</span>]</span><br><span class="line">            Strategy.RETAIN_UNIQUE -&gt; headers[name] = values.stream().distinct().collect(Collectors.toList())</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.gateway.default-filters[<span class="number">0</span>]=CustomDedupeResponseHeader=Vary Access-Control-Allow-Origin Access-Control-Allow-Credentials</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2%E9%B2%81%E9%B2%81%E4%BF%AE--wo-wei-shen-me-xi-huan-lu-lu-xiu-httpswwwnotionsoa72043b53a5a48f3beb069ab6a18be9b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/06/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2%E9%B2%81%E9%B2%81%E4%BF%AE--wo-wei-shen-me-xi-huan-lu-lu-xiu-httpswwwnotionsoa72043b53a5a48f3beb069ab6a18be9b/" class="post-title-link" itemprop="url">我为什么喜欢鲁鲁修</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-06 21:49:34 / Modified: 21:59:23" itemprop="dateCreated datePublished" datetime="2021-09-06T21:49:34+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">随想</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《反叛的鲁鲁修》好看吗？毫无疑问我认为是好看的，但细想，为啥我会觉得好看呢？不能凭感觉，好看总有个理由，必须是客观上的。</p>
<h2 id="世界设定"><a href="#世界设定" class="headerlink" title="世界设定"></a>世界设定</h2><p>动漫吸引我的很大原因，在于想象力。火影忍者凭空架设出一个完整的忍者世界，海贼王的海贼世界，无一不让我惊叹这些作者丰富的想象力。鲁鲁修给的世界让人感觉非常有意思——直接根据现实世界改变而来。</p>
<p>世界地图，就是真实的世界地图，不同的是所属国家的变化。全球分为三大部分：布里塔尼亚——美洲、EU——欧洲、中华联邦——亚洲大部分。布里塔尼亚就是美帝的翻版，占领日本，也仿佛是在影射二战。并且，和现实一样，布里塔尼亚研究出核武器并在日本本土进行了投放。</p>
<p>这样直接根据历史而来的世界背景设定，是我第一次见到（动漫还是看得少。。。）</p>
<h2 id="反叛和翻转"><a href="#反叛和翻转" class="headerlink" title="反叛和翻转"></a>反叛和翻转</h2><p>反叛的鲁鲁修，“反叛”一词。起初的理解类似叛逆，一个少年的反叛，与叛逆无异。</p>
<p>果然还是我太年轻。就感觉和写主题作文一样，片中好像一直在点题。第一季，为了妹妹娜娜莉，顶着布里塔尼亚人的身份，以ZERO之名，直接反叛布里塔尼亚政府；反叛兄弟朱雀；反叛恋人莎莉；反叛皇妹尤菲米娅；最终为救娜娜莉甚至客观反叛黑色骑士团。第二季更为彻底，反叛妹妹娜娜莉。</p>
<p>伴随反叛的，就是不停地反转。我要战败了。。。诶反转，我有了最新武器，无敌的存在；我要被黑色骑士团制裁了。。。诶反转，我摇身一变成了布里塔利亚的皇帝；我要将世界以自己的方式进行有利的改造，要与世界为伍。。。诶反转，我变成了全世界的公敌；我要专制独裁统治全世界。。。诶反转，我将仇恨带到地狱，留给世界一片祥和。</p>
<p>只能说。。。简直了。</p>
<h2 id="英雄主义"><a href="#英雄主义" class="headerlink" title="英雄主义"></a>英雄主义</h2><p>就像漫画中活跃的电台制作人迪特哈尔特·里德一样，我相信现实生活中的很多人都对个人英雄主义都有别样的喜爱之情，不然《玫瑰岛共和国》这样的电影为什么能够高分。为一个人，与全世界最强政府为敌，以独特的人格魅力和领导才能，左右着世界的风云变化；从与一个国家为敌，到与全世界为敌，将全世界的邪与恶集中于自己一人，再慷慨赴死，换取世界长久的和平。这样极致到如此彻底的个人英雄主义，极致到带有浓重的浪漫主义色彩，也是完美的理想主义。怎能不让人喜欢。</p>
<h2 id="战争与和平"><a href="#战争与和平" class="headerlink" title="战争与和平"></a>战争与和平</h2><p>动漫里有很多嘴遁环节，出现最多的话题是——和平。查尔斯国王和玛丽安娜王妃想让大家活在虚无的，没有实际战争和纷杂的精神世界中（这不就是。。。无限月读吗）；修奈泽尔的解决方案是核威慑；鲁鲁修则给全世界人们施以“愿望”的Geass，让大家憧憬美好的明天。</p>
<p>客观理性地讲是鲁鲁修正确，但凡事无绝对呀。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/03/WebSocket%E5%95%8A%E5%96%82-websocket-a-wei/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/03/WebSocket%E5%95%8A%E5%96%82-websocket-a-wei/" class="post-title-link" itemprop="url">WebSocket啊喂</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-03 18:39:28" itemprop="dateCreated datePublished" datetime="2021-09-03T18:39:28+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">后端 | 网络基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文主要包含三部分</p>
<ul>
<li>WebSocket协议、STOMP协议、SockJS协议三部分的理论介绍</li>
<li>使用Spring实现一个简单的消息推送服务</li>
<li>使用Postman调试STOMP服务</li>
</ul>
</blockquote>
<p>WebSocket我们大概都知道是个啥东西，原理上挺简单，使用起来却没那么容易。因为我们会发现，无论是Spring的WebSocket部分的手册，还是网络上的一大票文章，无不涉及到三个关键词——WebSocket、SockJS、STOMP。以至于我们想找一篇介绍只使用WebSocket构建服务的文章都十分困难。究其原因，我想大致有这么几个</p>
<ul>
<li>WebSocket协议在数据层面还是太底层了，需要STOMP这样的应用层协议供大家使用；而STOMP又涵盖了消息中心的大部分使用场景，因此变得很必要。</li>
<li>对前端来说，sockjs-client库很多时候是接入WebSocket的较好的方式，于是SockJS协议映入眼帘。</li>
</ul>
<p>所以，无论如何，这三个协议本身，我们是必须搞清楚的。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>十分建议详细阅读一下WebSocket的协议标准——<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6455.txt.pdf">RFC6455</a></p>
<p>关于WebSocket需要明白的重点</p>
<ul>
<li>由HTTP升级而来</li>
<li>与HTTP共用端口，即80和443(HTTPS)</li>
<li>升级后CS之间通信与HTTP无任何关系，而是采用类似TCP的二进制帧进行的</li>
</ul>
<h3 id="WebSocket的设计哲学"><a href="#WebSocket的设计哲学" class="headerlink" title="WebSocket的设计哲学"></a>WebSocket的设计哲学</h3><ul>
<li>设计足够简单，使得能够被用来支撑其它应用，如STOMP。STOMP之于WebSocket，好比HTTP之于TCP。</li>
<li>相较于TCP，它仅仅是被赋予了web的一些特性。如：origin安全模型、类似http 的uri地址模型等</li>
<li>其它。。。就没有其它了</li>
</ul>
<h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><p>一个完整的WebSocket通信流程包括：握手 -&gt; 全双工通信 -&gt; 关闭连接</p>
<h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>握手是纯HTTP请求，这为WebSocket鉴权带来了方便。我们依旧可以使用之前HTTP体系下的鉴权方式。</p>
<p>客户端握手请求示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务端响应示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<p>对比较陌生的请求头予以说明</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Upgrade: websocket</td>
<td>表明协议升级的目标协议。<br />如果有注意到，从HTTP1.1升级到HTTP2.0，也是采用一样的方式</td>
</tr>
<tr>
<td>Connection: Upgrade</td>
<td>表明本次请求是协议升级</td>
</tr>
<tr>
<td>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</td>
<td>客户端生成的随机数的BASE64编码结果</td>
</tr>
<tr>
<td>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</td>
<td>服务端根据客户端给的随机数通过固定的算法计算出的结果；<br />客户端收到后会以相同的算法计算结果并对比，以证明这是一个合法的响应</td>
</tr>
<tr>
<td>Sec-WebSocket-Protocol: chat, superchat</td>
<td>子协议选择，客户端列出可选子协议，服务端选择支持的子协议<br />由于WebSocket过于底层，因此支持子协议以适应不同应用场景</td>
</tr>
<tr>
<td>Sec-WebSocket-Version: 13</td>
<td>WebSocket版本</td>
</tr>
<tr>
<td>HTTP/1.1 101 Switching Protocols</td>
<td>101表示升级成功，即握手成功</td>
</tr>
</tbody></table>
<h4 id="协议帧"><a href="#协议帧" class="headerlink" title="协议帧"></a>协议帧</h4><p>握手成功之后就是正常的通信。WebSocket通信时以帧为单位进行数据的收发，一条完整的信息可能被分为多个帧进行传输，到远端后再被拼接在一次。</p>
<p>协议帧结构如下，是不是很熟悉，有点TCP协议帧的味道。这也是说它很底层的原因。各bit的详细含义，参见RFC</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210902223211949.png" alt="image-20210902223211949"></p>
<h4 id="协议帧类型"><a href="#协议帧类型" class="headerlink" title="协议帧类型"></a>协议帧类型</h4><p>WebSocket协议帧有两种类型：数据帧和控制帧。数据帧顾名思义，用于传输数据；我们这里重点关注数据帧</p>
<ul>
<li>Close：用于关闭连接</li>
<li>Ping：心跳发起</li>
<li>Pong：心跳响应，Ping、Pong总是成对出现</li>
</ul>
<p>注意，协议虽然定义了新跳帧，但是否使用，需要使用者决定。</p>
<h2 id="SockJS"><a href="#SockJS" class="headerlink" title="SockJS"></a>SockJS</h2><p>同样，十分建议阅读一下SockJS的协议标准——<a target="_blank" rel="noopener" href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">它并非ITEF拟定的，而是一个开源项目</a></p>
<p>我们知道，早在WebSocket出现之前，从服务端向客户端推数据这个需求，就一直存在。其中最常用的尝试就有轮询、长轮询等，后面又有了EventSource之类的机制。而SockJS，就是集合了现今所有这类方式的库（包含websocket）。如今，SockJS已经成为了一个协议标准，主流语言都有了支持的库，尤其是web前端。</p>
<p>简单地说，SocketJS定义了一个服务端必须有哪些HTTP端点，以便使用不同的通信方式。定义了帧结构，用于传输数据</p>
<h3 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h3><p>这里列出关键的端点，省略了域名和base url</p>
<ul>
<li><p>/info：用于查询客户端支持的通信方式，如是否支持WebSocket。可以理解为通信协商</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 这里展示一个典型地info响应</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;entropy&quot;</span>:<span class="number">2143307232</span>,</span><br><span class="line">  <span class="attr">&quot;origins&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;*:*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;cookie_needed&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;websocket&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>/(server_id)/(session_id)/websocket：暴露的websocket端点，用于websocket通信</p>
</li>
<li><p>/(server_id)/(session_id)/xhr，/(server_id)/(session_id)/xhr_send：暴露的长连接端点，用于ajax长连接</p>
</li>
<li><p>/(server_id)/(session_id)/eventsource：eventsource端点</p>
</li>
<li><p>/websocket：这是一个外挂，该端点直接走裸的websocket协议，这为SockJS服务端直接使用WebSocket客户端库提供了条件</p>
</li>
</ul>
<p>SockJS协议通信分为两步：访问/info询问支持的通信方式；访问对应的端点进行通信</p>
<h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3><p>SockJS是一个协议，也有自己的帧定义，但它的帧定义足够简单，就几个字符</p>
<ul>
<li>o：通信开启帧</li>
<li>h：心跳帧，服务端下发</li>
<li>a：消息数组</li>
<li>c：通信关闭帧</li>
</ul>
<h3 id="SockJS的缺点"><a href="#SockJS的缺点" class="headerlink" title="SockJS的缺点"></a>SockJS的缺点</h3><ul>
<li>出于安全原因，在协议层面就不支持自定义请求头，我们应该能发现所有sockjs客户端库都无法添加请求头吧。<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/issues/196">原因看这</a></li>
<li>与WebSocket是包含关系，而非兼容关系。如果一个服务端暴露SockJS服务，客户端是没办法直接将这个端点用在WebSocket库的，而是要通过SockJS暴露出的websocket原生端点进行访问（即base url/websocket），不大友好</li>
</ul>
<h2 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h2><p>再次，十分建议阅读一下STOMP的协议标准——<a target="_blank" rel="noopener" href="https://stomp.github.io/stomp-specification-1.2.html">它也是一个开源项目</a></p>
<p>STOMP是一个高级的应用协议，用于异步消息传输，支持点对点发送、发布订阅等消息传递方式。它的设计哲学就是足够简单，这也体现在协议长度上，如果看过AMQP、MQTT之类的消息协议，就能体会什么叫简单。</p>
<h3 id="帧结构-1"><a href="#帧结构-1" class="headerlink" title="帧结构"></a>帧结构</h3><p>这是它的帧结构，就是纯文本帧。包含命令、头部、body三部分。最后以ascii为0的字符结尾。</p>
<ul>
<li>命令：表明帧类型</li>
<li>头部：额外的帧属性，如心跳配置、content-type等</li>
<li>body：消息体，只有消息帧时才有</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure>

<h3 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h3><p>帧类型也足够简单</p>
<table>
<thead>
<tr>
<th>Side</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>CONNECT</td>
<td>发起连接</td>
</tr>
<tr>
<td></td>
<td>DISCONNECT</td>
<td>断开连接</td>
</tr>
<tr>
<td></td>
<td>SEND</td>
<td>发送消息</td>
</tr>
<tr>
<td></td>
<td>SUBSCRIBE</td>
<td>订阅</td>
</tr>
<tr>
<td></td>
<td>UNSUBSCRIBE</td>
<td>取消订阅</td>
</tr>
<tr>
<td></td>
<td>ACK/NACK</td>
<td>响应</td>
</tr>
<tr>
<td></td>
<td>BEGIN/COMMIT/ABORT</td>
<td>事务相关</td>
</tr>
<tr>
<td>服务端</td>
<td>CONNECTED</td>
<td>连接成功</td>
</tr>
<tr>
<td></td>
<td>MESSAGE</td>
<td>发送订阅的消息给客户端</td>
</tr>
<tr>
<td></td>
<td>RECEIPT</td>
<td>凭据，如果客户端需要的话</td>
</tr>
<tr>
<td></td>
<td>ERROR</td>
<td>错误通报</td>
</tr>
</tbody></table>
<h2 id="所以这三个协议的关系？"><a href="#所以这三个协议的关系？" class="headerlink" title="所以这三个协议的关系？"></a>所以这三个协议的关系？</h2><p>WebSocket、SockJS、STOMP三者，从前往后，层级依次上升，就像洋葱，WebSocket在里面，SockJS其次，STOMP在最外面。如果我们使用建立在SockJS协议上的STOMP服务，而SockJS又选择WebSocket作为底层的通信协议。在通信过程中，STOMP帧会被组装成SockJS的帧；SockJS的帧会被组装成WebSocket的帧；再深一点，WebSocket的帧会被组装成TCP的帧；TCP的帧被组装成IP层的帧，然后传输；到远端后执行相反操作。</p>
<p>从分类上说，WebSocket和SockJS都只是通用的数据传输协议；而STOMP是一种消息协议，抽象层级更高。</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>三个协议都定义了心跳，其中</p>
<ul>
<li>WebSocket只定义了心跳帧，但发送的时机与策略，由具体实现来定。目前来看，默认情况下WebSocket库是不会自动发送心跳的，需调用者手动发送</li>
<li>SockJS规定服务端必须发送心跳，默认25秒一次，可配，不需要调用者手动开启</li>
<li>STOMP也定义了心跳，默认不开启，一般实现库都有提供，只需手动配置开启即可。需要说明的是，开启了STOMP的心跳，会关闭掉SockJS的心跳。</li>
</ul>
<h2 id="Spring实现一个消息推送服务"><a href="#Spring实现一个消息推送服务" class="headerlink" title="Spring实现一个消息推送服务"></a>Spring实现一个消息推送服务</h2><p>Spring对WebSocket的支持看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html">这里</a>。</p>
<p>我们实现一个简单的需求</p>
<ul>
<li>暴露STOMP端点</li>
<li>提供主题，供用户订阅，支持对单个用户广播。即，需要鉴权</li>
<li>提供一个STOMP地址，用户向该地址发送数据时，从其订阅的主体下发消息</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置类如下，这不是一个完全可用的类，直接复制很可能无法正常运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> : <span class="type">WebSocketMessageBrokerConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> objectMapper: ObjectMapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerStompEndpoints</span><span class="params">(registry: <span class="type">StompEndpointRegistry</span>)</span></span> &#123;</span><br><span class="line">      	<span class="comment">// 暴露STOMP端点</span></span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/stomp&quot;</span>)</span><br><span class="line">      			<span class="comment">// 添加握手拦截器，用于做权限验证</span></span><br><span class="line">            .addInterceptors(AuthHandshakeInterceptor(objectMapper))</span><br><span class="line">      			<span class="comment">// 握手处理器</span></span><br><span class="line">            .setHandshakeHandler(AuthHandshakeHandler())</span><br><span class="line">            .setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .withSockJS()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configureMessageBroker</span><span class="params">(registry: <span class="type">MessageBrokerRegistry</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 用于发送心跳的调度器，一定要有。其它层级协议的心跳不能替代STOMP层级的心跳</span></span><br><span class="line">        <span class="keyword">val</span> scheduler = TaskSchedulerBuilder().build().apply &#123; initialize() &#125;</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>).setTaskScheduler(scheduler)</span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>)</span><br><span class="line">        <span class="comment">// 订阅/user/打头的destination时，STOMP可自动将每个用户对应一个主题，实现向指定用户发送消息的能力</span></span><br><span class="line">        registry.setUserDestinationPrefix(<span class="string">&quot;/user/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandshakeInterceptor</span></span>(<span class="keyword">val</span> objectMapper: ObjectMapper) : HandshakeInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeHandshake</span><span class="params">(request: <span class="type">ServerHttpRequest</span>, response: <span class="type">ServerHttpResponse</span>, wsHandler: <span class="type">WebSocketHandler</span>, attributes: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, Any&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      	<span class="comment">// 从request的header或query中提取用户，具体逻辑自己实现</span></span><br><span class="line">        <span class="keyword">val</span> user = request.parseUser(objectMapper)</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// </span></span><br><span class="line">            <span class="keyword">val</span> error = ResErrCode.NEED_AUTHORIZE</span><br><span class="line">            response.setStatusCode(error.httpStatus)</span><br><span class="line">            response.headers.contentType = MediaType.APPLICATION_JSON</span><br><span class="line">            response.body.write(objectMapper.writeValueAsBytes(R.fail(error)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        attributes[<span class="string">&quot;user&quot;</span>] = user</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterHandshake</span><span class="params">(request: <span class="type">ServerHttpRequest</span>, response: <span class="type">ServerHttpResponse</span>, wsHandler: <span class="type">WebSocketHandler</span>, exception: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 这里啥也没做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandshakeHandler</span> : <span class="type">DefaultHandshakeHandler</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineUser</span><span class="params">(request: <span class="type">ServerHttpRequest</span>, wsHandler: <span class="type">WebSocketHandler</span>, attributes: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, Any&gt;)</span></span>: Principal? &#123;</span><br><span class="line">        <span class="keyword">return</span> attributes[<span class="string">&quot;user&quot;</span>] <span class="keyword">as</span> Principal?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>暴露接收用户信息的地址。</p>
<p>这里的关键在于MessageMapping和SendToUser两个注解的使用，它们能够直接在Controller中使用。</p>
<p>前者将用户发送的消息导入；后者将方法返回的内容发送给对应的用户。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSocketController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动触发拉取通知，随便发个啥，都会触发一次拉取通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MessageMapping(<span class="meta-string">&quot;/triggerPullNotification&quot;</span>)</span></span><br><span class="line">    <span class="meta">@SendToUser(destinations = [<span class="meta-string">&quot;topic/pullNotification&quot;</span>])</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(income: <span class="type">String</span>, principal: <span class="type">Principal</span>)</span></span>: Any &#123;</span><br><span class="line">        log.info(<span class="string">&quot;trigger pull notification manually: user &#123;&#125;; message: &#123;&#125;&quot;</span>, principal.name, income)</span><br><span class="line">        <span class="keyword">return</span> STOMP_USER_PULL_NOTIFICATION_PAYLOAD</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，STOMP客户端向/app/triggerPullNotification发送消息时，会进入echo方法，发送的内容被传递到income参数中，发送消息的用户被传递到principal参数中。echo返回的对象会被发送给订阅了/user/topic/pullNotification主题的当前session的用户，即触发这个消息的用户。</p>
</li>
<li><p>在其他地方向指定用户发送消息</p>
<p>这里的关键是注入SimpMessagingTemplate</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleService</span></span>(<span class="keyword">val</span> stomp: SimpMessagingTemplate) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是你的自由逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 发送给某个用户</span></span><br><span class="line">    stomp.convertAndSendToUser(<span class="number">12345</span>, <span class="string">&quot;/topic/pullNotification&quot;</span>, <span class="string">&quot;your payload&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>JS测试脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接并订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&#x27;https://apitest.wemore.com/mylogs/stomp?X-5E-TOKEN=qhMtjBjVozY3zYLrOfMStgvffeFjBofY&#x27;</span>);</span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        setConnected(<span class="literal">true</span>);</span><br><span class="line">        stompClient.subscribe(<span class="string">&#x27;/user/topic/pullNotification&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;received: &#x27; + data);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送消息给服务端</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stompClient.send(<span class="string">&quot;/app/triggerPullNotification&quot;</span>, &#123;&#125;, <span class="built_in">JSON</span>.stringify(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;啥呀&#x27;</span>&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Chrome进行测试，在点击连接时，我们能看到先通过info询问，再调用websocket</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174636617.png" alt="image-20210903174636617"></p>
<p>info的响应</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174721948.png" alt="image-20210903174721948"></p>
<p>websocket的消息流：可以看到就是SockJS帧套STOMP帧。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174749633.png" alt="image-20210903174749633"></p>
<p>其中的[“\n”]和a[“\n”]是STOMP的心跳，我们把视线转移到console看得更为直观，它详细地展示了STOMP的通信过程</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174948448.png" alt="image-20210903174948448"></p>
<p>此时如果我们再触发一次消息，可以观察到消息的发出和接收</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903175110240.png" alt="image-20210903175110240"></p>
<h3 id="强调几点"><a href="#强调几点" class="headerlink" title="强调几点"></a>强调几点</h3><ol>
<li><p><code>HandShakeIntercepter</code>和<code>HandShakeHandler</code>的区别</p>
<ul>
<li><p><code>HandShakeIntercepter</code>前者能够拦截握手的请求，并且可操作直接对握手请求进行响应</p>
</li>
<li><p><code>HandShakeHandler</code>用于处理握手成功后的细节问题，尤其是允许我们自己设置当前session的用户</p>
</li>
<li><p>我们在<code>HandShakeIntercepter</code>进行鉴权；在<code>HandShakeHandler</code>将鉴权得来的用户设置为当前session的用户</p>
</li>
</ul>
</li>
<li><p>心跳</p>
<p>STOMP服务端的心跳一定要配：如果客户端直接采用了WebSocket连接，没有心跳配置，连接可能随时会断</p>
</li>
<li><p>标记用户</p>
<p>这是Spring Stomp为我们提供的方便的功能。它使得我们可以方便地只发送消息给订阅某个主题的单个用户。要完成它，必须有这么几步</p>
<ul>
<li><p>注入我们的用户逻辑，可以迁入Spring Security，也可以自定义。本文中我们在<code>HandShakeHandler</code>中将自己用户体系中的user传递给了Stomp作为用户标记。记得给user实现Principal接口哦。</p>
</li>
<li><p>配置用户地址前缀。并不是每个主题都能支持这样的功能的，我们需要设置一个固定的前缀，那么订阅了这些指定前缀主题的用户，就具有了被标记的能力</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configureMessageBroker</span><span class="params">(registry: <span class="type">MessageBrokerRegistry</span>)</span></span> &#123;</span><br><span class="line">  			... ...</span><br><span class="line">        <span class="comment">// 订阅/user/打头的destination时，STOMP可自动将每个用户对应一个主题，实现向指定用户发送消息的能力</span></span><br><span class="line">        registry.setUserDestinationPrefix(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用规则</p>
<p>需要对地址<code>/topic/pullNotification</code>赋予用户标记的能力，在配置OK后，使用方法</p>
<ul>
<li>客户端订阅地址：<code>/user/topic/pullNotification</code></li>
<li>服务端向指定用户发送消息时，使用：<code>stomp.convertAndSendToUser(12345, &quot;/topic/pullNotification&quot;, &quot;your payload&quot;)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="用Postman调试STOMP服务"><a href="#用Postman调试STOMP服务" class="headerlink" title="用Postman调试STOMP服务"></a>用Postman调试STOMP服务</h2><p>Postman提供WebSocket调试功能，但却不支持调试STOMP服务，这让人感到可惜。但是，如果我们实在想要直接用Postman访问STOMP服务的话。依在下愚见，唯一的办法就是，硬用。即，手动编辑STOMP帧，然后发送。</p>
<p>手动编辑有个问题，STOMP帧是以ASCII码表中值为0的字符结尾的，即<code>&#39;\u0000&#39;</code>，无法通过文本表达。于是只能通过二进制发送。</p>
<p>以上面的服务为例，我们要订阅一个STOMP服务，首先要连接上STOMP端点，然后发送CONNECT帧，然后是SUBSCRIBE帧，帧的二进制编码通过代码生成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> connectMessage = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        CONNECT</span></span><br><span class="line"><span class="string">        heart-beat:5000,5000</span></span><br><span class="line"><span class="string">        accept-version:1.2</span></span><br><span class="line"><span class="string">        host:127.0.0.1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> subscription = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        SUBSCRIBE</span></span><br><span class="line"><span class="string">        id:0</span></span><br><span class="line"><span class="string">        destination:/user/topic/pullNotification</span></span><br><span class="line"><span class="string">        ack:client</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> String.<span class="title">generate</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="keyword">this</span>)</span><br><span class="line">        builder.append(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        builder.append(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        builder.append(<span class="string">&#x27;\u0000&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString().toByteArray().joinToString(separator = <span class="string">&quot;&quot;</span>) &#123; String.format(<span class="string">&quot;%02x&quot;</span>, it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(connectMessage.generate()) <span class="comment">// 434f4e4e4543540a6163636570742d76657273696f6e3a312e320a686f73743a3132372e302e302e310a0a00</span></span><br><span class="line">    println(subscription.generate()) <span class="comment">// 5355425343524942450a69643a300a64657374696e6174696f6e3a2f757365722f746f7069632f70756c6c4e6f74696669636174696f6e0a61636b3a636c69656e740a0a00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面暴露的是SockJS服务，我们有两种方式连接websocket</p>
<ul>
<li>使用SockJS暴露的原生WebSocket端点，即/websocket</li>
<li>使用SockJS协议内容的WebSocket端点，即/server_id/sessioin_id/websocket</li>
</ul>
<p>我们用第一种，然后步骤是</p>
<ol>
<li><p>输入ws端点：wss://&lt;我的域名&gt;/stomp/websocket，点击连接</p>
</li>
<li><p>以二进制格式发送连接帧，重点是选择二进制哦</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_160e941c-6adc-4459-96bf-bbba2d15e4ad.png" alt="企业微信截图_160e941c-6adc-4459-96bf-bbba2d15e4ad"></p>
<p>出现如下响应，说明连接成功</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_293f66bf-25ab-49c4-8312-2f8cba9da8e5.png" alt="企业微信截图_293f66bf-25ab-49c4-8312-2f8cba9da8e5"></p>
</li>
<li><p>发送订阅帧</p>
</li>
<li><p>使用刚才的脚本触发一次echo，你就可以看到我们能够正常收到消息了</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903181047727.png" alt="image-20210903181047727"></p>
</li>
</ol>
<h3 id="有一个问题"><a href="#有一个问题" class="headerlink" title="有一个问题"></a>有一个问题</h3><p>你会发现，通过Postman尽管连上了，但在最后一次通信的60s后，连接自动断开了！！！</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_26269104-19a8-4c63-82dc-af94ce05534e.png" alt="企业微信截图_26269104-19a8-4c63-82dc-af94ce05534e"></p>
<p>这是因为我们没发心跳呀啊啊啊啊啊啊啊啊啊。由于我将服务部署在nginx后，我们的nginx设置为60s不活动的TCP连接都将被关闭。</p>
<p>如何解决呢，要解决，只有两个方法</p>
<ul>
<li>60s内发心跳续命</li>
<li>不停进行消息通信</li>
</ul>
<p>反正就是不停发就行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要使用WebSocket，那么SockJS和STOMP都是必须了解的，最好的了解方式是去看协议。</p>
<p>文中的示例代码，不能直接用，只能当做参考。</p>
<p>Postman调试STOMP？可以用来熟悉协议，但实际用来调试，还是算了吧。</p>
<p>本文重点：三种协议关键点介绍、Spring的STOMP用户标记功能、通过Postman学习STOMP协议帧。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6455.txt.pdf">RFC6455</a></li>
<li><a target="_blank" rel="noopener" href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">SockJS Protocol</a></li>
<li><a target="_blank" rel="noopener" href="https://stomp.github.io/stomp-specification-1.2.html">STOMP Specification</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html">Spring WebSocket</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
